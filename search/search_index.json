{"config":{"lang":["nl"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"","text":""},{"location":"#netherlands3d","title":"Netherlands3D","text":"<p>Netherlands3D, het open-source Digital Twin-framework ontworpen voor Nederland. </p> <p>Door middel van datavisualisatie stelt Netherlands3D u in staat om gedetailleerde, op data gebaseerde modellen weer te  geven.</p> <p>Bekijk de viewer Wat is het?</p>"},{"location":"#wat-is-netherlands3d","title":"Wat is Netherlands3D?","text":""},{"location":"#visualiseren-van-data","title":"Visualiseren van data","text":"<p>Zoek je een mogelijkheid om data aantrekkelijk en in samenhang in  beeld te brengen in een 3D omgeving? Dat kan in Netherlands 3D!</p> <p>Netherlands3D maakt het mogelijk datasets vanaf verschillende bronnen en in verschillende bestandsformaten te koppelen en in samenhang te  visualiseren. Heb je een interessante dataset of link in GeoJSON of WFS  formaat? Ontdek dan hoe deze er in Netherlands 3D uit ziet.  Gecombineerd met andere datasets en in 3D context geeft dit vaak n\u00e8t  dat beetje extra informatie dat je nodig hebt.</p> <p>Naast het visualiseren van data, zijn er ook een aantal functionaliteiten  beschikbaar die je kunt inzetten om jouw project tot een succes te  maken. Kies de relevante tools simpelweg bij het opstarten van  Netherlands 3D.</p>"},{"location":"#wat-onderscheid-netherlands3d-van-andere-viewers","title":"Wat onderscheid Netherlands3D van andere viewers?","text":"<p>Netherlands 3D richt zich op data-visualisatie. Het aantrekkelijk,  integraal en begrijpelijk verbeelden van data staat centraal. </p> <p>Wat Netherlands 3D verder onderscheid is dat jij als gebruiker zelf kiest  welke data er gevisualiseerd wordt en welke functionaliteiten je daarbij  wilt gebruiken. Dus geen lijsten met vooraf gedefinieerde kaartlagen  maar slechts koppelmogelijkheden naar databronnen en externe  applicaties waar jij op dat moment in jouw project behoefte aan hebt.  Denk aan bronnen van jouw lokale server, het landelijke dataloket PDOK  of diverse dataportalen van gemeentelijke en provinciale organisaties.</p>"},{"location":"#heel-nederland-uniform-en-consistent-beschikbaar","title":"Heel Nederland uniform en consistent beschikbaar","text":"<p>Netherlands 3D combineert voor heel Nederland een aantal basis  datasets waardoor een eenduidig 3D beeld van Nederland ontstaat.</p> <p>Op dit moment zijn dat de 3D BAG, de 3D Basisvoorziening en boomlocaties  uit de BGT. Het gezamenlijke 3D beeld dat ontstaat kun je gebruiken als  input voor jouw project. Groot voordeel is dat deze brondata voor heel  Nederland uniform en consistent beschikbaar wordt gemaakt. Dus altijd  gemakkelijk en vanaf \u00e9\u00e9n plek te gebruiken. Het kan ook input zijn als  basis voor rekenmodellen en simulatiesoftware of juist de output  daarvan zijn zodat uitkomsten aan een breed publiek getoond kunnen  worden. Voor het realiseren van koppelingen tussen Netherlands 3D en  reken- simulatie- en analysetools, nodigen we iedereen actief uit om  mee te ontwikkelen.</p>"},{"location":"#3d-omgeving-op-maat","title":"3D omgeving op maat","text":"<p>Wil iets specifieks dat meer aansluit bij jouw project of organisatie?</p> <p>Netherlands 3D biedt een oplossing om een eigen 3D omgeving op maat  in te richten. Bijvoorbeeld een aangepaste startlocatie of vooraf  ingestelde functionaliteiten en datasets. Meldt je dan als organisatie aan. Tot slot is er voor ontwikkelaars de mogelijkheid om actief mee te  bouwen aan het platform. </p> <p>We nodigen iedereen dan ook actief uit om  met ons mee te denken en te bouwen. En wil je dat allemaal niet?  Gebruik dan gewoon de basisviewer van Netherlands 3D hier!</p>"},{"location":"#in-samenwerking-met","title":"In samenwerking met","text":""},{"location":"_nieuws/","title":"nieuws","text":""},{"location":"_nieuws/#nieuws","title":"Nieuws","text":"<ul> <li> <p>Beginnen in 5 minuten</p> <p>Ontdek de mogelijkheden van Netherlands3D.</p> <p>Lees verder </p> </li> <li> <p></p> <p>Je eigen cloud, of niet?</p> <p>Beheer je Netherlands3D zelf of laat je je ontzorgen?</p> <p>Vind het uit </p> </li> <li> <p></p> <p>Toon de kaart die jij wil</p> <p>Wil je jouw project, stad, gemeente of provincie laten zien? Dat kan.</p> <p>Ontdek de opties </p> </li> </ul>"},{"location":"_uitgelicht/","title":"uitgelicht","text":""},{"location":"_uitgelicht/#uitgelicht","title":"Uitgelicht","text":"<ul> <li> <p> Beginnen in 5 minuten</p> <p>Ontdek de mogelijkheden van Netherlands3D.</p> <p>Lees verder </p> </li> <li> <p> Je eigen cloud, of niet?</p> <p>Beheer je Netherlands3D zelf of laat je je ontzorgen?</p> <p>Vind het uit </p> </li> <li> <p> Toon de kaart die jij wil</p> <p>Wil je jouw project, stad, gemeente of provincie laten zien? Dat kan.</p> <p>Ontdek de opties </p> </li> </ul>"},{"location":"_wat-is-netherlands3d/","title":"wat is netherlands3d","text":""},{"location":"_wat-is-netherlands3d/#wat-is-netherlands3d","title":"Wat is Netherlands3D?","text":""},{"location":"_wat-is-netherlands3d/#visualiseren-van-data","title":"Visualiseren van data","text":"<p>Zoek je een mogelijkheid om data aantrekkelijk en in samenhang in  beeld te brengen in een 3D omgeving? Dat kan in Netherlands 3D!</p> <p>Netherlands3D maakt het mogelijk datasets vanaf verschillende bronnen en in verschillende bestandsformaten te koppelen en in samenhang te  visualiseren. Heb je een interessante dataset of link in GeoJSON of WFS  formaat? Ontdek dan hoe deze er in Netherlands 3D uit ziet.  Gecombineerd met andere datasets en in 3D context geeft dit vaak n\u00e8t  dat beetje extra informatie dat je nodig hebt.</p> <p>Naast het visualiseren van data, zijn er ook een aantal functionaliteiten  beschikbaar die je kunt inzetten om jouw project tot een succes te  maken. Kies de relevante tools simpelweg bij het opstarten van  Netherlands 3D.</p>"},{"location":"_wat-is-netherlands3d/#wat-onderscheid-netherlands3d-van-andere-viewers","title":"Wat onderscheid Netherlands3D van andere viewers?","text":"<p>Netherlands 3D richt zich op data-visualisatie. Het aantrekkelijk,  integraal en begrijpelijk verbeelden van data staat centraal. </p> <p>Wat Netherlands 3D verder onderscheid is dat jij als gebruiker zelf kiest  welke data er gevisualiseerd wordt en welke functionaliteiten je daarbij  wilt gebruiken. Dus geen lijsten met vooraf gedefinieerde kaartlagen  maar slechts koppelmogelijkheden naar databronnen en externe  applicaties waar jij op dat moment in jouw project behoefte aan hebt.  Denk aan bronnen van jouw lokale server, het landelijke dataloket PDOK  of diverse dataportalen van gemeentelijke en provinciale organisaties.</p>"},{"location":"_wat-is-netherlands3d/#heel-nederland-uniform-en-consistent-beschikbaar","title":"Heel Nederland uniform en consistent beschikbaar","text":"<p>Netherlands 3D combineert voor heel Nederland een aantal basis  datasets waardoor een eenduidig 3D beeld van Nederland ontstaat.</p> <p>Op dit moment zijn dat de 3D BAG, de 3D Basisvoorziening en boomlocaties  uit de BGT. Het gezamenlijke 3D beeld dat ontstaat kun je gebruiken als  input voor jouw project. Groot voordeel is dat deze brondata voor heel  Nederland uniform en consistent beschikbaar wordt gemaakt. Dus altijd  gemakkelijk en vanaf \u00e9\u00e9n plek te gebruiken. Het kan ook input zijn als  basis voor rekenmodellen en simulatiesoftware of juist de output  daarvan zijn zodat uitkomsten aan een breed publiek getoond kunnen  worden. Voor het realiseren van koppelingen tussen Netherlands 3D en  reken- simulatie- en analysetools, nodigen we iedereen actief uit om  mee te ontwikkelen.</p>"},{"location":"_wat-is-netherlands3d/#3d-omgeving-op-maat","title":"3D omgeving op maat","text":"<p>Wil iets specifieks dat meer aansluit bij jouw project of organisatie?</p> <p>Netherlands 3D biedt een oplossing om een eigen 3D omgeving op maat  in te richten. Bijvoorbeeld een aangepaste startlocatie of vooraf  ingestelde functionaliteiten en datasets. Meldt je dan als organisatie aan. Tot slot is er voor ontwikkelaars de mogelijkheid om actief mee te  bouwen aan het platform. </p> <p>We nodigen iedereen dan ook actief uit om  met ons mee te denken en te bouwen. En wil je dat allemaal niet?  Gebruik dan gewoon de basisviewer van Netherlands 3D hier!</p>"},{"location":"articles/","title":"Artikelen","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam sodales est nec dolor luctus cursus. Sed tincidunt orci fermentum varius mattis. Quisque ut molestie augue, sit amet ornare sem. Praesent sit amet auctor nisi. Vivamus ornare tincidunt arcu in euismod. Proin ipsum ante, semper et sollicitudin eget, venenatis maximus nulla. Suspendisse potenti. Nulla facilisi.</p>"},{"location":"articles/2024/04/25/nieuwe-website/","title":"Nieuwe website","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam sodales est nec dolor luctus cursus. Sed tincidunt orci fermentum varius mattis. Quisque ut molestie augue, sit amet ornare sem. Praesent sit amet auctor nisi. Vivamus ornare tincidunt arcu in euismod. Proin ipsum ante, semper et sollicitudin eget, venenatis maximus nulla. Suspendisse potenti. Nulla facilisi.</p> <p>Fusce rutrum mi vel purus interdum imperdiet. Curabitur tempus fermentum odio et venenatis. In hac habitasse platea dictumst. Praesent pellentesque odio vel suscipit malesuada. Nulla facilisis mauris euismod pulvinar ullamcorper. Ut tincidunt lacus vitae nibh faucibus iaculis. Phasellus vitae risus ex.</p> <p>Donec at orci urna. Ut ac turpis nec quam luctus cursus. Nunc lobortis quam vitae iaculis dignissim. Vestibulum pretium, nulla id volutpat luctus, mauris leo rhoncus tortor, ut fringilla massa purus in erat. Donec blandit id sem et accumsan. Pellentesque at eleifend urna. Mauris quis odio odio. Interdum et malesuada fames ac ante ipsum primis in faucibus. Vivamus sollicitudin magna libero, eget congue odio mollis gravida. Praesent arcu tellus, ultrices id porttitor vitae, tincidunt quis dolor. Vivamus aliquet nulla non augue molestie, sed elementum nisl maximus. Curabitur ut augue eu urna ornare hendrerit sed at dolor. Duis vulputate ullamcorper viverra. Proin id urna sed turpis euismod blandit. Etiam gravida ipsum eu ligula lacinia, ut ultricies magna porta. Cras sem metus, commodo tincidunt ultricies fringilla, facilisis sit amet enim.</p> <p>Pellentesque nibh dui, iaculis at vehicula in, iaculis ut dui. Donec ac nisl eget massa pellentesque vehicula. Morbi interdum magna ac leo malesuada commodo. Nulla ac risus ut lectus eleifend semper. Nullam placerat sem quis lectus aliquam tristique. Nullam ante nisl, laoreet ut elit eu, laoreet gravida ex. Aenean eget sagittis magna. Donec non faucibus leo. Nullam rutrum euismod nisl, sed consequat arcu imperdiet et. Vivamus sit amet mi placerat, luctus sem a, posuere sem. Aliquam feugiat est eget risus dapibus efficitur.</p> <p>Nam vehicula sollicitudin nibh, at efficitur ligula tincidunt in. Pellentesque turpis nibh, tempor vitae consequat non, molestie ac turpis. Duis tempor vulputate urna, non iaculis velit faucibus vel. Aliquam erat volutpat. Donec eu porttitor lacus, in dignissim odio. Nam at laoreet sapien, pharetra scelerisque sapien. Nulla sed quam pretium, pellentesque dolor pharetra, aliquam nulla.</p>"},{"location":"docs/developers/adding-a-simple-type-of-layer/","title":"Adding a simple type of layer","text":"<p>In this step-by-step guide, you\u2019ll learn to add a new layer type, ideal for developers ready to start building within the platform.</p> <p>Note: Steps 6 and 7 may change as functionalities become more independent, reducing the need for adjustments in the  Twin application.</p>"},{"location":"docs/developers/adding-a-simple-type-of-layer/#step-1-pick-a-functionality-or-create-a-new-one","title":"Step 1: Pick a Functionality, or Create a New One","text":"<p> Layers are part of a Functionality and to maintain the necessary structure it is recommended to pick the functionality to which the layer should belong or, if this is the first time adding your own material,it is recommended to create  your own.</p> <p>To create a Functionality, create a subfolder in <code>Assets/_Functionalities</code> and name it after the functionality that will  manage this new layer, and add a new subfolder <code>Prefabs</code> to it; here we will place our new layer prefab.</p>"},{"location":"docs/developers/adding-a-simple-type-of-layer/#step-2-create-a-prefab-to-visualize-the-layer","title":"Step 2: Create a Prefab to Visualize the Layer","text":"<p>Create a new prefab to represent your layer. This can include 3D objects as needed for the layer's visual appearance. This prefab serves as the visual representation of your data in the 3D viewer.</p> <p>An example of this could be a Prefab that we call '2 Cubes', where we add two Cubes from Unity's '3D Object' creation  menu.</p>"},{"location":"docs/developers/adding-a-simple-type-of-layer/#step-3-attach-the-hierarchicalobjectlayergameobject-component","title":"Step 3: Attach the <code>HierarchicalObjectLayerGameObject</code> Component","text":"<p>Add the <code>HierarchicalObjectLayerGameObject</code> MonoBehaviour to your prefab. Leave the <code>Prefab Identifier</code> field empty or assign a unique identifier to make sure this layer is globally unique. This identifier will allow the prefab to register as a new layer within the layer system upon instantiation.</p> <p>This component will automatically add a Layer -to the project and in the UI- when an instance of this prefab is  added to the scene. </p> <p>Leaving the <code>Prefab Identifier</code> empty will allow for the <code>PrefabLibrary</code> (see Step 6) to assign a unique identifier, thus populating it when the prefab is added to the library.</p>"},{"location":"docs/developers/adding-a-simple-type-of-layer/#step-4-add-the-worldtransform-component","title":"Step 4: Add the WorldTransform Component","text":"<p>To ensure the object holds real-world coordinates and remains anchored in place as the user navigates, add the WorldTransform MonoBehaviour to your prefab. This enables the object to maintain accurate positioning in the 3D environment.</p> <p>The World Transform is similar to, and extends, Unity's own Transform, it provides the means for an object to be  located in a real world position and to track that. </p> <p>When you want to move a GameObject with a WorldTransform, it is highly recommended to do that by changing the Coordinates on the WorldTransform instead of the <code>transform.position</code>.</p>"},{"location":"docs/developers/adding-a-simple-type-of-layer/#step-5-optional-add-transform-properties-to-your-layer","title":"Step 5: (Optional) Add Transform properties to your layer","text":"<p>If you want users to reposition, rotate, or scale this layer in the viewer, add the <code>HierarchicalObjectPropertySectionInstantiator</code> component. Set its Property Section Reference to  <code>TransformPropertySection</code>, enabling these manipulations within the project and allowing them to persist in the  <code>.nl3d</code> project file.</p> <p>You can learn more about properties and property sections in the explanation section of the documentation.</p>"},{"location":"docs/developers/adding-a-simple-type-of-layer/#step-6-register-the-prefab-in-the-prefablibrary","title":"Step 6: Register the Prefab in the PrefabLibrary","text":"<p>To ensure the layer system recognizes and loads this layer, add your prefab to the <code>PrefabLibrary</code> ScriptableObject. In  it, you can either create a new prefab group or add it to an existing one for organization.</p>"},{"location":"docs/developers/adding-a-simple-type-of-layer/#step-7-if-needed-create-ui-elements-to-add-your-layer","title":"Step 7: (If Needed) Create UI Elements to Add Your Layer","text":"<p>If you created a new prefab group, or added your prefab to a group without the <code>auto-populate UI</code> toggle enabled, add  UI elements to allow users to instantiate this layer. The default location is within the <code>AddLayerPanel</code> prefab, which  serves as the UI hub for adding layers.</p>"},{"location":"docs/developers/adding-behaviour-to-a-layer-with-data/","title":"Adding behaviour to a layer with data","text":"<p>This guide will focus on adding functional behavior to a layer using persisted data. It will provide the structure for a headless approach to layer properties, enabling custom layer behavior without exposing settings to the end user.</p> <p>Properties in this platform are modular, making it possible to attach reusable \u201cproperty sections\u201d to a layer rather  than defining specific fields. This modular approach allows data persistence when saving and reloading projects, with  Netherlands3D managing persistence automatically.</p> <p>This guide builds on the previous steps for creating a simple layer type. Here, we'll add properties that are stored  within the layer\u2019s data but without displaying them in the properties panel UI.</p> <p>About the examples</p> <p>The code examples are meant to show a simple scenario where you have a layer with 2 cubes and where we add behaviour for users to change the colour randomly by clicking on a cube, and where that colour is persisted between sessions. It is expected that for your own use-case you can adapt these examples to suit your situation.</p>"},{"location":"docs/developers/adding-behaviour-to-a-layer-with-data/#step-1-create-a-controller-script-with-ilayerwithpropertydata","title":"Step 1: Create a Controller Script with <code>ILayerWithPropertyData</code>","text":"<p>Begin by creating a <code>MonoBehaviour</code> script to encapsulate behaviour for your layer. This behaviour script will handle  the interactions with your property data. To start, implement the <code>ILayerWithPropertyData</code> interface in the script.  This interface includes a <code>LoadProperties</code> method, which we\u2019ll define in a later step. For now, leave the  <code>LoadProperties</code> method empty, focusing on setting up the controller structure.</p> <p>The code:</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Netherlands3D.Twin.Layers;\nusing Netherlands3D.Twin.Layers.Properties;\nusing UnityEngine;\n\n[RequireComponent(typeof(LayerGameObject))]\npublic class TwoCubesColorChangingBehaviour : MonoBehaviour, ILayerWithPropertyData\n{\n    private LayerPropertyData propertyData;\n    public LayerPropertyData PropertyData =&gt; propertyData;\n\n    public void LoadProperties(List&lt;LayerPropertyData&gt; properties)\n    {\n    }\n\n    // implement the on click behaviour that will randomly change the \n    // color on one of the cubes; this is omitted for brevity\n}\n</code></pre> <p>In subsequent code samples some parts will be omitted for brevity -such as the import statements-.</p>"},{"location":"docs/developers/adding-behaviour-to-a-layer-with-data/#step-2-define-a-property-data-class","title":"Step 2: Define a Property Data Class","text":"<p>Next, create a dedicated class to represent the data fields you want to persist. This class should extend the <code>LayerPropertyData</code> superclass, which provides a foundation for layer properties. By extending <code>LayerPropertyData</code>, this class becomes capable of being serialized and deserialized by JSON.net, which  Netherlands3D uses to store and retrieve data within <code>.nl3d</code> project files. </p> <p>The data fields in this class should only represent state, with no embedded business logic, ensuring data integrity and  predictability.</p> <p>The code:</p> <pre><code>using System.Runtime.Serialization;\nusing Newtonsoft.Json;\nusing UnityEngine.Events;\n\npublic class TwoCubesColorPropertyData : LayerPropertyData\n{\n    // We will be adding fields in the next step\n}\n</code></pre>"},{"location":"docs/developers/adding-behaviour-to-a-layer-with-data/#step-3-add-fields-to-the-property-data-class","title":"Step 3: Add Fields to the Property Data Class","text":"<p>Now, add the fields to the property data class that you want to persist. For serialization and future compatibility, use a <code>DataContract</code> annotation on the class. This annotation should include a <code>Namespace</code> attribute, typically a URI  associated with your organization, to uniquely identify the origin of the class. In addition, a <code>Name</code> attribute provides  a clear, recognizable identifier for this data type.</p> <p>When defining fields, it is encouraged to use a <code>UnityEvent</code> alongside a C# property to trigger an event whenever a  property changes. This approach will allow the behaviour script to detect changes in state through events, making the  class versatile and responsive.</p> <p>The code:</p> <pre><code>...\n\n[DataContract(Namespace = \"https://example.org/schemas/my-nl3d-project\", Name = \"TwoCubesColor\")]\npublic class TwoCubesColorPropertyData : LayerPropertyData\n{\n    [DataMember] private Color cube1Color = Color.white;\n    [DataMember] private Color cube2Color = Color.red;\n\n    [JsonIgnore] public readonly UnityEvent&lt;Color&gt; Cube1ColorChanged = new();\n    [JsonIgnore] public readonly UnityEvent&lt;Color&gt; Cube2ColorChanged = new();\n\n    [JsonIgnore]\n    public Color Cube1Color\n    {\n        get =&gt; cube1Color;\n        set\n        {\n            cube1Color = value;\n            Cube1ColorChanged.Invoke(cube1Color);\n        }\n    }\n\n    [JsonIgnore]\n    public Color Cube2Color\n    {\n        get =&gt; cube2Color;\n        set\n        {\n            cube2Color = value;\n            Cube2ColorChanged.Invoke(cube2Color);\n        }\n    }\n}\n</code></pre>"},{"location":"docs/developers/adding-behaviour-to-a-layer-with-data/#step-4-wiring-the-controller-script-to-the-property-data","title":"Step 4: Wiring the Controller Script to the Property Data","text":"<p>With your property data class in place, return to the controller script and establish the connection between it and your properties. Start by creating a private field in the controller script, using the property data class you defined in Step 2. Next, set the controller's <code>PropertyData</code> getter to retrieve data from this field. Finally, implement the <code>LoadProperties</code> method by populating it with the necessary code to retrieve the correct <code>LayerPropertyData</code> object from  the layer at load time.</p> <p>Each controller can contain only one LayerPropertyData instance.</p> <p>This ensures the controller is dedicated to a single cohesive set of properties and promotes modularity, allowing  the controller to be reused across different layers without modification. For more information, see the explanation section on layers and properties.</p> <p>The code:</p> <pre><code>[RequireComponent(typeof(LayerGameObject))]\npublic class TwoCubesColorChangingBehaviour : MonoBehaviour, ILayerWithPropertyData\n{\n    // Note this change -&gt; We have replaced the generic LayerPropertyData with TwoCubesColorPropertyData\n    private TwoCubesColorPropertyData  propertyData;\n    public LayerPropertyData PropertyData =&gt; propertyData;\n\n    private void Start()\n    {\n        // Initialise the behaviour with properties from the propertyData - this will trigger upon loading a new project\n        OnCube1ColorChanged(propertyData.Cube1Color);\n        OnCube2ColorChanged(propertyData.Cube2Color);\n    }\n\n    public void LoadProperties(List&lt;LayerPropertyData&gt; properties)\n    {\n        // Find the property data for this behaviour in the list of properties belonging to its parent layer\n        properties = properties.OfType&lt;TwoCubesColorPropertyData&gt;().FirstOrDefault();\n\n        // if we found something, use that\n        if (properties != null)\n        {\n            propertyData = properties;\n        }\n\n        // if nothing is provided, or propertyData is otherwise null; make sure we have a default \n        propertyData ??= new();\n\n        // Add the listeners to allow this behaviour to respond to change in its state\n        propertyData.Cube1ColorChanged.AddListener(OnCube1ColorChanged);\n        propertyData.Cube2ColorChanged.AddListener(OnCube2ColorChanged);\n    }\n\n    private void OnCube1ColorChanged(Color colour)\n    {\n        // Implement the logic to apply this color to cube 1\n    }\n\n    private void OnCube2ColorChanged(Color colour)\n    {\n        // Implement the logic to apply this color to cube 2\n    }\n\n    private void OnDestroy()\n    {\n        propertyData.Cube1ColorChanged.RemoveListener(OnCube1ColorChanged);\n        propertyData.Cube2ColorChanged.RemoveListener(OnCube2ColorChanged);\n    }\n}\n</code></pre>"},{"location":"docs/developers/adding-behaviour-to-a-layer-with-data/#step-5-add-the-new-behavior-to-the-layer-prefab","title":"Step 5: Add the New Behavior to the Layer Prefab","text":"<p>To integrate your new persistent behavior with the layer, attach the behaviour script to the prefab for your layer. By adding the behaviour script, you enable the layer to utilize the persisted properties, allowing it to execute  specific behaviours based on saved data.</p>"},{"location":"docs/developers/build-pipeline/","title":"Our Build Pipeline","text":""},{"location":"docs/developers/build-pipeline/#what-is-a-build-or-ci-pipeline","title":"What is a Build, or CI, Pipeline?","text":"<p>Already know this?</p> <p>If you are familiar with the concept of Continuous Integration or Build Pipelines, feel free to skip ahead to the chapter \"Overview of the Build Pipeline\".</p> <p>A build pipeline, sometimes called a Continuous Integration (https://en.wikipedia.org/wiki/Continuous_integration) Pipeline, is a sequence of automated processes that converts source code into a deployable application. It enables developers to:</p> <ol> <li>Compile and build the application.</li> <li>Run automated tests to ensure code quality.</li> <li>Package the application for deployment.</li> <li>Deploy the application to the target environment.</li> </ol> <p>A critical aspect of a build pipeline is its ability to identify issues with the source code as early as possible in an automated way before deployment. The primary goal of a build pipeline is to \"fail fast.\" This means identifying issues early in the process to reduce wasted effort and allow developers to address problems as soon as they arise. Jobs and steps are generally constructed in such a way to aid in this process, ensuring that critical checks occur early and provide immediate feedback. </p>"},{"location":"docs/developers/build-pipeline/#jobs-in-a-build-pipeline","title":"Jobs in a Build Pipeline","text":"<p>Build pipelines are generally organized into jobs, each representing a major step in the development lifecycle. Note that in other CI systems, jobs may be referred to as stages.</p> <p>For example:</p> <ol> <li>Checkout: Retrieves the latest source code from version control.</li> <li>Build: Compiles the code and resolves dependencies.</li> <li>Test: Executes automated tests.</li> <li>Deploy: Publishes the built artifacts to a production or staging environment.</li> </ol> <p>Please see the next chapter how our build pipeline is set up.</p>"},{"location":"docs/developers/build-pipeline/#build-steps-in-a-job","title":"Build Steps in a Job","text":"<p>Each job consists of smaller units called steps, which represent discrete tasks. For instance, a step might involve running a specific script, configuring an environment, or uploading an artifact.</p>"},{"location":"docs/developers/build-pipeline/#overview-of-the-build-pipeline","title":"Overview of the Build Pipeline","text":"<p>Tip</p> <p>You can find the definition of our pipeline here.</p> <p>Netherlands3D uses GitHub Actions as its Continuous Integration (CI) solution to execute pipelines. </p> <p>The platform employs the principle of Continuous Deployment to automatically build and deploy changes as soon as they are pushed to the main branch. This ensures that the latest updates are always available  in production, reducing manual intervention and speeding up the release cycle.</p> <p>The build pipeline defined in the GitHub Actions workflow  consists of two primary flows:</p> <ol> <li> <p>Pull Request Flow: When a branch is created or updated, a development build of the viewer is triggered. The    resulting artifact, named <code>viewer-development</code>, is stored and can be downloaded from the build page in the     GitHub Actions interface. Developers can use this build for     debugging or profiling locally.</p> </li> <li> <p>Main Branch Flow: When a commit is pushed to the <code>main</code> branch,     both development and production builds are triggered:</p> <ul> <li>The development build produces an artifact (<code>viewer-development</code>) for debugging purposes.</li> <li> <p>The production build generates a production-ready artifact (<code>viewer</code>) at the same time, and then concurrently</p> <ul> <li>Deploys the viewer to GitHub Pages.</li> <li>Builds and publishes a Docker image containing the production viewer.</li> </ul> </li> </ul> </li> </ol> <p>Below is a visual representation of the pipeline:</p> <pre><code>graph TD\n    Start([Commit is Pushed])\n    MainOrPR{Pushed to *Main*&lt;br&gt;or&lt;br&gt;a Feature Branch}\n    End([Build Complete])\n\n    Start --&gt; MainOrPR\n    MainOrPR --&gt; DevBuild\n    MainOrPR --&gt; MainBuild\n    DevBuild --&gt; End\n    B--&gt; End\n\n    subgraph Push to Feature Branch\n        DevBuild[Build Development Viewer]\n        DevBuild\n    end\n    subgraph Push to Main\n        DevArtifact[Build Development Viewer]\n        ProdArtifact[Build Production Viewer]\n        MainBuild@{ shape: fork, label: \"Fork or Join\" }\n        A@{ shape: fork, label: \"Fork or Join\" }\n        B@{ shape: fork, label: \"Fork or Join\" }\n        Deploy[Deploy to GitHub Pages]\n        Docker[Build and Publish Docker Image]\n\n        MainBuild --&gt; DevArtifact --&gt; B\n        MainBuild --&gt; ProdArtifact\n        ProdArtifact --&gt; A\n        A --&gt; Deploy --&gt; B\n        A --&gt; Docker --&gt; B\n    end</code></pre>"},{"location":"docs/developers/build-pipeline/#jobs-and-steps","title":"Jobs and Steps","text":""},{"location":"docs/developers/build-pipeline/#pull-request-flow","title":"Pull Request Flow","text":""},{"location":"docs/developers/build-pipeline/#build-development-viewer","title":"Build Development Viewer","text":"<p>The goal of this job is to create a development build of the Netherlands3D viewer that includes debugging options. This build allows developers to test, debug, and profile the application locally. The resulting artifact, named <code>viewer-development</code>, is stored and available for download.</p> <ol> <li>Free Disk Space: Frees up runner storage for the build.</li> <li>Checkout Repository: Retrieves the repository's code.</li> <li>Cache Dependencies: Speeds up builds by caching the Unity <code>Library</code> folder.</li> <li>Build Unity Project: Builds a development version of the viewer with    debugging options enabled.</li> <li>Upload Development Artifact: Stores the development build as    <code>viewer-development</code>.</li> </ol>"},{"location":"docs/developers/build-pipeline/#main-branch-flow","title":"Main Branch Flow","text":""},{"location":"docs/developers/build-pipeline/#build-development-viewer_1","title":"Build Development Viewer","text":"<p>This is the exact same job as used in the Build Development Viewer job of the Pull Request Flow, see that chapter for more information.</p>"},{"location":"docs/developers/build-pipeline/#build-production-viewer","title":"Build Production Viewer","text":"<p>The goal of this job is to create a production-ready build of the Netherlands3D viewer. This build is optimized for deployment and does not include debugging options. The resulting artifact, named <code>viewer</code>, is used in subsequent deployment and Dockerization steps.</p> <ol> <li>Free Disk Space: Frees up runner storage for the build.</li> <li>Checkout Repository: Retrieves the repository's code.</li> <li>Cache Dependencies: Speeds up builds by caching the Unity <code>Library</code> folder.</li> <li>Build Unity Project: Builds a production version of the viewer.</li> <li>Upload Production Artifact: Stores the production build as <code>viewer</code>.</li> </ol>"},{"location":"docs/developers/build-pipeline/#deploy-to-github-pages","title":"Deploy to GitHub Pages","text":"<p>The goal of this job is to deploy the production build of the Netherlands3D viewer to GitHub Pages. This ensures that the latest version of the viewer is accessible via https://netherlands3d.eu/twin.</p> <ol> <li>Download Production Artifact: Retrieves the production build    artifact.</li> <li>Prepare Artifact for Deployment: Prepares the artifact    for GitHub Pages.</li> <li>Deploy to GitHub Pages: Publishes the production viewer.</li> </ol>"},{"location":"docs/developers/build-pipeline/#build-and-publish-docker-image","title":"Build and Publish Docker Image","text":"<p>The goal of this job is to create a Docker image containing the production build of the Netherlands3D viewer. The image is then pushed to the GitHub Container Registry, enabling easy deployment to containerized environments.</p> <ol> <li>Download Production Artifact: Retrieves the production build artifact.</li> <li>Login to Docker: Authenticates with Docker to push the image.</li> <li>Build and Push Docker Image: Creates and uploads the Docker image.</li> </ol>"},{"location":"docs/developers/build-pipeline/#reference-environment-variables","title":"Reference: Environment Variables","text":"<p>The following environment variables are defined in the build pipeline to standardize and simplify configurations:</p> <ul> <li><code>BUILD_OUTPUT_FOLDER</code>: Specifies the folder where the build output for the WebGL viewer is stored (   <code>build/WebGL/WebGL</code>). This path is used across jobs to locate the built artifacts.</li> <li><code>PRODUCTION_BUILD_ARTEFACT_NAME</code>: Defines the name of the artifact created for production builds (<code>viewer</code>). This is   used for identifying the production-ready build in artifact storage and subsequent deployment jobs.</li> <li><code>DEVELOPMENT_BUILD_ARTEFACT_NAME</code>: Defines the name of the artifact created for development builds (   <code>viewer-development</code>). This is used for storing builds meant for debugging and testing.</li> </ul> <p>These environment variables ensure consistency and reduce hardcoding of values across multiple steps in the workflow.</p>"},{"location":"docs/developers/build-pipeline/#reference-actions-in-depth","title":"Reference: Actions in Depth","text":""},{"location":"docs/developers/build-pipeline/#free-disk-space-jlumbrosofree-disk-space","title":"Free Disk Space (jlumbroso/free-disk-space)","text":"<p>This step ensures sufficient storage on the GitHub Actions runner by removing unnecessary tools and files. It's critical for resource-intensive builds like Unity.</p> <p>Inputs</p> <ul> <li><code>tool-cache</code>: Determines if the tool cache should be cleared. Default is <code>false</code>.</li> <li><code>android</code>, <code>dotnet</code>, <code>haskell</code>, <code>docker-images</code>, <code>swap-storage</code>: Specify which resources to clean up. All default to   <code>true</code> except <code>large-packages</code>.</li> </ul>"},{"location":"docs/developers/build-pipeline/#checkout-repository-actionscheckout","title":"Checkout Repository (actions/checkout)","text":"<p>This step retrieves the source code from the repository, including support for large files managed by Git LFS.</p> <p>Inputs</p> <ul> <li><code>lfs</code>: Fetches Git LFS objects if set to <code>true</code>.</li> </ul>"},{"location":"docs/developers/build-pipeline/#cache-dependencies-actionscache","title":"Cache Dependencies (actions/cache)","text":"<p>Caches the Unity <code>Library</code> folder to avoid redundant imports and expedite builds.</p> <p>Inputs</p> <ul> <li><code>path</code>: Folder to cache, such as <code>Library</code>.</li> <li><code>key</code>: Unique cache key, typically derived from file hashes.</li> <li><code>restore-keys</code>: Fallback keys if the primary cache key is not found.</li> </ul>"},{"location":"docs/developers/build-pipeline/#build-unity-project-game-ciunity-builder","title":"Build Unity Project (game-ci/unity-builder)","text":"<p>Compiles the Unity project for WebGL. For pull requests, development builds are configured with debugging options.</p> <p>Inputs</p> <ul> <li><code>targetPlatform</code>: Specifies <code>WebGL</code> as the build target.</li> <li><code>unityVersion</code>: Detects the Unity version automatically.</li> <li><code>customParameters</code>: Adds parameters like <code>-Development</code> and <code>-AllowDebugging</code> for development builds.</li> </ul>"},{"location":"docs/developers/build-pipeline/#upload-artifact-actionsupload-artifact","title":"Upload Artifact (actions/upload-artifact)","text":"<p>Saves the build outputs as downloadable artifacts for later use.</p> <p>Inputs</p> <ul> <li><code>name</code>: Name of the artifact (<code>viewer</code> or <code>viewer-development</code>).</li> <li><code>path</code>: Path to the files to upload (<code>build/WebGL/WebGL</code>).</li> </ul>"},{"location":"docs/developers/build-pipeline/#download-artifact-actionsdownload-artifact","title":"Download Artifact (actions/download-artifact)","text":"<p>Retrieves previously uploaded artifacts, enabling other jobs to access the build outputs.</p> <p>Inputs</p> <ul> <li><code>name</code>: Name of the artifact to download.</li> <li><code>path</code>: Path to store the downloaded artifact.</li> </ul>"},{"location":"docs/developers/build-pipeline/#prepare-artifact-for-deployment-actionsupload-pages-artifact","title":"Prepare Artifact for Deployment (actions/upload-pages-artifact)","text":"<p>This step prepares the production build artifact for deployment to GitHub Pages.</p> <p>Inputs</p> <ul> <li><code>path</code>: Specifies the location of the artifact to be uploaded for deployment.</li> </ul>"},{"location":"docs/developers/build-pipeline/#deploy-to-github-pages-actionsdeploy-pages","title":"Deploy to GitHub Pages (actions/deploy-pages)","text":"<p>Publishes the production viewer to GitHub Pages, making it accessible at https://netherlands3d.eu/twin.</p>"},{"location":"docs/developers/build-pipeline/#login-to-docker-dockerlogin-action","title":"Login to Docker (docker/login-action)","text":"<p>This step logs into Docker using credentials provided via GitHub Actions, enabling the push of Docker images to the GitHub Container Registry for the twin repository.</p> <p>Inputs</p> <ul> <li><code>registry</code>: Specifies the Docker registry (e.g., <code>ghcr.io</code>).</li> <li><code>username</code>: Username for the registry, typically the GitHub actor.</li> <li><code>password</code>: Access token or password used for authentication.</li> </ul>"},{"location":"docs/developers/build-pipeline/#build-and-push-docker-image-dockerbuild-push-action","title":"Build and Push Docker Image (docker/build-push-action)","text":"<p>Creates and publishes a Docker image containing the production viewer at the GitHub Container Registry for the twin repository.</p> <p>Inputs</p> <ul> <li><code>context</code>: Build context, usually the repository root.</li> <li><code>file</code>: Path to the Dockerfile.</li> <li><code>tags</code>: Tags for the Docker image (e.g., <code>latest</code>).</li> <li><code>build-args</code>: Build arguments, such as the artifact path.</li> </ul>"},{"location":"docs/developers/core-concepts/","title":"Core Concepts","text":"<p>Whether you are plotting sensor telemetry, planning new building projects, or mapping underground utilities like cables and pipes, Netherlands3D offers a versatile environment to bring your spatial data to life. This page introduces the key concepts behind the platform, providing a foundation for understanding how the application is structured and how you can leverage it for your projects.</p>"},{"location":"docs/developers/core-concepts/#projects-the-canvas-of-your-work","title":"Projects: The Canvas of Your Work","text":"<p>In Netherlands3D, everything you interact with on the screen is part of a Project. A project encompasses all the data layers, styles, and configurations that define your current view and can be saved or loaded as needed. Think of a project as a snapshot of your work, capturing everything from the base map to the overlaid datasets, and allowing you to revisit or share your work with others seamlessly.</p>"},{"location":"docs/developers/core-concepts/#layers-the-foundation-of-visualization","title":"Layers: The Foundation of Visualization","text":"<p>In Netherlands3D, Layers are the fundamental components that bring spatial data to life on the map. Each layer represents a specific dataset, determining not only what data is visualized but also how it appears. </p> <p>While Rasterlayers and Vectorlayers are the primary types, there are also additional supporting layers like folders and  scenarios that help organize your project. However, the focus of this chapter will be on understanding the two main  types of layers and the nature of the datasets they contain.</p>"},{"location":"docs/developers/core-concepts/#understanding-datasets-tiled-vs-fixed","title":"Understanding Datasets: Tiled vs. Fixed","text":"<p>Before diving into the specifics of Raster and Vector layers, it's important to understand the concept of how datasets are handled: Tiled versus Fixed.</p> <ul> <li> <p>Tiled Datasets: Tiling is a method used to optimize the performance of large datasets by breaking them down into smaller, more manageable pieces called tiles. These tiles are loaded dynamically as needed, which is especially useful when working with high-resolution data or when users need to navigate large geographical areas. Tiled datasets ensure that only the necessary portions of data are loaded at any given time, reducing memory usage and enhancing performance.</p> </li> <li> <p>Fixed Datasets: In contrast, fixed datasets are loaded in their entirety at once. This approach can be beneficial    when working with smaller datasets or when it's crucial to have immediate access to all the data without waiting for    it to stream. However, this method can be more demanding on system resources, particularly for large or complex    datasets.</p> </li> </ul> <p>The choice between tiled and fixed datasets affects how the data is visualized and interacted with in Netherlands3D. Whether a dataset is continuous (like elevation data) or discrete (like building footprints), it can be managed using either a tiled or fixed approach.</p>"},{"location":"docs/developers/core-concepts/#rasterlayers-visualizing-continuous-data","title":"Rasterlayers: Visualizing Continuous Data","text":"<p>Rasterlayers are used to display continuous data across a geographic area, such as heatmaps, terrain models, or aerial images. These layers are ideal for visualizing information that smoothly varies over space, like temperature changes across a city or elevation in a landscape.</p> <p>In Netherlands3D, Rasterlayers are powerful for showing broad, sweeping patterns in your data. For example, if you want to understand how pollution levels vary across a region, a Rasterlayer can provide a clear, visual representation of these gradients.</p>"},{"location":"docs/developers/core-concepts/#vectorlayers-representing-discrete-data","title":"Vectorlayers: Representing Discrete Data","text":"<p>Vectorlayers are used to map specific features like buildings, roads, utilities, or zones. Each feature is represented by points, lines, or polygons, and comes with attributes that describe it \u2014such as the height of a building or the type of road.</p> <p>Vectorlayers are essential for projects that require precise and detailed mapping. For instance, when planning new infrastructure, you can use Vectorlayers to map out exactly where new roads or pipelines will go. Each feature can be styled differently based on its attributes, making it easy to distinguish between different types of data.</p>"},{"location":"docs/developers/core-concepts/#features-the-building-blocks-of-layers","title":"Features: The Building Blocks of Layers","text":"<p>In Netherlands3D, Features are the individual elements that make up a Vectorlayer and can also be present in certain modern Rasterlayers. A feature represents a distinct geographical entity, such as a building, road, or zone, and can be styled and visualized according to your project\u2019s needs.</p> <p>Understanding features is crucial because they are the entities you interact with and analyze within a layer.  Whether you are drawing a map of utilities, defining zoning regulations, or visualizing sensor data, you are  essentially working with features. </p> <p>The ability to style and categorize these features, especially within the context of both vector and hybrid raster layers, provides the flexibility to create detailed, informative, and visually compelling maps.</p>"},{"location":"docs/developers/core-concepts/#features-in-vectorlayers","title":"Features in Vectorlayers","text":"<p>For Vectorlayers, features are the fundamental units. Each feature within a Vectorlayer has a specific geometry (point, line, or polygon) and is tied to a set of attributes that describe its properties. For example, a Vectorlayer representing buildings might have features corresponding to individual buildings, with attributes detailing their height, function, or construction material. These features can be styled in various ways using the platform's styling options, allowing you to differentiate between types of buildings, emphasize certain zones, or highlight critical infrastructure.</p>"},{"location":"docs/developers/core-concepts/#features-in-rasterlayers-the-hybrid-approach","title":"Features in Rasterlayers: The Hybrid Approach","text":"<p>Traditionally, Rasterlayers \u2014such as overlay images or heatmaps\u2014 do not contain discrete features. They represent continuous data spread across a grid, where each cell or pixel has a value but is not individually distinguished as a feature. However, with advances in 3D mapping technology, a new hybrid approach has emerged.</p> <p>In this modern method, certain Rasterlayers, especially those involving 3D meshes, may incorporate features. For example, a 3D terrain mesh (which is typically raster data) can have specific parts of the mesh categorized as features. These features within a Rasterlayer might represent distinct geographical areas, such as regions of interest or zones within a city, and can be individually styled and interacted with, similar to features in Vectorlayers. This blending of raster and vector data allows for a more nuanced and detailed representation of the environment, offering new possibilities for visualizing and analyzing spatial data.</p>"},{"location":"docs/developers/core-concepts/#styles-bringing-data-to-life","title":"Styles: Bringing Data to Life","text":"<p>While layers define what data is displayed and where, Styles (or Symbology) determine how that data is visualized. Styles control the visual appearance of layers, including colors, line thickness, transparency, and more. </p> <p>Similar to how CSS styles HTML in web development, styles in Netherlands3D customize the visual representation of your  spatial data. Whether you want to highlight certain areas, differentiate between types of infrastructure, or simply  make your map more visually appealing, styles give you the flexibility to achieve your desired look and feel.</p> <p>You can read more about styling in its dedicated chapter \"Layer Styles\". </p>"},{"location":"docs/developers/core-concepts/#conclusion","title":"Conclusion","text":"<p>Understanding these core concepts \u2014Projects, Layers, Rasterlayers, Vectorlayers, Features, Styles, and the distinction between Tiled and Fixed datasets\u2014 is crucial for effectively using Netherlands3D. These elements form the backbone of the platform, allowing you to create, visualize, and interact with spatial data in a way that meets your project needs. As you dive deeper into the application, these concepts will guide you in organizing your work and optimizing your use of the platform\u2019s powerful features.</p>"},{"location":"docs/developers/functionalities/","title":"Functionalities","text":"<p>At the core of Netherlands3D, various functionalities serve as building blocks. Each functionality represents a distinct element or feature of the platform, designed to perform specific tasks. These functionalities are modular, meaning they can be enabled or disabled individually based on user requirements or the needs of a particular project.</p> <p>This ability to toggle functionalities on and off ensures that you have control over the features you want to deploy in your project.</p>"},{"location":"docs/developers/functionalities/#how-does-it-work","title":"How does it work","text":"<p>In Unity's context for the Netherlands3D platform, each functionality is encapsulated in a ScriptableObject. Exploring further, you'll discover that each ScriptableObject is highly configurable, granting you the ability to tailor it to satisfy specific demands.</p>"},{"location":"docs/developers/functionalities/#key-components","title":"Key Components","text":""},{"location":"docs/developers/functionalities/#scriptableobjects","title":"ScriptableObjects","text":"<p>The ScriptableObjects for the functionalities can be located in the <code>Scriptables/Functionalities</code> folder. Each ScriptableObject represents a distinct functionality in the application, and can be configured to define its behavior and properties within the application.</p>"},{"location":"docs/developers/functionalities/#functionality-system","title":"Functionality System","text":"<p>The code powering the functionality system is hosted within the embedded package named <code>eu.netherlands3d.eu.twin-functionalities</code>. Digging into this package reveals the design and implementation of the system that manages and orchestrates the functionalities.</p>"},{"location":"docs/developers/functionalities/#the-functionality-script","title":"The Functionality Script","text":"<p>At the core, the Functionality script exists as a foundational unit for the ScriptableObject. Here is where you define key attributes such as its title, description, ID, and any additional configuration. This script performs the following roles:</p> <ol> <li> <p>Title and Description: The title and description fields of the ScriptableObject are primarily designed for your reference in the settings screen of the application.</p> </li> <li> <p>Functionality ID: The ID (or code) is used to refer to the functionality from the configuration file. This ID attribute is instrumental in organizing and managing configurations of functionalities within the system robustly.</p> </li> <li> <p>Enabled State: The enabled state of the functionality indicates whether it's active or inactive. The system can query this status to determine the functionality's availability and act accordingly in any part of the application.</p> </li> <li> <p>Additional Configuration: The ScriptableObject also includes an additional configuration section where you can define supplementary settings and properties that control its behavior within your application.</p> </li> </ol>"},{"location":"docs/developers/introduction/","title":"Introduction","text":"<p>Welcome to the technical documentation for Netherlands3D, an advanced Digital Twin platform designed to visualize and analyze geospatial data in a 3D environment. This documentation is intended for developers who want to understand how the platform works, explore its architecture, and contribute new modules or functionalities.</p> <p>Why English?</p> <p>While the rest of this website and the user-facing documentation is provided in Dutch, in accordance with  government guidelines, the technical documentation is written in English. </p> <p>This decision has been made to ensure a broad range of developers can contribute to Netherlands3D and to maintain  consistency with the platform's codebase, which uses English terms and concepts. By using English in the technical  documentation, we aim to make it easier for developers to map concepts between the documentation and the code  itself, facilitating a smoother development and contribution process.</p>"},{"location":"docs/developers/introduction/#overview","title":"Overview","text":"<p>Netherlands3D is built on a modular architecture, allowing for extensibility. Developers can add, modify, or replace individual modules without affecting the entire system. The platform integrates data from various sources, such as 3D Tiles, the national georegister, and sensor information, to create an interactive and dynamic 3D environment for spatial analysis and visualization.</p> <p>This documentation will provide you with a detailed understanding of how the system operates under the hood, including its component-based architecture, event-driven communication, and handling of secure data layers.</p>"},{"location":"docs/developers/introduction/#key-technologies","title":"Key Technologies","text":"<ul> <li>Unity3D: The platform is developed using Unity, leveraging its robust rendering capabilities to display   high-performance 3D models and large-scale datasets.</li> <li>Scriptable Objects: Used extensively to manage data, configuration, and communication between different modules   and functionalities.</li> <li>Event-Driven System: Internal communication within modules is handled via UnityEvents, while inter-module   interactions are driven by Scriptable Object Events, which allow asynchronous communication and keep the   system decoupled.</li> </ul> <p>This documentation will guide you through the internal workings of the platform, including detailed API references, examples of module creation, and best practices for integrating new functionality.</p>"},{"location":"docs/developers/layers-with-authentication/","title":"Managing Layers with Authentication","text":"<p>In Netherlands3D, certain data layers require user authentication to be accessed and displayed. This guide explains how the system manages authentication for these layers, handles different types of credentials, and ensures sensitive information remains protected while maintaining layer visibility settings.</p>"},{"location":"docs/developers/layers-with-authentication/#1-layer-authentication-process","title":"1. Layer Authentication Process","text":"<p>When a user adds a layer that requires authentication, they are prompted to provide credentials in one of the following forms:</p> <ul> <li>Username and Password</li> <li>Access Key</li> </ul> <p>Regardless of the credential type, the system records that the source associated with the layer (typically the layer's URL) requires authentication. This information is stored in a KeyVault.</p>"},{"location":"docs/developers/layers-with-authentication/#2-credential-storage-and-security","title":"2. Credential Storage and Security","text":"<p>To ensure that sensitive information is never compromised:</p> <ul> <li>Credentials are not stored in the project file. Instead, the KeyVault retains only the metadata necessary to    recognize that the layer is protected and requires credentials.</li> <li>The KeyVault is saved alongside the project, but it does not contain the actual credentials, only the    authentication type and associated layer source.</li> <li>This design prevents sensitive credentials from being shared when the project file is distributed to third parties,   ensuring privacy and security.</li> </ul>"},{"location":"docs/developers/layers-with-authentication/#3-handling-credentials-http-basic-authentication-vs-access-key","title":"3. Handling Credentials: HTTP Basic Authentication vs. Access Key","text":"<p>The system supports two main methods of authentication, depending on the type of credentials provided by the user:</p> <ul> <li> <p>HTTP Basic Authentication (Username and Password): If the user provides a username and password, the system    queries the protected endpoint using HTTP Basic Authentication. This involves sending the credentials in the request    header in accordance with the Basic Authentication protocol.</p> </li> <li> <p>Access Key: If an access key is provided, the system attempts to use the key within the query string of the    endpoint's URL. The application performs auto-detection to determine the appropriate query parameter name by testing    common parameters like:</p> </li> <li> <p><code>code</code></p> </li> <li><code>key</code></li> <li><code>token</code></li> </ul> <p>The system will make repeated requests to the endpoint using each query parameter name and observe the HTTP response.    If the server returns an HTTP status code 401 (Unauthorized) or 403 (Forbidden) for each attempt, the    application concludes that the provided credential is incorrect. If a valid credential is found, the system records    the correct query parameter name in the KeyVault for future use.</p>"},{"location":"docs/developers/layers-with-authentication/#4-handling-layers-without-credentials","title":"4. Handling Layers Without Credentials","text":"<p>If a layer requiring authentication is added (either manually by the user or through reloading a project), and no valid credentials are provided, the following behavior occurs:</p> <ul> <li>The layer enters a non-visible state, as it cannot be displayed without valid credentials.</li> <li>The system issues a warning prompting the user to enter (or re-enter) credentials for the layer.</li> </ul> <p>Note: The user must resolve this issue by supplying valid credentials before the layer can be displayed.</p>"},{"location":"docs/developers/layers-with-authentication/#5-maintaining-layer-visibility-settings","title":"5. Maintaining Layer Visibility Settings","text":"<p>One critical aspect of this system is that the visibility of the layer is preserved, even if it cannot be displayed due to authentication issues:</p> <ul> <li>If the layer was hidden (via the eye icon) when the project was saved, it will remain hidden after authentication    is provided.</li> <li>Similarly, if the layer was visible, it will become visible once valid credentials are entered and the authentication   issue is resolved.</li> </ul> <p>This approach ensures that the visibility state is consistent and independent of the authentication status.</p>"},{"location":"docs/developers/layers-with-authentication/#6-temporary-state-of-authentication","title":"6. Temporary State of Authentication","text":"<p>The system does not store the authentication status (whether credentials have been verified or not) in the project file. This is because authentication status is a temporary state that should not persist across sessions. Each time  a project is loaded, the authentication process must be reinitiated for protected layers, ensuring that credentials are entered securely and as needed.</p>"},{"location":"docs/developers/layers-with-authentication/#7-need-to-re-authenticate-reopening-the-application","title":"7. Need to re-authenticate reopening the application","text":"<p>A key implication of this design is that users will need to re-authenticate any protected layers every time they reopen the application or load a saved project file. Since credentials are never stored in the project file for security reasons, the system requires users to provide valid credentials again when the project is reloaded.</p> <p>This approach ensures that sensitive credentials are handled securely, but it also means that re-authentication is necessary whenever a protected layer is accessed in a new session. Users should be aware that any protected layers will initially be in a non-visible state until the required credentials are provided.</p>"},{"location":"docs/developers/layers-with-authentication/#8-warnings-and-user-flow","title":"8. Warnings and User Flow","text":"<p>The current user flow for managing layer authentication includes:</p> <ul> <li>A warning message indicating that the layer cannot be displayed due to missing or invalid credentials.</li> <li>A prompt that allows the user to supply new credentials for the layer.</li> <li>Once the credentials are provided and validated, the layer\u2019s display status is updated accordingly, without altering    its pre-existing visibility state.</li> </ul> <p>By following this process, Netherlands3D ensures that users can securely manage layers requiring authentication while maintaining proper visibility states and safeguarding sensitive data.</p>"},{"location":"docs/developers/layers/","title":"Layers","text":""},{"location":"docs/developers/layers/#layers_1","title":"Layers","text":"<p>Layers in Netherlands3D are objects that have an effect on the 3D environment. Layers are hierarchical, similar to GameObjects in Unity. Because of this. the Layer data structure makes use of Unity's GameObject/Transform hierarchy in order to minimize custom coding of the data structure, and to visualize the data structure in the Unity Editor hierarchy.</p>"},{"location":"docs/developers/layers/#functionality-of-layers","title":"Functionality of layers","text":"<p>All layers have the following basic functionality:</p> <ul> <li>Parenting: This works similar to the Unity Hierarchy.</li> <li>Reordering: This works similar to changing the sibling index within the same parent in the Unity hierarchy.</li> <li>Visibility: This works similar to setting a GameObject active/inactive in the Unity hierarchy.</li> <li>Properties: Each layer can have its own settings specific to the layer type, or even more specific to the content of   the layer. This is similar to how the inspector in Unity will display all components and serialized fields of a   GameObject.</li> </ul> <p>The layer data structure hierarchy is managed by the class <code>LayerData</code>. There should only be 1 LayerData object in the scene.</p>"},{"location":"docs/developers/layers/#layer-types","title":"Layer types","text":"<p>Layers are split in 2 categories:</p> <ol> <li>Regular layers that do not need their own GameObject hierarchy (basic layers)</li> <li>Layers that do require a GameObject hierarchy (referenced layers)</li> </ol>"},{"location":"docs/developers/layers/#basic-layers","title":"Basic layers","text":"<p>The first category of layers is the most simple. These layers are an extension of the <code>LayerNL3DBase</code> class.</p> <p>Folder layer:</p> <p>The most simple form of a Layer in this category is a <code>FolderLayer</code>. This layers has no functionality, except for providing the user with a way to organise other layers. It is similar to an empty GameObject.</p> <p>Polygon selection layer:</p> <p>A <code>PolygonSelectionLayer</code> is a layer that represents a polygon in the 3D environment. This layer can be created by providing a <code>List&lt;Vector3&gt;</code> of points (either by user input or from another source). This will create a layer in the hierarchy, with a visualisation that will listen to user input so that the layer can be selected by the user by clicking on the visualisation in the scene.</p>"},{"location":"docs/developers/layers/#referenced-layers","title":"Referenced layers","text":"<p>In case a layer has an internal hierarchy (such as a hierarchy of object parts, or a container with different tile objects) a layer can be integrated in the layer system as a referenced layer. A referenced layer exists outside of the Layer data structure, but has a connection to it through a <code>ReferencedProxyLayer</code> . The ReferencedProxyLayer will pass the required actions that affect the layer to its reference outside of the layer hierarchy, thereby making the referenced layer comply with the layer functionalities.</p> <p>In order to do this, the layer object outside of the hierarchy must have an extension of the abstract class <code>ReferencedLayer</code> attached to it. This class will automatically create the <code>ReferencedProxyLayer</code>, thereby creating the connection to the layer system.</p> <p>The following Layers are referenced layers:</p> <p>Hierarchical object layer:</p> <p>A <code>HierarchicalObjectLayer</code> is an object that can be placed in the 3D environment. By default, this object can be moved by the transform handles. Objects of this type either come from a library of developer defined objects, or by user uploads. The most simple Hierarchical object layer is a GameObject with a <code>MeshFilter</code>, <code>MeshRenderer</code>, <code>Collider</code>, and <code>HierarchicalObjectLayer</code> component attached. More complex Hierarchical object layers can have nested GameObjects with each their own internal logic.</p> <p>Cartesian tile layer:</p> <p>A <code>CartesianTileLayer</code> is a layer that makes use of the Netherlands3D custom tile file format. The objects and tiles in the layer are managed by the <code>TileHandler</code> and through the class <code>CartesianTileLayer</code> can interact with the layer system. For more information see the section on Cartesian Tiles.</p> <p>3D tile layer:</p> <p>A <code>Tile3DLayer2</code> is a layer that makes use of the 3D Tiles file format. These layers are managed by <code>Read3DTileset</code> and through the class <code>Tile3DLayer2</code> can interact with the layer system. For more information see the section on 3D Tiles.</p> <p>Object scatter layer:</p> <p>An <code>ObjectScatterLayer</code> is a special type of layer that will scatter the combined mesh of a <code>HierarchicalObjectLayer</code> in the area defined by a <code>PolygonLayer</code>. To do this, create a <code>PolygonLayer</code> and make a <code>HierarchicalObjectLayer</code> the child of the <code>PolygonLayer</code>. This will convert the <code>HierarchicalObjectLayer</code> to an <code>ObjectScatterLayer</code>. Unparenting the ObjectScatterLayer from a PolygonLayer will revert the layer back to a <code>HierarchicalObjectLayer</code>. The <code>ObjectScatterLayer</code> has scatter settings that determine how the scattering should occur.</p> <p>Warning</p> <p>The scattering is achieved through GPUInstancing, and therefore the mesh and material should support this. All  objects in the ObjectLibrary support scattering.</p>"},{"location":"docs/developers/layers/#layer-ui","title":"Layer UI","text":"<p>Each Layer can have an associated UI component defined by the class <code>LayerUI</code>. This component controls the UI elements associated with the layer. Interacting with the LayerUI will affect the corresponding <code>LayerNL3DBase</code>. The Layer UI hierarcy is managed by <code>LayerManager</code>. This class holds a references to the layer type icons that are requested by LayerUI.</p>"},{"location":"docs/developers/layers/#creating-your-own-layers-of-an-existing-type","title":"Creating your own layers of an existing type","text":"<p>In order to add one of your own layers as an option through the existing UI, the following steps should be followed:</p> <ol> <li>Create a prefab with the layer object. Make sure this object has a component of either <code>LayerNL3DBase</code>    or <code>ReferencedLayer</code> attached to it.</li> <li>Instantiate the prefab. If this is done in the existing LayerPanel UI, add a button or toggle in the    prefab <code>AddLayerPanel.prefab</code> in the appropriate panel sub section. Then have the script that controls the button or    toggle logic instantiate the prefab made in step 1.</li> </ol>"},{"location":"docs/developers/layers/#creating-your-own-layers-of-a-new-type","title":"Creating your own layers of a new type","text":"<p>Follow the following steps to create a new layer type:</p> <ol> <li>Choose if the new layer type can be a simple layer (direct extension of <code>LayerNL3DBase</code>) or it needs to be a more    complex referenced layer (extension of <code>ReferencedLayer</code>).</li> <li>Extend the chosen class and implement the required methods.</li> <li>Add your own logic to the new class</li> <li>Add a reference to the appropriate type and icon in LayerManager to ensure the new layer does not use the default <code>?</code>    icon.</li> </ol>"},{"location":"docs/developers/layers/#layers-and-functionalities","title":"Layers and Functionalities","text":"<p>Specific layers or specific types of layers can also be enabled/disabled with the functionalities system. Follow these steps to do this:</p> <ol> <li>Add a <code>FunctionalityListener</code> to the prefab of the layer. Add the functionality you want to link the layer to, and in    the <code>OnDisableFunctionality</code> event, add a function that will destroy the gameObject itself. This will clean up any    active layers when disabling the functionality.</li> <li>For any buttons that instantiate the prefab above, add a <code>FunctionalityListener</code> to the button that will    enable/disable the button's gameObject when the functionality is enabled/disabled respectively. This will ensure the    user cannot instantiate layers from functionalities that are disabled.</li> <li>(Optional) In case your layers should by default spawn when the functionality is enabled, add a PrefabSpawner script    to the scene where the functionality and the associated prefab are set in the inspector.</li> </ol>"},{"location":"docs/developers/platform-architecture/","title":"Platform Overview","text":"<p>Netherlands3D is a comprehensive platform designed to develop specialized 3D viewers that unify geospatial data from various sources. By integrating information from multiple parties, it enables organizations to visualize, analyze, and interact with spatial data in one centralized, interactive 3D environment. This approach transforms individual datasets into a cohesive, integral viewer, providing insights and context that would be hard to achieve by viewing data in isolation.</p>"},{"location":"docs/developers/platform-architecture/#a-platform-for-building-custom-viewers","title":"A Platform for Building Custom Viewers","text":"<p>Netherlands3D stands out as a flexible solution for creating tailored viewers suited to specific use cases. Its modular design, composed of individual Unity packages, allows developers to select and combine only the components they need. Each viewer built with Netherlands3D can be as simple or as complex as the project demands, with the ability to incorporate advanced functionalities such as live data updates, 3D rendering of large datasets, and interactive tools for exploration.</p>"},{"location":"docs/developers/platform-architecture/#centralized-data-integration","title":"Centralized Data Integration","text":"<p>The platform\u2019s core strength lies in its capacity to aggregate data from multiple external sources, including GIS databases, real-time sensor feeds, and specialized geospatial services. Netherlands3D acts as a data integrator, gathering disparate data streams and presenting them in a unified 3D viewer. This enables users to work within a single environment while accessing and analyzing comprehensive spatial data from various partners and services. By bringing diverse datasets together, Netherlands3D supports the development of digital twins and other projects requiring up-to-date and holistic data views.</p>"},{"location":"docs/developers/platform-architecture/#core-components","title":"Core Components","text":""},{"location":"docs/developers/platform-architecture/#building-blocks-unity-packages","title":"Building Blocks (Unity Packages)","text":"<p> Building blocks are the fundamental components of the Netherlands3D platform, each packaged as a Unity module with a specific function. These packages manage key tasks within the viewer -such as data handling, layer management,  and integrations with OGC standardized services- and can be added or removed independently to suit the viewer\u2019s  purpose.</p> <p>Each package is designed to be modular, allowing developers to choose only the components required for a particular project. This modularity supports the integration of data from various sources, such as GIS services and sensor networks, into a cohesive and interactive 3D viewer. By breaking down functionality into separate, reusable Unity packages, Netherlands3D simplifies maintenance and scalability, making it easy to adapt the viewer to evolving needs and datasets.</p>"},{"location":"docs/developers/platform-architecture/#functionalities","title":"Functionalities","text":"<p> Functionalities are specialized modules that encapsulate the capabilities of Netherlands3D\u2019s core building blocks. These functionalities handle unique tasks or provide interactions that enrich the viewer. Examples include urban development,  live sensor data overlays, and environmental simulation tools.</p> <p>The modular nature of functionalities allows them to be activated or configured on a per-project basis. By offering specific, configurable tools, functionalities make it easy for end-users to create viewers that cater to  specialized use cases. This flexible setup also enables developers to integrate real-time data or add interactive features, fostering engagement and insight through data visualization.</p>"},{"location":"docs/developers/platform-architecture/#the-twin-application","title":"The \"Twin\" Application","text":"<p>The Twin application provides a foundational viewer setup, pre-configured with essential building blocks and a selection of baseline functionalities. Designed to help users get started quickly, Twin offers an accessible path for building on the platform, providing a solid base configuration that can be expanded as needed.</p> <p>In addition to being a starting template, Twin also serves as an incubator for Netherlands3D\u2019s development team. New building blocks and functionalities are developed, tested, and refined within Twin before being packaged independently. This process allows the development team to evaluate how emerging functionalities interact within a full viewer context, addressing any issues early and ensuring seamless integration into the larger ecosystem.</p> <p>Once a new module or functionality reaches a level of stability and maturity, it is moved into its own Unity package, making it available for integration into other projects. This approach fosters innovation within a controlled environment, accelerating development while maintaining reliability.</p> <p>You can see the code at https://github.com/Netherlands3D/twin or see it in action at https://netherlands3d.eu/twin.</p>"},{"location":"docs/developers/projects/","title":"Projects","text":""},{"location":"docs/developers/projects/#overview","title":"Overview","text":"<p>Netherlands3D is a dynamic platform designed to allow users to interact with 3D geographical maps of locations across the Netherlands. This platform enables a wide array of spatial data interactions, from visualizing sensor telemetry to managing infrastructure data like cables, pipes, and zoning information. At the core of this functionality is the concept of Projects, which serve as containers for all user interactions and data on the platform.</p> <p>Projects in Netherlands3D encompass everything from the base map to the specific data layers, styles, and configurations that define the user's current view. Users can save these projects as snapshots of their work, allowing them to revisit, share, or continue working seamlessly at any time. This structure not only facilitates complex data analysis but also ensures that all spatial relationships are preserved and accurately represented.</p>"},{"location":"docs/developers/projects/#project-file-format","title":"Project File Format","text":"<p>Before diving into the technical specifics of how projects operate within the system, it's essential to understand the file format used to store project data. The project file acts as a blueprint, capturing all the layers, styles, configurations, and settings that define the project. </p> <p>Todo</p> <p>Describe the file format</p>"},{"location":"docs/developers/projects/#system-operation-overview","title":"System Operation Overview","text":"<p>Netherlands3D operates on a robust system that initializes with a default project file^1. This default project acts as the foundation upon which all subsequent user interactions and loaded projects are based.</p>"},{"location":"docs/developers/projects/#included-empty-project","title":"Included Empty Project","text":"<p>Upon startup, the system loads an empty project file^1 from the Assets^2 folder. This project serves as the  initial state of the application, providing a base map and predefined configurations that set the scene for the user's  interaction. The empty project is crucial for ensuring that the application is ready to use immediately upon launch,  without requiring any user input.</p>"},{"location":"docs/developers/projects/#customizable-default-project","title":"Customizable Default Project","text":"<p>A default project is fully configurable per deployment, allowing providers to tailor the initial view and settings to their specific needs. For instance, a province or municipality might want to highlight a particular region or set specific visualization parameters to align with their objectives. This flexibility ensures that the application can be used in various contexts, whether as an interactive tool for end-users or a static viewer for presenting a digital twin of a specific location.</p> <p>Todo</p> <p>Describe how this can be done</p>"},{"location":"docs/developers/projects/#project-loading-and-replacement","title":"Project Loading and Replacement","text":"<p>Once the application is running, users can load their own project files. When a new project file is loaded, it replaces the current project in its entirety, bringing in all new data layers, styles, and configurations. This process ensures a smooth transition between different datasets and views, allowing users to focus on their work without worrying about residual configurations from previous projects.</p> <p>Todo</p> <p>Describe how this works in more detail with a flowchart illustrating the overall process</p>"},{"location":"docs/developers/projects/#how-layers-work","title":"How Layers Work","text":"<p>Self-registering layers</p> <p>A variant of the described flow exists where by adding the visualisation of a layer it self-registers the layer's data onto the current project. This flow will be described in a separate chapter for clarity.</p> <p></p> <p>The diagram provided illustrates the lifecycle of layers within a project, detailing how they are acquired, constructed, and visualized. Here's a breakdown:</p>"},{"location":"docs/developers/projects/#acquiring-layers","title":"Acquiring Layers","text":"<p>Layers in Netherlands3D can be added to a project in several ways:</p> <ul> <li> <p>Importing via URL or File Upload: The system allows users to import data layers by providing a URL or uploading a file. The uploaded or referenced file is stored within the current project, and the system determines the layer type based on the file name or its contents.</p> </li> <li> <p>Dragging from Object Library: Users can also add layers by dragging objects from a pre-existing object library. The system determines the type of layer based on the selected object.</p> </li> <li>Opening a Project: When a project is opened, the system unpacks its contents to a predefined storage path. This process involves instantiating a ProjectData object and associated LayerData objects through deserialization.</li> </ul>"},{"location":"docs/developers/projects/#constructing-layers","title":"Constructing Layers","text":"<p>Once a layer is added, the system begins constructing it:</p> <ul> <li>The system finds a visualizer identifier for the specific layer type and then instantiates a LayerData object accordingly.</li> <li>The LayerData is then registered with the current project, linking it to the broader project context.</li> </ul> <p>Layers consist of two primary components:</p> <ul> <li>Layer Data: This is a lightweight, serializable data object containing information about the layer, such as its source data location (e.g., file paths, URIs).</li> <li>Layer Visualizer: This component handles the actual visualization work, such as spawning tiles and rendering geometry.</li> </ul>"},{"location":"docs/developers/projects/#visualizing-layers","title":"Visualizing Layers","text":"<p>The final stage is visualizing the layers within the application:</p> <ul> <li>The system grabs the appropriate visualizer prefab based on the identifier in LayerData.</li> <li>The visualizer loads the data from LayerData, and the application schedules visualization activities.</li> <li>If necessary, the source data is parsed or interpreted before visualization, ensuring that all data layers are accurately represented.</li> <li>Finally, the visualization scheduler renders the data, allowing users to interact with the newly loaded layers seamlessly.</li> </ul> <p>This structured approach to handling layers ensures that all data is properly managed, visualized, and integrated within the project framework, offering a powerful tool for spatial analysis and geographic data management in the Netherlands3D platform.</p>"},{"location":"docs/developers/quickstart/","title":"Quick Start Guide","text":"<p>Info</p> <p>This quickstart is aimed at developers who want to build on top of this platform, if all you want is to deploy it pre-configured on your platform, please read the guide on  deploying using Docker.</p>"},{"location":"docs/developers/quickstart/#prerequisites","title":"Prerequisites","text":"<p>Netherlands3D is developed in Unity, thus you'll need few prerequisites to start with the platform:</p> <ol> <li>Install Unity, the recommended version is Unity 6 (6000.0.58f2), including the WebGL build options. Please check     the Unity Download Page -or Unity Hub- and the official Installation Guide for assistance.</li> <li>Basic understanding of Unity and C# programming language.</li> </ol>"},{"location":"docs/developers/quickstart/#getting-started","title":"Getting Started","text":"<ol> <li> <p>We use Git LFS for storing large files. For Windows users, this is included in Git for Windows, while Mac users need to do the following:</p> <pre><code>brew install git-lfs\ngit lfs install\n</code></pre> </li> <li> <p>Clone the Netherlands3D/twin repository from GitHub:</p> <p>Warning</p> <p>The projects contains long paths, make sure you clone in a folder that is not too deeply nested - see  https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs=registry  for more information.</p> <pre><code>git clone https://github.com/Netherlands3D/twin.git\n</code></pre> </li> <li> <p>Once cloned, open the project in Unity. </p> </li> <li> <p>Now, go to the File menu, then select Build Settings. In the Build Settings window, choose WebGL and click Switch Platform.</p> </li> </ol>"},{"location":"docs/developers/quickstart/#recommendations","title":"Recommendations","text":""},{"location":"docs/developers/quickstart/#copy-the-main-scene","title":"Copy the Main scene","text":"<p>It's recommended to create a copy of the 'Main' scene before making any modifications. This ensures that you're not directly altering the original scene which, as the project is in continuous development, can lead to conflicts.</p> <p>To copy a scene in Unity:</p> <ul> <li>Select the 'Main' scene in the Project window.</li> <li>Press Ctrl+D or right-click and select 'Duplicate' from the context menu.</li> </ul>"},{"location":"docs/developers/quickstart/#next-steps","title":"Next Steps","text":"<p>With just these steps, you can immediately build and release your own customized Digital Twin; next up you can read up  on what and how you can configure the platform without making any code changes.</p>"},{"location":"docs/developers/styling/","title":"Layer Styles","text":"<p>Imagine you are dressing a city map for a public event. The <code>eu.netherlands3d.layer-styles</code> package is the wardrobe manager: it keeps outfits ready for every feature, checks who is walking past, and hands out the right clothes on the spot. </p> <p>This document walks through that wardrobe in plain language, highlighting the moving parts, the flow of data, and how other systems in Netherlands3D pick up the finished look.</p>"},{"location":"docs/developers/styling/#quick-cheat-sheet","title":"Quick cheat sheet","text":"<ul> <li>Purpose: Bridge the gap between saved styling data and the layer-specific renderers that bring it to life.</li> <li>Audience: Anyone wiring layer data to presentation logic\u2014whether you script styles on the fly, ship them with   layer metadata, or build custom authoring tools later.</li> <li>Mental shortcut: Treat the package as CSS for features. Rules match features, symbolizers hold properties, and the   resolver cascades them into a single outfit per feature.</li> </ul>"},{"location":"docs/developers/styling/#1-mental-model-at-a-glance","title":"1. Mental model at a glance","text":"Term Think of it as Where it lives LayerStyle A labeled clothing rack that groups related outfits <code>LayerStyle.cs</code> StylingRule A note on the rack saying \u201cIf the visitor matches this description, give them outfit X\u201d <code>StylingRule.cs</code> Symbolizer The actual outfit: colors, visibility flags, masks, custom notes <code>Symbolizer.cs</code> StyleResolver The wardrobe attendant who reads every note, checks the visitor, and layers outfits together <code>StyleResolver.cs</code> <p>Together they deliver CSS-inspired \u201ccascade\u201d behaviour: several rules can match one feature, and the last matching rule wins when the same property is set twice.</p> <p></p> <p>Pseudo-CSS to illustrate the anatomy of a Layer Style.</p> <p>Why not just use CSS?</p> <p>Good question! The expression language used for CSS selectors was never intended for complex queries such as the geospatial community knows, therefore we base our selectors on the Mapbox Style Spec's Expression language (https://docs.mapbox.com/style-spec/reference/expressions/).</p> <p>Also, we use JSON serializable data structures instead of a text-based syntax due to performance and layer  information is already stored in a JSON data structure. </p>"},{"location":"docs/developers/styling/#2-a-day-in-the-life-of-a-feature","title":"2. A day in the life of a feature","text":"<ol> <li>A layer is loaded and brings along one or more <code>LayerStyle</code> objects. Each style can include a    <code>default</code> rule so the layer has a baseline outfit without writing any selectors.</li> <li>A feature walks up with its attributes tucked inside <code>LayerFeature</code> and passes this to the StyleResolver.</li> <li>Every rule gets a chance. If a rule has no selector, it matches automatically; otherwise the expression is    evaluated against the feature. This is where you filter on height, zoning, owner, or any other attribute.</li> <li>Matching rules stack. When the selector passes, that rule\u2019s symbolizer is merged on top of the current    symbolizer. Later matches overwrite earlier ones, just like cascading CSS</li> <li>The layer visualizer receives one symbolizer containing the final set of properties. Each layer type (buildings,    terrain, parcels\u2026) interprets the symbolizer in its own rendering code, allowing wildly different visualisations    while keeping the contract the same.</li> </ol> <p>If you prefer a concrete -fictive- story, picture the \u201cCanal District Buildings\u201d layer with three rules:</p> Rule Selector (story form) Key style tweaks <code>default</code> Everything gets a calm sandstone paint Soft beige fill, subtle outline <code>Monuments</code> Buildings marked with <code>isMonument</code> Swap fill to deep green, add golden outline <code>NightLights</code> Opening hours past 22:00 Window color switches from blue to yellow <p>Written as pseudo-CSS</p> <pre><code>/* All features' fill color is \"sandstone\" */\n* {\n    fill: sandstone;\n}\n\n/* Except for windows in buildings - their fill color is blue */\nBuilding Window {\n    fill: blue;\n}\n\n/* \n  When buildings have the `is-monument` attribute set to the value `true`, \n  their fill color is deepgreen and they have a golden stroke\n*/\nBuilding[is-monument=true] {\n    fill: deepgreen;\n    stroke: golden;\n}\n\n/* \n  Windows of buildings whose opening hours is later than 22:00 should \n  have yellow windows\n*/\nBuilding[opening-hours &gt; 22:00] Window {\n    fill: yellow;\n}\n</code></pre> <p>When the feature for the Old Town Hall shows up, the resolver </p> <ol> <li>applies the default styling rule, </li> <li>spots the monument badge, and </li> <li>notes that its opening hours stretch late into the night. </li> </ol> <p>The final symbolizer mixes all three contributions, and the visualizer turns those knobs however it likes (perhaps by  feeding a shader, perhaps by toggling a prefab).</p>"},{"location":"docs/developers/styling/#3-what-does-a-symbolizer-look-like","title":"3. What does a symbolizer look like?","text":"<p>Symbolizers store everything as strings so they survive JSON round-tripping without special converters. Typed helpers translate those strings back into Unity data types when you need them, for example: </p> <ul> <li>colors become <code>Color</code> structs, </li> <li>visibility is exposed as <code>bool</code> </li> <li>masks are bitfields written as binary strings, and </li> <li>custom properties are JSON blobs prefixed with <code>--</code> to follow MDN-style naming (lowercase kebab-case).</li> </ul> <p>Here is an illustrative example of what a symbolizer might represent when serialized:</p> <pre><code>{\n  \"properties\": {\n    \"fill\": \"#FFAA33FF\",     // soft orange facade\n    \"stroke\": \"#333333FF\",   // charcoal outlines\n    \"visibility\": \"visible\",       // feature should render\n    \"mask-layer-mask\": \"00000100\", // use third mask layer bit\n    \"--shadow-style\": \"long\"      // custom flag read by a shader extension\n  }\n}\n</code></pre> <p>You set these values with the <code>SetFillColor</code>, <code>SetStrokeColor</code>, <code>SetVisibility</code>, <code>SetMaskLayerMask</code>, and <code>SetCustomProperty</code> helpers; clearing a property simply removes the key so downstream systems know to ignore it.</p>"},{"location":"docs/developers/styling/#4-understanding-the-cascade","title":"4. Understanding the Cascade","text":"<p>If several styling rules apply to the same feature, the cascade decides which property values survive. It works like layers of transparent paint: each new rule adds color where it speaks, but leaves untouched areas showing through from earlier coats.</p> <p>Core idea:</p> <ol> <li>Rules are evaluated in order.</li> <li>Matching rules merge their <code>Symbolizer</code> properties into the current result.</li> <li>If a property key already exists, the new value overwrites the old one.</li> <li>Missing keys are ignored, meaning \u201ckeep whatever is already there.\u201d</li> </ol> <p>You can picture it as a running dictionary merge:</p> <pre><code>foreach (var rule in rules)\n{\n    if (rule.Matches(feature))\n        finalSymbolizer.Merge(rule.Symbolizer);\n}\n</code></pre> <p>The merge method simply copies non-null entries:</p> <pre><code>public void Merge(Symbolizer other)\n{\n    foreach (var kvp in other.Properties)\n        Properties[kvp.Key] = kvp.Value;\n}\n</code></pre>"},{"location":"docs/developers/styling/#pseudo-css-cascade-example","title":"Pseudo-CSS Cascade Example","text":"<p>Let\u2019s restate the \u201cCanal District Buildings\u201d scenario in cascade form:</p> <pre><code>/* 1. Default look \u2014 everyone starts beige */\n* {\n  fill: sandstone;\n  --my-custom-property: flagged;\n}\n\n/* 2. Monuments override fill and stroke */\nBuilding[is-monument=true] {\n  fill: deepgreen;\n  stroke: golden;\n}\n</code></pre> <p>Now imagine a single feature:</p> <pre><code>{\n  \"geometry\": [123.11, 123.12, 321.21, 321.11],\n  \"properties\": {\n    \"is-monument\": true,\n    \"opening-hours\": \"23:00\"\n  }\n}\n</code></pre> <p>Cascade resolution:</p> Step Rule Applied Merged Properties Notes 1 <code>default</code> <code>fill: sandstone</code>, <code>--my-custom-property: flagged</code> Base layer with property 2 <code>Monuments</code> <code>fill: deepgreen</code>, <code>stroke: golden</code> Override fill and adds stroke <p>Final symbolizer result:</p> <pre><code>{\n  \"fill\": \"deepgreen\",\n  \"--my-custom-property\": \"flagged\",\n  \"stroke\": \"golden\"\n}\n</code></pre> <p>The renderer only ever sees this merged view. No selector logic or layer-specific detail leaks into rendering  code\u2014making it trivial to test and reuse.</p>"},{"location":"docs/developers/styling/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Later rules win on key collisions.</li> <li>Missing properties don\u2019t clear existing values.</li> <li>Order matters; specificity does not.</li> <li>The cascade operates purely through dictionary merges\u2014no parsing, no sorting, no text evaluation.</li> </ul>"},{"location":"docs/developers/styling/#5-crafting-styling-rules","title":"5. Crafting styling rules","text":"<p>A <code>StylingRule</code> combines a friendly name, one symbolizer, and an optional selector expression. Selectors use the Serializable GIS Expressions library, so you can compose Mapbox-style expressions (<code>==</code>, <code>in</code>, arithmetic, color utilities, etc.) to decide when a rule applies. Leave the selector <code>null</code> to create a base rule that always fires.</p> <p>Narrative example:</p> <ul> <li>Rule name: <code>Tall towers</code></li> <li>Selector: \"height &gt; 70\" expressed as <code>[\"&gt;\", [\"get\", \"height\"], 70]</code></li> <li>Symbolizer: Glowing outline and a semi-transparent fill.</li> </ul> <p>When a skyscraper feature arrives, the rule paints it accordingly; shorter buildings never see this style. During resolution, any 72-metre high-rise will slip into this style after the default styling, while a 45-metre apartment block simply keeps the baseline look. If you later add a <code>Residential highlight</code> rule that also matches the apartment block, whichever rule comes last in the style list decides the final stroke colour.</p>"},{"location":"docs/developers/styling/#6-where-styles-live-and-how-they-travel","title":"6. Where styles live and how they travel","text":"<p>The package is deliberately agnostic about storage. Anything Newtonsoft JSON can serialize/deserialise will work, so projects are free to tuck styles into scriptable objects, JSON files, or layer metadata. </p> <p>In Netherlands3D, layer styles travel alongside layer data objects\u2014each layer reads the symbolizer contract and applies  it using layer-specific visualisation code. This division keeps the package focused on the data contract between  persistence and presentation: authoring tools fill in the styles, while visualizers interpret them.</p> <p>Because styles are plain C# objects, you can experiment quickly in code. For example, during prototyping you might deserialize a JSON file into a <code>LayerStyle</code>, tweak the resulting <code>Symbolizer</code> objects in memory to respond to user input, and then write the updated structure back to disk\u2014no custom editor tooling required. Later, if you decide to build a designer UI, it only has to speak the same JSON contract.</p> <p>Because the data structures are plain C# classes with JSON constructors, there is no dedicated Unity editor UI today. Teams manipulate styles in code during runtime, keeping integration simple and leaving room for bespoke authoring pipelines later on.</p>"},{"location":"docs/developers/styling/#7-tips-gotchas-and-conventions","title":"7. Tips, gotchas, and conventions","text":"<ul> <li>Custom properties: Prefix them with <code>--</code> (automatically enforced) and use lowercase kebab-case for readability,   mirroring CSS custom property conventions.</li> <li>Merge order matters: Supply styles/rules to the resolver in the order you want later rules to win. The resolver   simply iterates the dictionary values, so keep the collection deterministic if you rely on precise overrides.</li> <li>Specificity does not matter: contrary to CSS, there is no resolving based on specificity. This may be added in a   later version but to preserve performance it is not implemented.</li> <li>Null means \u201cignore me\u201d: When a property is missing or a getter returns <code>null</code>, the renderer should leave the   previous value untouched. This is how the cascade differentiates between \u201cI don\u2019t care\u201d and \u201cexplicitly clear this   setting.\u201d</li> </ul>"},{"location":"docs/developers/styling/#8-recap","title":"8. Recap","text":"<ol> <li>Start with a <code>LayerStyle</code> rack and its default rule.</li> <li>Add descriptive <code>StylingRule</code> notes with selectors and symbolizers.</li> <li>Hand the rack to the <code>StyleResolver</code>.</li> <li>As each feature comes in, the resolver stacks matching symbolizers into one outfit.</li> <li>The layer renderer interprets the final symbolizer however it likes\u2014painting meshes, toggling game objects, feeding    shaders\u2014without ever needing to know where the data came from.</li> </ol> <p>With this shared mental picture, team members can approach the package as a friendly wardrobe rather than a mysterious black box, and layer teams can concentrate on rendering while data teams focus on expressive styling contracts.</p>"},{"location":"docs/developers/styling/#9-further-reading","title":"9. Further reading","text":"<ul> <li>Guide: Adding styling support to layers</li> <li>Guide: how to color parts of the terrain</li> </ul>"},{"location":"docs/developers/contributing/coding-standards/","title":"Coding Standards","text":"<p>This document outlines the coding standards for our Unity project. Adhering to consistent coding styles helps maintain the readability, maintainability, and collaboration ease of our codebase. These standards are in alignment with Unity\u2019s C# scripting practices and incorporate additional guidelines specific to our project.</p>"},{"location":"docs/developers/contributing/coding-standards/#1-naming-and-code-style","title":"1. Naming and Code Style","text":"<p>We follow the naming and code style tips provided by Unity  to ensure consistency and familiarity for all developers working in our Unity project. Key aspects of this style  include:</p> <ul> <li>PascalCasing for public properties, class names, and methods.</li> <li>camelCasing for private fields and local variables.</li> <li>Suffix boolean variables with Is, Has, or Can (e.g., isReady, hasAccess, canShoot).</li> <li>Avoid abbreviations unless they are well-known (e.g., maxHealth is preferable over mH).</li> </ul> <p>We also emphasize clarity and meaningful names over brevity, ensuring that variable and function names communicate their intent effectively.</p> <p>It is important to read the full guide at https://unity.com/how-to/naming-and-code-style-tips-c-scripting-unity  for a more complete picture of the coding guidelines followed in this project.</p>"},{"location":"docs/developers/contributing/coding-standards/#general-principles","title":"General Principles","text":"<ul> <li>Call a thing what it is. A bird should be called Bird.</li> <li>Choose names that can be pronounced and remembered.</li> <li>Be consistent. When you choose a name, stick to it.</li> <li>Use Pascal case, like this: ComplicatedVerySpecificObject. Do not use spaces, underscores, or hyphens.</li> <li>Do not use version numbers, or words to indicate their progress (WIP, final).</li> <li>Do not use abbreviations: DVamp@W should be DarkVampire@Walk.</li> <li>Keep the most specific descriptor on the left: PauseButton, not ButtonPaused. It is, for instance, easier to find    the pause button in the inspector if not all buttons start with the word Button.</li> <li>Some names form a sequence. Use numbers in these names, for example, PathNode0, PathNode1. Always start with 0, not 1.</li> <li>Do not use numbers for things that don\u2019t form a sequence. For example, Bird0, Bird1, Bird2 should be Flamingo, Eagle, Swallow.</li> </ul>"},{"location":"docs/developers/contributing/coding-standards/#structure","title":"Structure","text":"<p>The organisation of your project folder should follow a similar pattern.</p> <p>Warning</p> <p>We are in the process of moving project files to the structure below, until that process is complete you can expect to find asset folders directly in the root of the Assets folder.</p> <p>For new components it is recommended to follow this structure.</p> <p>We differentiate between architectural folders and asset folders. Architectural folders are meant to organize the  project in such a way that we have a modular -or composable- architecture with independent layers; asset folders can be  found inside each architectural folder and is similar to the regular folder structure that is normal with Unity.</p>"},{"location":"docs/developers/contributing/coding-standards/#architectural-folders","title":"Architectural folders","text":"<p>In the <code>Assets</code> folder there are four special folders:</p> <ol> <li>_Application - assets needed for the application itself, such as<ul> <li>Rendering pipelines, </li> <li>Inputsystem, </li> <li>Overall ui, </li> <li>Bootstrapping</li> <li>etc.</li> </ul> </li> <li>_BuildingBlocks - contains a series of folders for each building block that can be consumed by a functionality</li> <li>_Functionalities</li> <li>_UIKit</li> </ol>"},{"location":"docs/developers/contributing/coding-standards/#unity-folder-structure","title":"Unity Folder Structure","text":"<ul> <li>Animations</li> <li>Editor</li> <li>Fonts</li> <li>Materials</li> <li>Models</li> <li>Resources</li> <li>Prefabs</li> <li>Scenes</li> <li>ScriptableObjects</li> <li>Scripts</li> <li>Shaders</li> <li>Sprites</li> <li>Textures</li> </ul>"},{"location":"docs/developers/contributing/coding-standards/#2-bracing-style","title":"2. Bracing Style","text":"<p>We use the Allman style for braces, which is standard in most C# coding conventions. This style places opening  braces on a new line:</p> <pre><code>public class Player\n{\n    public void Jump()\n    {\n        // Code here\n    }\n}\n</code></pre> <p>This ensures clear structure and improves readability, especially in nested code blocks.</p>"},{"location":"docs/developers/contributing/coding-standards/#3-indentation","title":"3. Indentation","text":"<p>Indentation is essential for making code readable and understandable at a glance. We use 4 spaces for indentation rather than tabs. This ensures consistent formatting across different environments and prevents issues with mixed tab and space usage.</p> <p>Ensure the indentation is correct, especially when working with nested blocks of code.</p>"},{"location":"docs/developers/contributing/coding-standards/#nesting-levels","title":"Nesting Levels","text":"<p>To maintain clarity and readability, the number of nesting levels within any method or function should be limited to 2 at most. If a deeper level of nesting is required, consider refactoring the code into supporting methods or even supporting services. This helps in avoiding overly complex methods and improves the maintainability of the code.</p> <p>Example</p> <p>Instead of having deeply nested if-statements or loops:</p> <pre><code>public void ProcessPlayerInput(Player player)\n{\n    if (player != null)\n    {\n        if (player.HasControl())\n        {\n            if (player.IsAlive)\n            {\n                if (player.HasWeapon())\n                {\n                    if (player.CanShoot())\n                    {\n                        ShootWeapon(player);\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>This code is difficult to read due to the excessive nesting. To improve readability, we can refactor the logic into separate methods:</p> <pre><code>public void ProcessPlayerInput(Player player)\n{\n    if (!IsValidPlayer(player)) return;\n\n    if (CanPlayerShoot(player))\n    {\n        ShootWeapon(player);\n    }\n}\n\nprivate bool IsValidPlayer(Player player)\n{\n    return player != null &amp;&amp; player.HasControl() &amp;&amp; player.IsAlive;\n}\n\nprivate bool CanPlayerShoot(Player player)\n{\n    return player.HasWeapon() &amp;&amp; player.CanShoot();\n}\n</code></pre> <p>In this refactored example, the nesting is limited to 2 levels, and the logic has been broken down into meaningful, self-explanatory methods, making the code easier to understand and maintain. Each method handles a specific responsibility, which also helps with unit testing and debugging.</p>"},{"location":"docs/developers/contributing/coding-standards/#4-git-branching-strategy","title":"4. Git Branching Strategy","text":"<p>When creating branches for new features or bug fixes, follow the naming conventions outlined below. These conventions make it clear what type of change is being worked on and make branches easier to track and manage.</p> <ul> <li> <p>Branch Prefixes:</p> </li> <li> <p><code>feature/</code> for new features.</p> </li> <li> <p><code>fix/</code> for bug fixes or adjustments.</p> </li> <li> <p>Branch Name Format: Use kebab-case for branch names, which involves using hyphens (-) to separate words.</p> </li> </ul> <p>Examples:</p> <ul> <li>feature/implement-player-movement</li> <li>fix/camera-rotation-bug</li> </ul> <p>Following this strategy keeps the Git history clean and makes collaboration smoother, as everyone can quickly understand the purpose of each branch.</p>"},{"location":"docs/developers/contributing/documentation/","title":"Contributing to our Documentation","text":"<p>Thank you for your interest in contributing to the Netherlands3D documentation. This guide provides all the necessary information to help you get started with contributing to our documentation, which is composed of Markdown documents in our GitHub repository and is automatically built using MkDocs whenever a pull request is merged.</p>"},{"location":"docs/developers/contributing/documentation/#getting-started","title":"Getting Started","text":"<p>First, you'll need to set up your environment for making contributions:</p> <ol> <li>Fork the Repository: Go to https://github.com/Netherlands3D/netherlands3D.github.io/ and fork the repository to     your GitHub account.</li> <li>Clone the Fork: Clone your forked repository to your local machine to make changes.</li> </ol>"},{"location":"docs/developers/contributing/documentation/#previewing-changes","title":"Previewing Changes","text":"<p>You can preview the documentation locally in two different ways: either using Docker (recommended, no local installation required),or by installing MkDocs directly on your system.</p>"},{"location":"docs/developers/contributing/documentation/#option-1-using-docker-recommended","title":"Option 1: Using Docker (Recommended)","text":"<p>If you have Docker Desktop installed and running, you can follow these steps:</p> <ol> <li>Open Powershell (or your IDE's terminal)</li> <li>Make sure you are in your project folder (usually something like <code>C:\\Users\\[username]\\[path to where you cloned]\\Netherlands3D.github.io</code>)</li> <li>Run the included helper script:    <pre><code>.\\bin\\develop.bat\n</code></pre></li> </ol> <p>This will start a virtual webserver inside Docker and make the site available at:</p> <pre><code>http://localhost:8000\n</code></pre> <p>As long as the script is running, any edits you make to the documentation files will automatically be detected and the site will refresh. In most cases, your browser will even reload automatically.</p> <p>This method ensures a consistent environment for all contributors.</p>"},{"location":"docs/developers/contributing/documentation/#option-2-installing-mkdocs-locally","title":"Option 2: Installing MkDocs Locally","text":"<p>If you prefer to install MkDocs directly on your machine:</p> <ol> <li>Follow the installation guide on the MkDocs website and on     the mkdocs-material website.</li> <li>In your project directory, run:</li> </ol> <pre><code>mkdocs serve\n</code></pre> <p>This will start a local development server and make the site available at:</p> <pre><code>http://localhost:8000\n</code></pre> <p>Like with Docker, changes to the files will automatically update the preview.</p>"},{"location":"docs/developers/contributing/documentation/#making-contributions","title":"Making Contributions","text":""},{"location":"docs/developers/contributing/documentation/#language-and-voice","title":"Language and Voice","text":"<ul> <li>For user and organisation facing parts of the documentation, write in Dutch using the passive voice.</li> <li>For developer-facing documentation, write in English.</li> </ul>"},{"location":"docs/developers/contributing/documentation/#adding-or-editing-content","title":"Adding or Editing Content","text":"<ol> <li>Create a New Branch: Before making any changes, create a new branch in your forked repository.</li> <li>Add/Edit Markdown Files: Make your changes or add new content in the appropriate Markdown (.md) files. Be sure to    follow    the language and voice guidelines mentioned above.</li> <li>Update mkdocs.yml: If you are adding a new page, don't forget to update the mkdocs.yml configuration file to    include    your new page in the navigation.</li> </ol>"},{"location":"docs/developers/contributing/documentation/#submitting-your-contributions","title":"Submitting Your Contributions","text":"<p>Once you are satisfied with your changes:</p> <ol> <li>Commit Your Changes: Add your changes to your fork and commit them with a clear commit message.</li> <li>Push to Your Fork: Push your changes to your GitHub fork.</li> <li>Create a Pull Request: Go to the original Netherlands3D/docs repository and create a new pull request. Target the    main branch for your pull request and provide a clear description of your changes.</li> <li>Review Process: Your pull request will be reviewed by the Netherlands3D documentation team. Be open to feedback    and make any requested changes.</li> </ol>"},{"location":"docs/developers/contributing/documentation/#conclusion","title":"Conclusion","text":"<p>Contributing to the Netherlands3D documentation is a collaborative effort. We appreciate your willingness to contribute and look forward to improving our documentation with your help. If you have any questions or need assistance, please open an issue in the GitHub repository.</p>"},{"location":"docs/developers/contributing/writing-explanation-pages/","title":"Writing Explanation Pages","text":"<p>Explanation pages in Netherlands3D are designed to teach understanding \u2014 not procedures or API details. They connect architectural reasoning, design principles, and mental models in a way that developers, product managers, and auditors can follow without needing to read the source code.</p> <p>This guide describes how to write an Explanation page in our documentation using the Netherlands3D narrative structure.</p>"},{"location":"docs/developers/contributing/writing-explanation-pages/#1-purpose-of-explanation-pages","title":"1. Purpose of Explanation Pages","text":"<p>Explanation pages answer the question:</p> <p>\u201cHow does this concept work \u2014 and why is it designed this way?\u201d</p> <p>They are where readers develop a mental model. Unlike tutorials or guides, explanations are not step-by-step or goal-oriented. They focus on conceptual clarity, architectural insight, and rationale.</p> <p>You should write an Explanation page when you need to:</p> <ul> <li>Clarify how a core system (e.g., Layers, Styling, Catalogs, Tiles) fits into the overall architecture.</li> <li>Explain design trade-offs, conceptual patterns, or system lifecycles.</li> <li>Provide a shared vocabulary for technical and non-technical stakeholders.</li> <li>Help readers reason about code without diving into implementation details.</li> </ul>"},{"location":"docs/developers/contributing/writing-explanation-pages/#2-relationship-to-the-diataxis-framework","title":"2. Relationship to the Di\u00e1taxis Framework","text":"Di\u00e1taxis Category Focus Tone Typical Output Tutorials Learn by doing Friendly, step-by-step \u201cHello World\u201d examples How-to Guides Achieve a goal Practical, direct \u201cHow to add a new layer type\u201d Explanations Understand concepts Narrative, reflective \u201cHow layer styles cascade\u201d Reference Look up facts Precise, formal API lists, configuration schemas <p>This guide focuses exclusively on Explanations. For more information, see https://diataxis.fr/.</p>"},{"location":"docs/developers/contributing/writing-explanation-pages/#3-core-structure-for-an-explanation-page","title":"3. Core Structure for an Explanation Page","text":"<p>We use a consistent nine-part structure inspired by Layer Styles and Layers explainers. It balances narrative storytelling with technical clarity.</p> Section Purpose Typical Elements Title &amp; Hero Image Introduce the concept visually and narratively. Short metaphorical title, right-aligned image or diagram. Intro (analogy) Set the scene \u2014 connect an everyday metaphor to the technical topic. A \u201cImagine you are\u2026\u201d paragraph linking real-world intuition. Quick cheat sheet Establish audience and purpose. Three bullets: Purpose, Audience, Mental shortcut. 1. Mental model at a glance Present the conceptual building blocks. A table mapping terms \u2192 metaphors \u2192 file locations. 2. A day in the life of X Walk through runtime behavior or flow. 4\u20136 steps describing lifecycle or data flow. 3. What does X look like? Show how it looks in code or data form. JSON, YAML, or code snippet representing structure. 4. Understanding the lifecycle / cascade / flow Explain how the system behaves dynamically. Example logic, small code block, and annotated tables. 5. Crafting / Defining / Extending X Show how to create or modify it. Step-by-step or conceptual instructions. 6. Where X lives and how it travels Describe how it connects to the rest of the system. Explain persistence, serialization, or interaction with other modules. 7. Tips, gotchas, conventions Capture practical wisdom and conventions. Bullet list of dos, don\u2019ts, naming, and performance notes. 8. Recap Reinforce main takeaways. 4\u20136 concise summary points. 9. Further reading Link to related guides and references. Crosslinks to guides, references, or ADRs. <p>This structure helps maintain narrative coherence across all explanation pages.</p>"},{"location":"docs/developers/contributing/writing-explanation-pages/#4-writing-style-guidelines","title":"4. Writing Style Guidelines","text":""},{"location":"docs/developers/contributing/writing-explanation-pages/#tone","title":"Tone","text":"<ul> <li>Use plain language and conversational flow \u2014 write as if explaining to a new developer joining the project.</li> <li>Prefer analogies and metaphors that make abstract systems tangible (\u201cThink of the resolver as a wardrobe   attendant\u201d).</li> <li>Balance metaphor and precision: introduce with metaphor, then map it explicitly to real code.</li> </ul>"},{"location":"docs/developers/contributing/writing-explanation-pages/#structure-and-formatting","title":"Structure and Formatting","text":"<ul> <li>Use consistent heading numbers (1\u20139).</li> <li>Always include Quick cheat sheet early on for fast scanning.</li> <li>Include tables for mental models and code blocks for structure or examples.</li> <li>Separate sections with horizontal rules (<code>---</code>) for readability.</li> <li>Use MkDocs callouts (<code>!!! note</code>, <code>!!! warning</code>, <code>!!! example</code>, <code>!!! question</code>) to enrich explanations.</li> <li>Use JSONC syntax for serialized examples so comments can annotate meaning.</li> </ul>"},{"location":"docs/developers/contributing/writing-explanation-pages/#visuals","title":"Visuals","text":"<ul> <li>Include at least one right-aligned or inline image per explainer (e.g., diagram, conceptual illustration).</li> <li>Caption images using <code>/// caption</code> blocks when relevant.</li> <li>Keep visuals conceptual \u2014 not UI screenshots \u2014 unless they explain the architecture.</li> </ul>"},{"location":"docs/developers/contributing/writing-explanation-pages/#references","title":"References","text":"<ul> <li>Link directly to relevant <code>.cs</code> files in GitHub (preferably with permalink).</li> <li>Use relative links for internal docs (<code>./guides/...</code>, <code>../imgs/...</code>).</li> </ul>"},{"location":"docs/developers/contributing/writing-explanation-pages/#5-example-skeleton-template","title":"5. Example Skeleton Template","text":"<p>Use this template as a starting point for any new Explanation page:</p> <pre><code># [Concept Name]\n\n![concept-diagram.png](../imgs/concept-diagram.png){align=right width=300}\n\nImagine you are [metaphor here].  \nThis document explains how [concept] works within Netherlands3D, showing its moving parts, data flow, and relationships\nwith other systems.\n\n## Quick cheat sheet\n\n- **Purpose:** [Short description]\n- **Audience:** [Intended readers]\n- **Mental shortcut:** [Metaphor summary]\n\n## 1. Mental model at a glance\n\n| Term | Think of it as | Where it lives |\n|------|----------------|----------------|\n| [Key term] | [Analogy] | `[File.cs]` |\n| ... | ... | ... |\n\n## 2. A day in the life of a [concept]\n\n1. [Step 1]\n2. [Step 2]\n3. [Step 3]\n4. ...\n\n## 3. What does it look like?\n\n```jsonc\n{ ...example structure... }\n```\n\n## 4. Understanding the [flow/lifecycle/cascade]\n\nExplain how this system behaves dynamically, using annotated examples or diagrams.\n\n## 5. Crafting or extending a [concept]\n\nGuidelines for defining or extending the concept, with examples.\n\n## 6. Where it lives and how it travels\n\nExplain how it\u2019s serialized, stored, or passed between systems.\n\n## 7. Tips, gotchas, and conventions\n\n* [Convention 1]\n* [Convention 2]\n* [Performance tip]\n\n## 8. Recap\n\n1. [Key insight]\n2. [Key insight]\n3. [Key insight]\n\n## 9. Further reading\n\n* [Guide link]\n* [Reference link]\n</code></pre>"},{"location":"docs/developers/contributing/writing-explanation-pages/#6-author-checklist","title":"6. Author Checklist","text":"<p>Before submitting a new Explanation page:</p> <ul> <li>[ ] The document follows the nine-section structure.</li> <li>[ ] It uses a clear, relatable metaphor in the introduction.</li> <li>[ ] It includes a Quick cheat sheet table.</li> <li>[ ] It references real code files where appropriate.</li> <li>[ ] JSON or C# snippets match current code.</li> <li>[ ] It links to at least one related Guide and Reference page.</li> <li>[ ] It has been proofread for consistent tone and technical accuracy.</li> </ul>"},{"location":"docs/developers/contributing/writing-explanation-pages/#7-example-pages-to-learn-from","title":"7. Example Pages to Learn From","text":"<ul> <li>Layers</li> <li>Layer Styles</li> </ul>"},{"location":"docs/developers/contributing/writing-explanation-pages/#8-summary","title":"8. Summary","text":"<p>Explanation pages form the conceptual backbone of the Netherlands3D documentation. They connect the why behind systems to the how found in guides and references, giving readers the mental model to navigate complex architectures confidently.</p> <p>By following this structure, every new explainer remains readable, cohesive, and visually aligned with the rest of the docs \u2014 helping both new contributors and long-term maintainers understand the system, not just use it.</p>"},{"location":"docs/developers/contributing/writing-explanation-pages/#9-further-reading","title":"9. Further reading","text":"<ul> <li>Contributing to the documentation</li> <li>Writing guides</li> </ul>"},{"location":"docs/developers/contributing/writing-guides/","title":"Writing How-to Guides","text":"<p>How-to Guides in Netherlands3D describe practical procedures that achieve a specific goal. They are for readers who already understand the concepts (from Explanation pages) and now want to do something concrete \u2014 like \u201ccolor terrain parts,\u201d \u201cadd a new layer type,\u201d or \u201cconnect a catalog service.\u201d</p> <p>This guide explains how to structure, write, and review a Netherlands3D How-to Guide following the  Di\u00e1taxis framework.</p>"},{"location":"docs/developers/contributing/writing-guides/#1-purpose-of-how-to-guides","title":"1. Purpose of How-to Guides","text":"<p>How-to Guides answer the question:</p> <p>\u201cHow do I accomplish this task?\u201d</p> <p>They focus on getting results, not on explaining architecture or theory. Readers expect to follow steps, run examples, and see immediate outcomes.</p> <p>You should write a How-to Guide when:</p> <ul> <li>You\u2019re documenting a repeatable process or workflow.</li> <li>The reader already understands the why, and only needs the how.</li> <li>The procedure can be completed in a few clear steps, often with code.</li> </ul>"},{"location":"docs/developers/contributing/writing-guides/#2-relationship-to-the-diataxis-framework","title":"2. Relationship to the Di\u00e1taxis Framework","text":"Di\u00e1taxis Category Focus Tone Typical Output Tutorials Learn by doing Guided, educational \u201cBuild your first layer project\u201d How-to Guides Achieve a goal Practical, concise \u201cHow to color parts of the terrain\u201d Explanations Understand concepts Reflective, narrative \u201cHow layer styles cascade\u201d Reference Look up facts Formal, precise API and configuration details <p>This page focuses exclusively on How-to Guides. For more information, see  https://diataxis.fr/.</p>"},{"location":"docs/developers/contributing/writing-guides/#3-standard-structure","title":"3. Standard Structure","text":"<p>Each guide follows a predictable structure for clarity and scanning. Readers should be able to jump to the section they need and copy-paste code safely.</p> Section Purpose Typical Elements Title Clearly describe the goal. \u201cHow to color parts of the terrain\u201d Introduction Explain what the reader will achieve and why it\u2019s useful. 2-3 lines with context. Prerequisites List what\u2019s needed before starting. Layers, components, SDK versions, or project setup. Step-by-Step Instructions Core of the guide \u2014 numbered steps that lead to success. 3-6 sequential sections, each with code or screenshots. Verification / Testing Show how to confirm the result works. Checklist or run instructions. What\u2019s Next? Suggest extensions or related improvements. Optional, encourages exploration. Performance Tips / Common Pitfalls Optimization hints or warnings. Optional, but very useful. Further Reading Link to explanations, guides, or references. Always end with cross-references."},{"location":"docs/developers/contributing/writing-guides/#4-writing-style-guidelines","title":"4. Writing Style Guidelines","text":""},{"location":"docs/developers/contributing/writing-guides/#tone","title":"Tone","text":"<ul> <li>Be direct and task-oriented: readers are here to do something.</li> <li>Use imperative verbs (\u201cClick,\u201d \u201cCreate,\u201d \u201cCall,\u201d \u201cAdd\u201d).</li> <li>Avoid theoretical detours \u2014 link to explanation pages instead.</li> <li>Write one goal per guide. If a task has branches, make separate guides.</li> </ul>"},{"location":"docs/developers/contributing/writing-guides/#code-and-formatting","title":"Code and Formatting","text":"<ul> <li>Use C# for Unity examples unless another language is unavoidable.</li> <li>Use fenced code blocks (<code>```csharp</code>, <code>```jsonc</code>, etc.) with inline comments for clarity.</li> <li>Provide copy-pasteable snippets that compile or run as written.</li> <li>Separate sections with horizontal rules (<code>---</code>) for readability.</li> <li>Use MkDocs callouts (<code>!!! tip</code>, <code>!!! warning</code>, <code>!!! example</code>) to emphasize key details.</li> </ul>"},{"location":"docs/developers/contributing/writing-guides/#style-of-instruction","title":"Style of Instruction","text":"<p>Each step should:</p> <ol> <li>State the goal (\u201cCreate a color mapping for terrain features\u201d).</li> <li>Explain the reasoning briefly (\u201cThis uses the feature\u2019s material index\u201d).</li> <li>Show the code or action required.</li> <li>Conclude with what the reader should observe (\u201cFootpaths now appear beige.\u201d).</li> </ol>"},{"location":"docs/developers/contributing/writing-guides/#visual-and-structural-conventions","title":"Visual and Structural Conventions","text":"<ul> <li>Start every code step with a heading like Step 1: ...</li> <li>Use consistent section titles (<code>## Step 1</code>, <code>## Step 2</code>, etc.).</li> <li>Include at least one example output (screenshot, visual, or JSON result).</li> <li>Keep lines under ~100 characters where possible for readability in narrow docs layouts.</li> </ul>"},{"location":"docs/developers/contributing/writing-guides/#5-template-for-a-how-to-guide","title":"5. Template for a How-to Guide","text":"<pre><code># How to [goal in plain language]\n\n## Introduction\n\nBriefly describe what the guide helps achieve, and why.  \nInclude one sentence explaining the broader context (e.g. within Netherlands3D or Unity).\n\n---\n\n## Prerequisites\n\n- [Required layer or object]\n- [Specific environment or component]\n- [Any setup steps completed]\n\n---\n\n## Step 1: [Title of first step]\n\nExplain what this step accomplishes.\n\n```csharp\n// Example code snippet\n```\n\n!!! tip\nHelpful reminder or optional shortcut.\n\n---\n\n## Step 2: [Next step title]\n\n...\n\n---\n\n## Step 3: [Verification or further configuration]\n\nExplain how to confirm it works.\n\n---\n\n## What\u2019s next?\n\nOptional: suggest follow-up tasks or advanced variations.\n\n---\n\n## Performance tips\n\nOptional: share optimizations, caveats, or best practices.\n\n---\n\n## Further Reading\n\n* [Explanation: related concept](../explainers/related-concept.md)\n* [Reference: relevant API](../reference/relevant-api.md)\n</code></pre>"},{"location":"docs/developers/contributing/writing-guides/#6-checklist-for-authors","title":"6. Checklist for Authors","text":"<p>Before submitting your guide:</p> <ul> <li>[ ] The title clearly states a single goal.</li> <li>[ ] Steps are numbered and sequential.</li> <li>[ ] Each step shows an action, explanation, and expected result.</li> <li>[ ] Code compiles and matches current API signatures.</li> <li>[ ] Uses proper Markdown formatting and callouts.</li> <li>[ ] Ends with at least one link to an Explanation and Reference page.</li> </ul>"},{"location":"docs/developers/contributing/writing-guides/#7-examples-to-learn-from","title":"7. Examples to Learn From","text":"<ul> <li>How to color parts of the terrain</li> <li>How to add styling support to layers</li> <li>How to enable functionalities for specific layers</li> </ul>"},{"location":"docs/developers/contributing/writing-guides/#8-summary","title":"8. Summary","text":"<p>How-to Guides are hands-on recipes: short, focused, and reliable. They show how to use the system, not how it\u2019s built. By following this structure, every new guide in Netherlands3D remains clear, repeatable, and consistent with the rest of the Di\u00e1taxis documentation set.</p>"},{"location":"docs/developers/contributing/writing-guides/#9-further-reading","title":"9. Further reading","text":"<ul> <li>Contributing to the documentation</li> </ul>"},{"location":"docs/developers/decisions/","title":"Architectural Decisions","text":"<p>In the Netherlands3D project, we recognize the importance of documenting key architectural decisions to ensure that the rationale behind our choices is clear, traceable, and accessible to all contributors and stakeholders. This section serves as a living document where we track these decisions, both accepted and rejected, to provide a transparent record of our technical direction.</p>"},{"location":"docs/developers/decisions/#why-track-architectural-decisions","title":"Why Track Architectural Decisions?","text":"<p>Architectural decisions often shape the foundation of a project and influence how future features are built. By documenting these decisions:</p> <ul> <li>We ensure clarity and alignment: Everyone working on the project understands why certain paths were chosen over   others.</li> <li>We maintain consistency: Having a record of decisions helps to maintain a coherent and stable architectural vision   as the project evolves.</li> <li>We enable future-proofing: Teams and future developers can reference past decisions to avoid re-evaluating or   re-implementing resolved issues.</li> <li>We encourage informed collaboration: It creates an open dialogue for discussing technical options and ensures   everyone has access to the decision-making process.</li> </ul>"},{"location":"docs/developers/decisions/#what-to-expect","title":"What to Expect","text":"<p>In this section, you will find a record of:</p> <ul> <li>Accepted proposals: Decisions that have been approved and are guiding the current development.</li> <li>Rejected proposals: Ideas that were considered but ultimately not adopted, along with the reasons why.</li> <li>Ongoing discussions: Some entries may reflect decisions that are still under consideration, providing insight into   our ongoing thought process.</li> </ul> <p>Each architectural decision is written in a lightweight, actionable format that includes a summary of the problem, the considered options, the decision taken, and the rationale behind it. We strive to keep these entries concise while capturing the essential technical and business context.</p>"},{"location":"docs/developers/decisions/#language-considerations","title":"Language Considerations","text":"<p>Since the core Netherlands3D team operates primarily in Dutch, many architectural proposals and discussions will initially be documented in Dutch. This allows us to facilitate faster and more in-depth discussions within the team. However, we strive to provide English translations for most of these decisions to ensure that non-Dutch speakers can follow and contribute to the project. Whenever possible, both Dutch and English versions of each decision will be available.</p>"},{"location":"docs/developers/decisions/20241009-styling-of-layers/","title":"2024-10-09 - Laagstijlen / Symbologie","text":"Datum 09-10-2024 Status Geaccepteerd"},{"location":"docs/developers/decisions/20241009-styling-of-layers/#context","title":"Context","text":"<p>Als uitkomst van dit voorstel willen we dat Netherlands3D gebruik maakt van visualisaties waarbij lagen worden gestileerd met behulp van symbologie, gebaseerd op de OGC Cartographic Symbology - Part 1: Core Model &amp; Encodings  (https://docs.ogc.org/DRAFTS/18-067r4.html). De implementatie is een systeem vergelijkbaar met CSS, waarbij een  Symbolizer styling-eigenschappen bevat, en Selectors (beschreven als Expressions) bepalen wanneer en hoe  deze eigenschappen worden toegepast.</p> <p>Hoewel de term \"symbologie\" gebruikelijk is in GIS, noemen we dit systeem \"styling\" om het toegankelijker te maken voor een breder publiek en de parallel met CSS te benadrukken.</p> <p>Scheiding tussen Styling en Visualisatie</p> <p>Het styling-systeem zelf doet niets met de daadwerkelijke visualisatie. Het systeem beschrijft alleen hoe de styling moet zijn, maar het is aan de visualisatiecode die hoort bij een laag om te bepalen of en hoe de styling-eigenschappen worden toegepast. Dit betekent dat het mogelijk is dat bepaalde styling-eigenschappen niet worden toegepast als de visualisatiecode daarvoor geen ondersteuning biedt.</p>"},{"location":"docs/developers/decisions/20241009-styling-of-layers/#besluit","title":"Besluit","text":"<p>We implementeren een flexibel styling-systeem waarin Symbolizers styling-eigenschappen bevatten, en Selectors en Expressions bepalen wanneer deze eigenschappen van toepassing zijn. Dit systeem wordt toegepast op lagen, en de mogelijke waarden binnen een Symbolizer worden bepaald door de aanwezige Symbolizer-extensies.</p> <p>Externe partijen kunnen hun eigen extensies en styling-eigenschap prefixes toevoegen, volgens het patroon uit hoofdstuk 8.1.7 van de OGC-specificatie: <code>vendor.&lt;vendor naam&gt;.&lt;eigenschap naam&gt;</code>. Voor Netherlands3D betekent dit dat we de prefix <code>vendor.netherlands3d.&lt;eigenschap naam&gt;</code> zullen hanteren.</p>"},{"location":"docs/developers/decisions/20241009-styling-of-layers/#rationale","title":"Rationale","text":"<p>Het gebruik van een systeem, vergelijkbaar met CSS, biedt de flexibiliteit en uitbreidbaarheid die nodig is voor het werken met dynamische geodata. Door selectors en expressies te gebruiken, kunnen we styling-eigenschappen toepassen op basis van attribuutwaarden of andere condities. Symbolizer-extensies zorgen ervoor dat nieuwe styling-eigenschappen kunnen worden toegevoegd zonder de kernstructuur te verstoren. Door gebruik te maken van extension methods met default-waarden, waarborgen we een voorspelbare werking van het systeem, zelfs wanneer geen expliciete waarde aanwezig is.</p>"},{"location":"docs/developers/decisions/20241009-styling-of-layers/#codeorganisatie","title":"Codeorganisatie","text":"<p>De implementatie van het systeem wordt initieel ondergebracht als Building Block in de Twin applicatie en zodra de  structuur uitontwikkeld is, verhuist naar een aparte OpenUPM-package. De code voor de verschillende  Symbolizer-extensies wordt georganiseerd in mappen, waarbij iedere extensie een Requirement Class uit de OGC-specificatie volgt. Dit maakt het beheer van verschillende extensies overzichtelijk en zorgt voor een heldere scheiding tussen kernfunctionaliteit en uitbreidingen.</p> <p>Wij passen zelf de styling-eigenschap prefix <code>vendor.netherlands3d.&lt;eigenschap naam&gt;</code> toe voor onze eigen uitbreidingen. Derde partijen kunnen hun eigen extensies via hun eigen packages toevoegen en daarbij hun eigen  styling-eigenschap prefixes introduceren volgens hetzelfde patroon uit hoofdstuk 8.1.7 van de OGC-specificatie.</p>"},{"location":"docs/developers/decisions/20241009-styling-of-layers/#implementatiestrategie","title":"Implementatiestrategie","text":"<p>We voeren de implementatie stapsgewijs uit. Dit houdt in dat we niet alle eigenschappen van de Symbolizer in \u00e9\u00e9n keer toevoegen, maar in kleine iteraties werken. Elke iteratie implementeert \u00e9\u00e9n of meer specifieke eigenschappen van de Symbolizer, afhankelijk van de eisen van een user story. Bijvoorbeeld: wanneer een user story vraagt om een laag een enkele vulkleur te geven, wordt alleen de fill-eigenschap van de Symbolizer-extensie voor vectorfeatures ge\u00efmplementeerd.</p> <p>Hoewel hoofdstuk 17 van de OGC-specificatie extra opties beschrijft zoals het gebruik van het \"alter\" veld, variabelen en het includen van stylesheets, zullen we deze opties expliciet niet implementeren. Ons doel is niet om de volledige specificatie te implementeren, maar om de organisatiestructuur van symbolizers, expressies en styling te adopteren. Dit voorkomt dat we het wiel opnieuw uitvinden, maar zorgt ervoor dat we ons beperken tot een basisstructuur die ons flexibiliteit biedt zonder de complexiteit van volledige implementatie.</p>"},{"location":"docs/developers/decisions/20241009-styling-of-layers/#implementatie","title":"Implementatie","text":"<pre><code>classDiagram\n    namespace Netherlands3D {\n        class Layers\n    }\n    namespace Layers {\n        class LayerData {\n            +LayerStyle styles\n        }\n        class Styles\n    }\n\n    namespace Styles {\n    class LayerStyle {\n        +StylingRule stylingRules\n        +Metadata metadata\n    }\n\n    class Metadata {\n        + string name\n    }\n\n    class StylingRule {\n        +string name\n        +Symbolizer symbolizer\n        +Expression selector\n    }\n\n    class Expression {\n    }\n\n    class Symbolizer {\n        - Dictionary properties\n        ~ void GetProperty(string name)\n        ~ object SetProperty(string name, object value)\n    }\n\n    class CoreSymbolizerExtension {\n        +GetVisibility() bool\n        +SetVisibility(bool visible)\n        +GetOpacity() float\n        +SetOpacity(float opacity)\n    }\n\n    class VectorSymbolizerExtension {\n        +GetFill() Color\n        +SetFill(Color fillColor)\n    }\n    }\n\n    LayerData --&gt; \"0..*\" LayerStyle\n    LayerStyle --&gt; \"0..*\" StylingRule\n    LayerStyle --&gt; \"0..1\" Metadata\n    StylingRule --&gt; \"0..1\" Symbolizer\n    StylingRule --&gt; \"0..1\" Expression\n    CoreSymbolizerExtension .. Symbolizer : extension of\n    VectorSymbolizerExtension .. Symbolizer : extension of\n</code></pre> <p>Let op</p> <p>We wijken in de naamgeving af van de beschrijving in de OGC standaard bij de LayerStyle klasse, in de OGC standaard heeft deze enkel <code>Style</code>, maar om consistent te zijn in de applicatie en ter verduidelijking voegen wij het voorzetsel <code>Layer</code> toe om te benadrukken dat dit een style is behorende bij layers; vergelijkbaar met <code>LayerPropertyData</code></p>"},{"location":"docs/developers/decisions/20241009-styling-of-layers/#opslag-van-stijlen-in-het-projectbestand","title":"Opslag van Stijlen in het Projectbestand","text":"<p>Elke layer in het projectbestand krijgt een nieuw veld genaamd \"styles\" waarin de stylinginformatie wordt opgeslagen. Dit veld verwijst naar een JSON-structuur die hetzelfde formaat is zoals gedefinieerd in hoofdstuk 17 van de OGC Cartographic Symbology - Part 1: Core Model &amp; Encodings OGC-standaard. Hierdoor kunnen we stijlen opnieuw laden en heen en weer converteren tussen het interne representatiemodel en het JSON-bestand. Dit zorgt ervoor dat stijlen behouden blijven wanneer ze eenmaal gedefinieerd zijn.</p> <p>Technische Vereisten voor Serialization</p> <p>Omdat het hele projectbestand wordt geserialized met Newtonsoft's JSON.net, moet de klassestructuur van de symbolizers ook in dit format worden geserialized. Dit waarborgt strict typing en maakt het consistent met de rest  van het project.</p> <p>Voor de Symbolizer zal een aparte JsonConverter geschreven moeten worden die ervoor zorgt dat de waarden in de <code>properties</code> dictionary als losse velden direct in de JSON voor het symbolizer object verschijnen en niet dat een extra veld <code>properties</code> in de JSON terecht komt.</p>"},{"location":"docs/developers/decisions/20241009-styling-of-layers/#expressions-en-selectors","title":"Expressions, en Selectors","text":"<p>Bij het implementeren van expressions en selectors volgen we de structuur zoals beschreven in hoofdstuk 8.1.5 van de OGC Cartographic Symbology - Part 1: Core Model &amp; Encodings. Net als bij de styling-eigenschappen, zullen we de expressie-taal niet in \u00e9\u00e9n keer volledig implementeren, maar stap voor stap, afhankelijk van de vereisten van user stories.</p> <p>Voorbeeld</p> <p>Een voorbeeld hiervan is een user story waarin we een groep features kleuren op basis van een attribuutwaarde. Voor deze implementatie hebben we alleen de volgende onderdelen nodig:</p> <ul> <li>Een vergelijkingsoperator (alleen gelijkheid),</li> <li>Een attribuut-identiteits-expressie (om het attribuut aan te duiden),</li> <li>Een TextLiteral-expressie (om de letterlijke waarde te beschrijven).</li> </ul> <p>Dit iteratieve proces maakt het mogelijk om gericht de functionaliteiten toe te voegen die direct noodzakelijk zijn voor de behoeften van de gebruikers.</p>"},{"location":"docs/developers/decisions/20241009-styling-of-layers/#risicos","title":"Risico's","text":"<p>De OGC Cartographic Symbology-standaard bevindt zich in een draft-stadium, wat betekent dat de specificaties nog kunnen veranderen. We accepteren dat onze implementatie niet volledig overeenkomt met de definitieve specificatie, en houden hier rekening mee in toekomstige aanpassingen.</p>"},{"location":"docs/developers/decisions/20241009-styling-of-layers/#appendix-a-woordenlijst","title":"Appendix A: Woordenlijst","text":"<ul> <li>OGC Cartographic Symbology-standaard: De standaard waarop het styling-systeem is gebaseerd.</li> <li>Layer: Een verzameling van geografische objecten die in een bepaalde stijl worden weergegeven.</li> <li>Styling: Het toekennen van visuele eigenschappen aan geografische objecten.</li> <li>Style: Een verzameling van stylingregels die wordt toegepast op een layer.</li> <li>Styling-eigenschap: Een specifieke visuele eigenschap, zoals kleur of lijnstijl, die wordt toegepast op een   object.</li> <li>Symbolizer: Een object dat styling-eigenschappen bevat voor lagen.</li> <li>Symbologie: Een GIS-term voor het beschrijven van hoe geografische objecten visueel worden weergegeven.</li> <li>Selector: Een conditie die bepaalt wanneer een symbolizer moet worden toegepast.</li> <li>Expression: Een voorwaarde of waarde die bepaalt hoe en wanneer een bepaalde styling-eigenschap wordt toegepast.</li> <li>Symbolizer-extensie: Uitbreidingen die nieuwe styling-eigenschappen toevoegen aan de Symbolizer.</li> <li>Styling-eigenschap prefix: Een voorvoegsel toegevoegd aan eigen styling-eigenschappen om conflicten met   OGC-gedefinieerde eigenschappen te voorkomen, zoals beschreven in hoofdstuk 8.1.7 van de OGC-specificatie.</li> </ul>"},{"location":"docs/developers/decisions/20241009-styling-of-layers/#appendix-b-voorbeeld-flow-voor-het-wijzigen-van-kleur","title":"Appendix B: Voorbeeld flow voor het wijzigen van kleur","text":"<p>Wanneer een gebruiker de kleur van een laag aanpast in de UI, doorloopt de applicatie de volgende stappen:</p> <pre><code>graph TD\n    A[Gebruiker past kleur aan in UI] --&gt; B[UI haalt huidige laag op]\n    B --&gt; C[UI zoekt standaard stylingregel op en haalt Symbology object op]\n    C --&gt; D[UI roept SetFillColor aan op Symbology-object]\n    D --&gt; E[Symbology slaat nieuwe kleur op in private dictionary]\n    subgraph Update van visualisatie\n        E --&gt; F[Laag triggert update naar visualisatieklasse]\n        F --&gt; G[Visualisatieklasse haalt Symbology op]\n        G --&gt; H[Visualisatieklasse leest FillColor uit]\n        H --&gt; I[Visualisatieklasse past nieuwe kleur toe]\n    end\n    I --&gt; J[Visualisatie wordt bijgewerkt]</code></pre> <ol> <li>Gebruiker past kleur aan in UI: De gebruiker kiest een nieuwe kleur voor een laag.</li> <li>UI haalt huidige laag en standaard stylingregel op: De UI haalt de geselecteerde laag en de standaard    stylingregel op, inclusief het bijbehorende Symbology-object.</li> <li>Symbology-object bijwerken: De UI roept de <code>SetFillColor</code> method aan op het Symbology-object, dat de nieuwe kleur    opslaat in een private dictionary.</li> <li>Update van visualisatie: De laag triggert een update naar de visualisatieklasse, die vervolgens het    Symbology-object ophaalt, de nieuwe kleur uitleest, en deze toepast op de visualisatie.</li> <li>Visualisatie wordt bijgewerkt: De visualisatie wordt automatisch bijgewerkt om de nieuwe stijl van de laag te    reflecteren.</li> </ol> <p>Het updaten van de visualisatie is een herbruikbaar blok dat niet alleen in deze flow kan worden ingezet, maar ook bij het openen van een project. Door de scheiding tussen de symbologie data en de visualisatie kan, vergelijkbaar met de scheiding tussen LayerData en visualisatie, styling in het project uniform worden opgeslagen.</p>"},{"location":"docs/developers/features/embedding/","title":"Embedding Netherlands3D on Your Website","text":"<p>You can easily embed Netherlands3D on your own website using an iframe. This allows you to showcase the 3D  representation of the Netherlands directly within your web pages. You can also customize the location and features  displayed using a query string.</p>"},{"location":"docs/developers/features/embedding/#using-an-iframe","title":"Using an Iframe","text":"<p>To embed Netherlands3D with Rijksdriehoekformaat (EPSG:28992) coordinates, use the following HTML code snippet. Replace the <code>src</code> attribute value with the URL of the Netherlands3D digital twin you'd like to embed:</p> <pre><code>&lt;iframe\n        src=\"https://netherlands3d.eu/twin/?origin=161088,503050,300&amp;features=terrain,buildings,trees,sun\"\n        width=\"640\"\n        height=\"480\"\n        frameborder=\"0\"\n&gt;&lt;/iframe&gt;\n</code></pre> <ul> <li> <p>src: Set this attribute to the URL of the Netherlands3D digital twin. You can customize the location and features   using the query string.</p> </li> <li> <p>width and height: Adjust these attributes to define the dimensions of the iframe on your webpage. Make sure the   width   fits your design, and the height provides an optimal viewing experience.</p> </li> <li> <p>frameborder: Set this attribute to \"0\" to remove the iframe border.</p> </li> </ul>"},{"location":"docs/developers/features/embedding/#configuring-location-and-features","title":"Configuring Location and Features","text":"<p>You can customize the location and features displayed in your embedded Netherlands3D using a query string. In the query string, the origin parameter should follow the format <code>origin=X,Y,elevation</code>, where <code>X</code> and <code>Y</code> is the position of the camera in Rijksdriehoekformaat (EPSG:28992) coordinates and elevation is the desired viewing elevation.</p> <p>Here's an example URL with a query string for your reference:</p> <pre><code>https://netherlands3d.eu/twin/?origin=161088,503050,300&amp;features=terrain,buildings,trees,sun\n</code></pre> <ul> <li> <p>origin: This parameter sets the initial view location in the   Rijksdriehoekformaat (EPSG:28992) coordinate system. It follows the format   <code>origin=X,Y,elevation</code>, where elevation is a value between <code>0</code> and <code>1400</code>.</p> </li> <li> <p>features: Use this parameter to specify which features to display in the digital twin. You can include multiple   features, separated by commas.</p> </li> </ul>"},{"location":"docs/developers/features/embedding/#using-the-setup-wizard","title":"Using the Setup Wizard","text":"<p>For an even easier way to generate the query string with the desired configuration, you can visit the Netherlands3D Setup Wizard (https://netherlands3d.eu/twin/). This interactive tool allows you to select the location, features, and other options, and it generates the corresponding query string for your iframe.</p> <p>Once you have the query string, insert it into the <code>src</code> attribute of your iframe code, and you'll have a fully customized embedded Netherlands3D digital twin on your website.</p>"},{"location":"docs/developers/features/floating-origin/","title":"Working with large distances (Floating Origin)","text":"<p>The Floating Origin system allows you to navigate the entire world without encountering floating-point precision errors. Instead of letting the camera roam infinitely far from the unity origin (0, 0, 0), it keeps the camera near the center  by shifting the entire world when needed:</p> <ul> <li> <p>When the camera moves more than 5 kilometers away from (0, 0, 0), the system shifts all GameObjects so that the camera   is back near the origin.</p> </li> <li> <p>This shift is invisible to the user\u2014everything appears stable, while in reality, the whole scene has been    repositioned.</p> </li> <li> <p>Each object stores its real-world coordinates separately, and the Floating Origin itself also tracks its own    real-world position, enabling accurate placement at all times.</p> </li> </ul> <p>Analogy: Imagine sliding the world underneath you in 5 km steps as you move, instead of moving the camera through the   world.</p>"},{"location":"docs/developers/features/floating-origin/#overview-of-the-floating-origin-system","title":"Overview of the Floating Origin System","text":"<p>Before the deep-dive into the components of the Floating Origin system, a basic understanding of the concepts in this  system is required: </p>"},{"location":"docs/developers/features/floating-origin/#real-world-coordinates-and-unity-positions","title":"Real world coordinates and Unity positions","text":"<p>In Unity, the transform component is responsible for tracking the position relative to Unity's (0,0,0) origin point,  when working with large worlds -such as our real-world- this system no longer works due to floating point precision  errors. To solve this, a second mechanic for tracking positions is introduced using real world coordinates in  the WGS84 lat/long ECEF coordinate system.</p> <p>As the distances expressed by real world coordinates are greater than Unity's floating point based transforms, it is  needed to track the real world coordinate of the (0,0,0) origin -called the Floating Origin- and the coordinates  of real world objects.</p> <p>When the camera moves thus far away from the Floating Origin that floating point issues may occur, the origin will  change its real-world coordinate to be nearer to the camera's real-world coordinate and shift the Unity position of all real-world objects to match the new real-world coordinate of Unity's (0,0,0) origin.</p>"},{"location":"docs/developers/features/floating-origin/#floating-origin","title":"(Floating) Origin","text":"<p>The Origin represents the real world coordinates of Unity's (0,0,0) origin and is responsible for tracking the distance  of the Camera from Unity's (0,0,0) origin. If the Camera moves too far away, rendering and calculation anomalies can  happen due to floating point precision issues and all real world objects -including the origin's own real-world  coordinates- need to be shifted so that all elements are back into a safe distance in Unity's coordinate system.</p>"},{"location":"docs/developers/features/floating-origin/#shifting","title":"Shifting","text":"<p>Shifting is the term for when real world objects need to have their Unity position adjusted to get closer to the  Floating Origin. Because the origin's Unity position never changes -it is always at 0,0,0- but its real-world coordinate can change, we need to respond to that by moving real-world objects' Unity position. As soon as this happened, all Game  Objects should be within a safe distance from 0,0,0 again.</p>"},{"location":"docs/developers/features/floating-origin/#real-world-objects","title":"Real-world objects","text":"<p>Real-world objects -sometimes referred to as spatial objects- are game objects whose location is tied to the real-world and have a location in the real world. An example may be a windmill, where a UI element is an example of something that  is not.</p> <p>Real-world objects have a World Transform component that tracks the real-world position and orientation of the object  and when a shift is emitted, they will reposition themselves or its parts.</p>"},{"location":"docs/developers/features/floating-origin/#world-transform","title":"World Transform","text":"<p>The World Transform tracks the real-world position and orientation for a real-world object. The World Transform also reacts to the Origin calling for a shift, but delegates the actual work to a World Transform Shifter component. This allows for objects to respond to shifts differently.</p>"},{"location":"docs/developers/features/floating-origin/#world-transform-shifter","title":"World Transform Shifter","text":"<p>The World Transform Shifter is the component that handles the shifting of a Game Object. Usually you do not need to  provide a specific World Transform Shifter with a World Transform, in that case the default  GameObjectWorldTransformShifter is used. </p>"},{"location":"docs/developers/features/floating-origin/#origin","title":"Origin","text":"<p>In the Floating Origin System, the Origin is an important concept referring to the focal point within the Unity game world. It is crucial for large scale projects where precision becomes a challenge.</p> <p>The Origin is typically associated with its own separate GameObject. This GameObject serves as an indicator or marker of the origin point, and doesn't have any visual representation in the game environment. Its primary role is to maintain the game world's central point and handle shifts in that point to ensure accuracy and consistency in objects' locations in the world.</p> <p>To use the Origin, create an empty GameObject in your scene. This empty GameObject often doesn't need any other components besides Origin. Then, attach the Origin script to this GameObject. Now, the Origin GameObject will continually monitor its distance from the camera (or a specified mainShifter object) while playing.</p>"},{"location":"docs/developers/features/floating-origin/#performance-optimizations-in-origin","title":"Performance Optimizations in Origin","text":"<p>Understanding and managing performance is key in any system, and the Floating Origin System includes several performance optimizations to ensure efficient operation.</p>"},{"location":"docs/developers/features/floating-origin/#using-sqrmagnitude-instead-of-magnitude","title":"Using sqrMagnitude Instead of Magnitude","text":"<p>The process of calculating distance often involves the operation of square roots, which introduce computational complexity. In the Floating Origin System, we use Unity's built-in sqrMagnitude method instead of magnitude for distance calculations.</p> <p>The sqrMagnitude method calculates the square of the magnitude of a distance vector, which omits the need for a square root operation. Since the Origin uses a squared threshold for determining shifting necessity, this optimization aligns perfectly. Simply put, both the mainShifter's distance and the threshold are squared values, so no square root operation is needed, resulting in improved performance without comprising correct operation.</p>"},{"location":"docs/developers/features/floating-origin/#using-a-coroutine-to-wait-until-the-end-of-frame","title":"Using a Coroutine to Wait Until the End of Frame","text":"<p>The Floating Origin System uses Unity's Coroutine feature to postpone the shifting evaluation to the end of each frame. The shifting operation checks at the end of the frame if it needs to reposition the Origin based on the final position of the mainShifter.</p> <p>This optimization minimizes unnecessary Origin shifting, as multiple changes to the mainShifter position within a single frame will only trigger the shifting operation once at the end of the frame. This approach effectively reduces computational load by minimizing the frequency of costly shifting operations.</p>"},{"location":"docs/developers/features/floating-origin/#the-origin-triggers-the-shifts","title":"The Origin triggers the shifts","text":"<p>The Origin in the Floating Origin System demonstrates an example of encapsulation, a fundamental principle of object-oriented programming. Instead of distributing responsibilities across multiple components (like making the camera responsible for calculating distances and triggering shifts), the Floating Origin System centralizes these responsibilities within the Origin.</p> <p>Encapsulating Responsibilities</p> <p>The Origin is responsible for continually monitoring its distance from the camera (or another defined mainShifter object). Using a pre-determined threshold, the Origin decides when the shift operation needs to occur. Once that threshold is surpassed, the Origin triggers a shift operation to reestablish itself closer to the camera or mainShifter. This design decision encapsulates the behavior within the Origin, making it a standalone component that can independently determine and respond to shifts.</p> <p>Performance and Design Improvements</p> <p>The encapsulation model presents several advantages:</p> <ul> <li> <p>Performance: By monitoring the mainShifter's distance at the end of each frame and shifting only when necessary,   the Origin can optimize performance and reduce unnecessary shifts, irrespective of how many changes occur to the   mainShifter during the frame.</p> </li> <li> <p>Design Simplicity: Having the Origin act as the central point of control simplifies task delegation amongst   components and makes the overall system easier to understand.</p> </li> <li> <p>Encapsulation: By keeping related functions within the Origin, the design favors encapsulation, ensuring a clean   system where components' responsibilities are clearly defined and do not blend.</p> </li> </ul>"},{"location":"docs/developers/features/floating-origin/#worldtransform","title":"WorldTransform","text":"<p>An analogy: transforms and rigidbodies</p> <p>To illustrate how the WorldTransform and their Shifters work, you can compare them to the way Transform and RigidBodies work in Unity. The Transform holds the position, rotation and scale and can be manipulated; but the actual physics  interaction -movement forced by external factors- is accomplished through a RigidBody component, or even a  CharacterController.</p> <p>In Unity, you have one transform and one type of RigidBody/Character Controller; and with the WorldTransform this works similarly: the WorldTransform works like a Transform and records the position of the real-world object, where a  WorldTransformShifter functions like a RigidBody and exerts force on the WorldTransform when a Shift happens. </p> <p>The WorldTransform is effectively the real-world equivalent of an object's location within the Unity game world. When the Origin shifts, the WorldTransform is adjusted correspondingly. Meanwhile, Unity's native Transform class remains untouched. This results in two interconnected, but separate, coordinate systems.</p> <p>Not all objects will need to handle a shift in the same way. The default is to shift the GameObject itself, but some objects are containers whose children need to shift and not themselves -example: tile handlers- or where transformation matrices are used instead of transform components -example: instanced objects-. By delegating this responsibility to a World Transform Shifter all real-world objects will track their coordinates in the same way but have different ways to react to shift events.</p>"},{"location":"docs/developers/features/floating-origin/#worldtransformshifter","title":"WorldTransformShifter","text":"<p>The WorldTransformShifter is meant to manage the effects of moving the Origin on GameObjects. Custom behaviors for  different types of GameObjects when the Origin shifts can be defined by implementing the method ShiftTo in derived  classes of WorldTransformShifter.</p> <p>When it is not the GameObject itself whose position needs to change but a child or something not directly linked to the  transform position, then you need to use one of the other strategies. See below for more information.</p> <p>Tip</p> <p>The WorldTransform and its Shifters is an implementation of the Strategy design pattern.</p>"},{"location":"docs/developers/features/floating-origin/#specialized-shifters","title":"Specialized Shifters","text":"<p>Specialized Shifters are used to manage Origin shifts for unique types of GameObjects not part of the Unity base package. These could be packages like Netherlands3D 3DTiles that have their unique behaviors. An example of this is ThreeDTilesWorldTransformShifter. This sub-class handles shifts for child GameObjects associated with the Content component. When an Origin shift happens, it iterates over all Content components and adjusts the positions of all their children.</p>"},{"location":"docs/developers/features/floating-origin/#usage","title":"Usage","text":"<p>To use the Floating Origin System within your Unity projects:</p> <ol> <li>Attach the Origin component to a GameObject that will act as the world origin.</li> <li>For objects that should maintain real-world positions, attach the WorldTransform component.</li> <li>For specialized objects, for example, objects from the Netherlands3D 3DTiles package, attach a specialized    WorldTransformShifter, like ThreeDTilesWorldTransformShifter.</li> </ol>"},{"location":"docs/developers/features/geojson/","title":"GeoJSON Support","text":"<p>Netherlands3D enables users to import and work with GeoJSON data seamlessly. Below is a breakdown of how GeoJSON files are supported, including file handling, parsing, coordinate transformation, and more.</p>"},{"location":"docs/developers/features/geojson/#importing","title":"Importing","text":"<p>Netherlands3D supports <code>.json</code> and <code>.geojson</code> file extensions by default. For custom file types, you can extend support by modifying:</p> <ul> <li>FileOpen script: Enables selection of additional file types.</li> <li>FileTypeAdapter: Handles the processing of new file types.</li> </ul> <p>GeoJSON files are uploaded and embedded as assets within the open NL3D project. When opened from a URL, pointing to GeoJSON files ( e.g., https://raw.githubusercontent.com/blackmad/neighborhoods/refs/heads/master/utrecht.geojson), these are added as remote assets, ensuring they reload every time a project is opened.</p>"},{"location":"docs/developers/features/geojson/#parsing-and-performance","title":"Parsing and Performance","text":"<p>To prevent application freezes when importing large files, GeoJSON parsing is spread across multiple frames. The default parsing time per frame is 0.01 seconds, but this value can be adjusted by modifying the <code>maxParseDuration</code> variable in <code>GeoJSONLayer.cs</code>.</p>"},{"location":"docs/developers/features/geojson/#supported-feature-types","title":"Supported Feature Types","text":"<p>Netherlands3D supports the following GeoJSON feature types:</p> <ul> <li>Polygon</li> <li>MultiPolygon</li> <li>LineString</li> <li>MultiLineString</li> <li>Point</li> <li>MultiPoint</li> </ul> <p>Features of the same type are combined into a single layer in the application:</p> <ul> <li>Polygon and MultiPolygon \u2192 One layer.</li> <li>LineString and MultiLineString \u2192 One layer.</li> <li>Point and MultiPoint \u2192 One layer.</li> </ul>"},{"location":"docs/developers/features/geojson/#coordinate-transformation","title":"Coordinate Transformation","text":"<p>GeoJSON coordinates are converted to Unity coordinates using the  <code>eu.netherlands3d.coordinates</code> package. The transformation leverages the parsed CRS (Coordinate Reference System).</p>"},{"location":"docs/developers/features/geojson/#crs-support","title":"CRS Support","text":"<ul> <li>Netherlands3D supports the \"Named CRS\" feature described in the original pre-2018 GeoJSON   specification (see details here), enabling backwards compatibility   for older GeoJSON files that define their own CRS.</li> <li>Support for the \"Linked CRS\" variant is not provided.</li> <li>Custom CRS definitions are not supported in the current GeoJSON specification, but legacy files using \"Named CRS\" are   still supported.</li> </ul>"},{"location":"docs/developers/features/geojson/#visualization-and-appearance","title":"Visualization and Appearance","text":"<p>A material can be assigned to a GeoJSONLayer to control the visualization's appearance. This allows for customization of how imported GeoJSON features are displayed in the 3D environment.</p>"},{"location":"docs/developers/features/geojson/#error-handling","title":"Error Handling","text":"<p>Netherlands3D includes error handling for GeoJSON imports. If parsing fails, an event is invoked to display error messages on-screen, ensuring users are informed of any issues during the import process.</p>"},{"location":"docs/developers/features/geojson/#troubleshooting","title":"Troubleshooting","text":"<p>If GeoJSON data does not display correctly in Netherlands3D, follow these steps to verify data correctness before debugging the code:</p> <ol> <li>Open the file in QGIS: Check if QGIS can successfully display the data. If QGIS cannot load the file, the data    may be incorrect.</li> <li>Validate the GeoJSON structure and geometry: Use    the GeoJSON Validator to confirm the file\u2019s structure and geometry are    valid.</li> <li>Test the file in GeoJSON.io: Try loading the file in GeoJSON.io to verify if the data    renders correctly.</li> </ol> <p>These steps help ensure the GeoJSON file is correct and usable, minimizing unnecessary debugging in the code.</p>"},{"location":"docs/developers/guides/adding-styling-support-to-layers/","title":"Add styling support to layers","text":""},{"location":"docs/developers/guides/adding-styling-support-to-layers/#goal","title":"Goal","text":"<p>Show how to extend <code>LayerGameObject</code> to surface its visual elements as <code>LayerFeature</code> instances, and how to build a companion \u201cStyler\u201d class that applies and persists style rules to your layer\u2019s features.</p>"},{"location":"docs/developers/guides/adding-styling-support-to-layers/#prerequisites","title":"Prerequisites","text":"<ul> <li>You already have a subclass of <code>LayerGameObject</code> for your custom layer type (e.g. <code>MyCustomLayerGameObject</code>).</li> <li>You understand the basics of the Netherlands3D Expression &amp; Styling system (see \u201cHow to color parts of the terrain\u201d   guide).</li> </ul>"},{"location":"docs/developers/guides/adding-styling-support-to-layers/#step-1-expose-your-features","title":"Step 1: Expose your features","text":"<p>In your <code>LayerGameObject</code> subclass\u2019s <code>Awake()</code>, create one <code>LayerFeature</code> per visual element (e.g. per material,  per mesh, per component). This lets the styling engine treat them as independent style targets.</p> <p>Example</p> <p>In this example is shown how each of the materials is converted into a LayerFeature since that is for a mesh layer  often that which distinguishes a feature - or type of feature. This can also be a GameObject -as happens for the  .OBJ import- or actual GeoJSON.net Feature objects.</p> <pre><code>// MyCustomLayerGameObject.cs\nprotected override void Awake()\n{\n    base.Awake();\n\n    for (int i = 0; i &lt; layer.DefaultMaterialList.Count; i++)\n    {\n        // duplicate material so color changes don\u2019t bleed into the original\n        var mat = new Material(layer.DefaultMaterialList[i]);\n        layer.DefaultMaterialList[i] = mat;\n\n        var feature = CreateFeature(mat); // Create the feature and ..\n        LayerFeatures.Add(mat, feature); // .. register it\n    }\n}\n</code></pre> <p>The styling system only sees what you expose as <code>LayerFeatures</code>. By calling <code>CreateFeature(geometry)</code>, you get a  <code>LayerFeature</code> with a hook to <code>AddAttributesToLayerFeature</code> (next step).</p>"},{"location":"docs/developers/guides/adding-styling-support-to-layers/#step-2-annotate-each-feature-with-identifying-attributes","title":"Step 2: Annotate each feature with identifying attributes","text":"<p>Override <code>AddAttributesToLayerFeature</code> to record everything the Styler needs\u2014e.g. material index, material name, any semantic tags.</p> <p>Example</p> <pre><code>// MyCustomLayerGameObject.cs\nprotected override LayerFeature AddAttributesToLayerFeature(LayerFeature feature)\n{\n    // guard that the geometry is a material\n    if (feature.Geometry is not Material mat) return feature;\n\n    // perform a lookup of the material index\n    int idx = mesh.DefaultMaterialList.IndexOf(mat);\n\n    feature.Attributes.Add( \n        CartesianTileLayerStyler.MaterialIndexIdentifier, // key for the attribute, here shown as a const \n        idx.ToString() // record the material index as an identifier for this feature\n    );\n    feature.Attributes.Add(\n        CartesianTileLayerStyler.MaterialNameIdentifier, // key for the attribute, here shown as a const\n        mat.name // record the material name as a name for this feature\n    );\n\n    return feature;\n}\n</code></pre> <p>Expressions work by matching on feature attributes. This step encodes the minimal context your Styler will need. Please note that LayerFeatures can also be used for other purposes, such as showing information in the information panels, thus more attributes may be needed.</p> <p>Tip</p> <p>If you add custom attributes on top of the source data -such as GeoJSON features- it is recommended to prefix these to prevent naming collisions. The prefix for custom attributes is generally <code>data-</code>, by default the styling system will also include <code>nl3d_layer_id</code> and <code>nl3d_layer_name</code>.</p>"},{"location":"docs/developers/guides/adding-styling-support-to-layers/#step-3-implement-applystyling-to-invoke-your-styler","title":"Step 3: Implement <code>ApplyStyling</code> to invoke your Styler","text":"<p>Override <code>ApplyStyling</code> and, for each feature, request the resolved <code>Symbolizer</code> using the <code>GetStyling()</code> method and  hand it off to your custom Styler class.</p> <p>Example</p> <pre><code>// MyCustomLayerGameObject.cs\npublic override void ApplyStyling()\n{\n    foreach (var (_, feature) in LayerFeatures)\n    {\n        var styling = GetStyling(feature);\n        MyCustomLayerStyler.Apply(layer, styling, feature);\n    }\n\n    base.ApplyStyling();\n}\n</code></pre> <p>Calling <code>base.ApplyStyling()</code> at the end ensures events fire for UI panels, property refreshes, etc.</p>"},{"location":"docs/developers/guides/adding-styling-support-to-layers/#step-4-build-your-styler-helper","title":"Step 4: Build your \u201cStyler\u201d helper","text":"<p>Encapsulate all expression-creation and object-manipulation logic in a static helper class (e.g. <code>MyCustomLayerStyler</code>). This keeps your layer class clean and makes styling behavior discoverable.</p>"},{"location":"docs/developers/guides/adding-styling-support-to-layers/#step-4a-register-and-retrieve-styling-rules","title":"Step 4a: Register and Retrieve Styling Rules","text":"<p>Before you can apply visuals, your Styler must expose methods to register new style rules and retrieve saved styles for UI integration.</p> <ul> <li> <p>Registering: create or update a <code>StylingRule</code> in <code>LayerData.DefaultStyle.StylingRules</code>. For example:   <pre><code>MyCustomLayerStyler.SetColor(layerGO, feature, Color.red);\n</code></pre>   Internally, this creates an expression like <code>Get(\"data-materialindex\") == \"2\"</code> and sets the rule\u2019s FillColor.</p> </li> <li> <p>Retrieving: read back any existing override or fall back to the default material color:   <pre><code>Color? current = MyCustomLayerStyler.GetColor(layerGO, feature);\n</code></pre></p> </li> </ul> <p>This separation ensures that style registration and UI display logic live in your Styler class, cleanly apart from rendering.</p>"},{"location":"docs/developers/guides/adding-styling-support-to-layers/#step-4b-applying-styling-rules","title":"Step 4b: Applying styling rules","text":"<p>To update any visuals, the Apply method must take the resolved <code>Symbolizer</code> \u2014 which encapsulates all style  properties for a feature\u2014and translate those into concrete modifications on your layer\u2019s objects. </p> <p>This typically involves:</p> <ul> <li>Retrieving style attributes (e.g. fill color, opacity, line width) from the <code>Symbolizer</code>.</li> <li>Determining which visual element to target (by material index, component reference, or other attribute).</li> <li>Applying those properties directly to the Unity object (e.g. changing <code>Material.color</code>, adjusting mesh renderer    settings).</li> </ul> <p>By centralizing this logic in <code>Apply</code>, you ensure that all style rules are consistently enforced whenever  <code>ApplyStyling()</code> is called.</p> <pre><code>// MyCustomLayerStyler.cs\npublic static class MyCustomLayerStyler\n{\n    // Declare keys for custom attributes to keep track\n    public const string MaterialIndexIdentifier = \"data-materialindex\";\n\n    // Applies the resolved style to the Unity objects\n    public static void Apply(BinaryMeshLayer meshLayer, Symbolizer styling, LayerFeature feature) \n    {\n        // Grab the fill color from the symbolizer\n        Color? color = styling.GetFillColor();\n        if (!color.HasValue) return;\n\n        // Attempt to get the material index from the layer feature' attributes\n        if (!int.TryParse(layerFeature.Attributes[MaterialIndexIdentifier], out var materialIndex)) return;\n\n        // Apply the grabbed color to the given material\n        layer.DefaultMaterialList[materialIndex].color = color.Value;\n    }\n}\n</code></pre>"},{"location":"docs/developers/guides/adding-styling-support-to-layers/#verification","title":"Verification","text":"<ol> <li>Enter Play Mode and open your custom layer\u2019s property panel.</li> <li>Define a new style rule (e.g. \u201cmaterial == 2 \u2192 color = red\u201d).</li> <li>Observe that only the intended feature(s) change color.</li> <li>Save and reload the project \u2014 verify your rule is still applied.</li> </ol>"},{"location":"docs/developers/guides/adding-styling-support-to-layers/#whats-next","title":"What\u2019s next?","text":"<ul> <li>Add support for line-width, opacity or other symbolizer properties.</li> <li>Expose a color-picker or style-preset dropdown in your layer\u2019s UI.</li> <li>Document your Styler API so other developers can discover available expressions.</li> </ul>"},{"location":"docs/developers/guides/adding-styling-support-to-layers/#further-reading","title":"Further Reading","text":"<ul> <li>Explanation: Layer styling - for more in-depth information how the styling system works.</li> </ul>"},{"location":"docs/developers/guides/asset-bundles/","title":"Using Asset Bundles to add Objects to the Object Library","text":""},{"location":"docs/developers/guides/asset-bundles/#introduction","title":"Introduction","text":"<p>This is an experimental feature</p> <p>This feature is in an experimental stage and the guide below is subject to change. Use at your own peril.</p> <p>Asset Bundles are an excellent way to extend the functionality of Netherlands3D by enabling developers to include advanced or prebuilt assets, such as textured FBX files, that may not be feasible to load during the initial application startup.</p> <p>By utilizing Asset Bundles, you can significantly reduce the initial loading time of your application while providing end users with access to complex assets on demand. This guide will walk you through how to build an Asset Bundle, load it into your Netherlands3D project, and make the included assets available in the Object Library for your twin.</p>"},{"location":"docs/developers/guides/asset-bundles/#prerequisites","title":"Prerequisites","text":"<p>This feature is only available when using the Netherlands3D \"Twin\" project as  the basis for your digital twin viewer. The instructions in this guide assume that you are following the same directory  structure and conventions as the \"Twin\" project. Ensure that your project setup aligns with these assumptions to avoid  integration issues.</p>"},{"location":"docs/developers/guides/asset-bundles/#step-1-creating-a-layer-prefab","title":"Step 1: Creating a Layer Prefab","text":"<p>Before building an Asset Bundle, you need to create a prefab that can be registered as a Layer prefab. This prefab serves as the entry point for your assets and will automatically be made available in the Object Library.</p> <p>This can be accomplished by following our guide on  adding a simple type of layer. Do remember  the name of the asset file, as we will be using that in the last step.</p>"},{"location":"docs/developers/guides/asset-bundles/#step-2-build-an-asset-bundle","title":"Step 2: Build an Asset Bundle","text":"<p>To create an Asset Bundle, follow these steps:</p> <ol> <li> <p>Organize your assets, including the Layer Prefab:</p> <ul> <li>Place all the assets you wish to include in your Asset Bundle into the folder named <code>AssetBundleAssets</code> in the   <code>Assets/_Functionalities/AssetBundles</code> folder within your Unity project.</li> </ul> </li> <li> <p>Assign assets to the Asset Bundle:</p> <ul> <li>Select each asset you wish to include and assign it to an Asset Bundle. This can be done in the Inspector   window, under the AssetBundle dropdown menu. For more information, refer to   the Unity documentation.</li> </ul> </li> <li> <p>Build the Asset Bundle:</p> <ul> <li>Navigate to the Unity menu bar, select <code>Assets</code>, and then click <code>Build AssetBundles</code>.</li> <li>Unity will compile your assets into a single Asset Bundle and place it in the <code>StreamingAssets</code> folder of your   project.</li> </ul> </li> </ol> <p>Tip</p> <p>If you make any changes to a prefab or asset included in an Asset Bundle, you must rebuild the Asset Bundle by repeating the steps above.</p>"},{"location":"docs/developers/guides/asset-bundles/#notes","title":"Notes:","text":"<ul> <li> <p>Ensure that all assets included in the Asset Bundle are properly configured and optimized to avoid runtime issues.</p> </li> <li> <p>Assigning assets to an Asset Bundle is a critical step for ensuring they are included in the build.</p> </li> <li> <p>Keep your memory footprint as low as possible, and then even lower. WebGL applications are bound to a maximum of 2GBs    of RAM by the browser.</p> </li> </ul>"},{"location":"docs/developers/guides/asset-bundles/#step-3-registering-your-asset-bundle-with-the-object-library","title":"Step 3. Registering your Asset Bundle with the Object Library","text":"<p>Once an asset bundle is available, you need to ensure the viewer know about it and registers the prefab -from step 1- as an object in the Object Library. You can do this by creating a game object responsible for loading the Object from the Asset bundle:</p> <ol> <li>Create a new GameObject as a child of the <code>Functionalities</code> GameObject in the Hierarchy</li> <li>Attach the <code>AssetBundleLoader</code> MonoBehaviour</li> <li>Configure the Loading Screen Prefab and Canvas -recommended is to use the <code>AssetBundleLoader</code> prefab for the loader,     and the <code>InterfaceUtilities</code> as the canvas.</li> <li>Assign the name of your asset bundle to the <code>Bundle Name</code> field - this is the name you used in Step 2 when tagging      assets.</li> <li>Assign the name of your Layer GameObject prefab's asset file -from Step 1- to the <code>Prefab Name</code> field, including the     <code>.prefab</code> extension</li> </ol> <p>That's it! When you load your application, you should find your new object in the Object Library.</p>"},{"location":"docs/developers/guides/asset-bundles/#common-issues-and-solutions","title":"Common Issues and Solutions","text":"<p>Below are some common issues developers encounter when using Asset Bundles, along with their solutions:</p> <ol> <li> <p>Issue: Asset Bundle fails to load.</p> </li> <li> <p>Solution: Check that the Asset Bundle file is placed in the correct location and that the file path in your script       is accurate.</p> </li> <li> <p>Issue: Prefab is not found in the Asset Bundle.</p> </li> <li> <p>Solution: Ensure that the prefab\u2019s name matches the name used in the AssetBundleLoader prefab.</p> </li> <li> <p>Issue: Changes to prefabs are not reflected.</p> </li> <li> <p>Solution: Rebuild the Asset Bundle after making any changes to the included prefabs or assets.</p> </li> <li> <p>Issue: Some assets are not visible or missing</p> </li> <li> <p>Solution: Reimport the assets in the asset bundle folder, check if their Asset Bundle field is properly set and       rebuild the asset bundle.</p> </li> <li> <p>Issue: The application crashes upon loading with a popup dialog.</p> </li> <li> <p>Solution: make your assets smaller, your asset bundle pushes the memory usage of the application beyond 2GB of RAM      and WebGL applications crash when that happens.</p> </li> </ol>"},{"location":"docs/developers/guides/dealing-with-cors-issues/","title":"Dealing with CORS issues during development","text":"<p>When using external web services (e.g., WFS, WMS, 3D Tiles) with Netherlands3D,  Cross-Origin Resource Sharing (CORS) restrictions can disrupt  development. To avoid waiting on backend adjustments from a DevOps team, you can use a local CORS proxy like  <code>local-cors-proxy</code>, which circumvents these issues while developing.</p> <p>What is CORS, and Why Does It Affect Web Applications?</p> <p>CORS (Cross-Origin Resource Sharing) is a security feature in web browsers that restricts web applications from  making requests to a different domain than the one that served the initial page. This policy prevents unauthorized  access to sensitive data from other origins (e.g., servers) that didn\u2019t explicitly permit the connection. Desktop  applications, unlike web applications, aren\u2019t bound by browser-enforced CORS rules, which is why they can access  multiple origins without restrictions.</p>"},{"location":"docs/developers/guides/dealing-with-cors-issues/#step-1-install-nodejs-and-npm","title":"Step 1: Install Node.js and NPM","text":"<p>If you don\u2019t already have Node.js, download and install it from Node.js.</p>"},{"location":"docs/developers/guides/dealing-with-cors-issues/#step-2-install-local-cors-proxy","title":"Step 2: Install <code>local-cors-proxy</code>","text":"<p>Open your terminal (or PowerShell in Windows) and install  local-cors-proxy globally:</p> <pre><code>npm install -g local-cors-proxy\n</code></pre>"},{"location":"docs/developers/guides/dealing-with-cors-issues/#step-3-start-the-local-cors-proxy","title":"Step 3: Start the Local CORS Proxy","text":"<p>To start, run the following command, where <code>&lt;TARGET_WEBSERVICE_URL&gt;</code> is the service URL you need to access:</p> <pre><code>lcp --proxyUrl &lt;TARGET_WEBSERVICE_URL&gt;\n</code></pre> <p>By default, this will run on port <code>8010</code>. For a custom port, specify it as <code>--port &lt;PORT_NUMBER&gt;</code>.</p>"},{"location":"docs/developers/guides/dealing-with-cors-issues/#step-4-handling-self-signed-certificates","title":"Step 4: Handling Self-Signed Certificates","text":"<p>If the target service uses a self-signed certificate, you may need to disable SSL verification by setting the <code>NODE_TLS_REJECT_UNAUTHORIZED</code> environment variable to <code>0</code>.</p> Linux / macOSWindows PowerShell <pre><code>export NODE_TLS_REJECT_UNAUTHORIZED=0\n</code></pre> <pre><code>$env:NODE_TLS_REJECT_UNAUTHORIZED=0\n</code></pre> <p>This setting should be applied before running the proxy.</p>"},{"location":"docs/developers/guides/dealing-with-cors-issues/#step-5-pass-proxied-urls-in-netherlands3d","title":"Step 5: Pass Proxied URLs in Netherlands3D","text":"<p>Point service requests to the proxy URL, e.g., <code>http://localhost:8010/&lt;original_service_url_path&gt;</code>, allowing requests to pass through the proxy for CORS management. This includes importing services by URL in the layers panel.</p>"},{"location":"docs/developers/guides/dealing-with-cors-issues/#step-6-test-the-setup","title":"Step 6: Test the Setup","text":"<p>Run Netherlands3D, confirming that requests are passing through the proxy. Use browser developer tools or monitor the terminal to check for successful CORS handling.</p>"},{"location":"docs/developers/guides/how-to-color-parts-of-the-terrain/","title":"How to color parts of the terrain","text":""},{"location":"docs/developers/guides/how-to-color-parts-of-the-terrain/#introduction","title":"Introduction","text":"<p>How to use the CartesianTileLayerStyler and expressions to assign distinct fill colors to specific terrain feature types\u2014e.g. footpaths, residential zones, and roads\u2014based on their material index.</p> <p>Using the Netherlands3D styling system ensures that any styling rules you define are saved directly into the project file and will be automatically reapplied whenever the project is reopened or the layer is reloaded.</p>"},{"location":"docs/developers/guides/how-to-color-parts-of-the-terrain/#prerequisites","title":"Prerequisites","text":"<ul> <li>A <code>BinaryMeshLayer</code> or similar layer already added to your scene</li> </ul>"},{"location":"docs/developers/guides/how-to-color-parts-of-the-terrain/#step-1-identify-your-feature-type-material-index-mapping","title":"Step 1: Identify your feature-type \u2192 material-index mapping","text":"<p>Your tile data assigns each feature a material index via the <code>data-materialindex</code> attribute. Decide which indices correspond to each terrain part. For example:</p> <pre><code>// These values depend on how your CartesianTiles are authored!\nconst int footpathIndex      = 0;   // e.g. \u201cfootpath\u201d material\nconst int residentialIndex   = 1;   // e.g. \u201cresidential area\u201d material\nconst int roadIndex          = 2;   // e.g. \u201croad\u201d material\n</code></pre> <p>If you\u2019re not sure, inspect your layer\u2019s mesh materials in the editor or log <code>layerFeature.Attributes[\"data-materialindex\"]</code> at runtime.</p>"},{"location":"docs/developers/guides/how-to-color-parts-of-the-terrain/#step-2-choose-your-colors","title":"Step 2: Choose your colors","text":"<p>Define the <code>Color</code> instances you want to use:</p> <pre><code>var footpathColor = new Color(0.8f, 0.7f, 0.5f); // a light sandy tone\nvar residentialColor = new Color(0.9f, 0.9f, 0.6f); // a pale yellow\nvar roadColor = new Color(0.7f, 0.7f, 0.7f); // light gray\n</code></pre>"},{"location":"docs/developers/guides/how-to-color-parts-of-the-terrain/#step-3-apply-styling-in-code","title":"Step 3: Apply styling in code","text":"<p>In your layer-initialization (or UI callback), call <code>CartesianTileLayerStyler.SetColor</code> for each type:</p> <pre><code>void StyleTerrainLayer(BinaryMeshLayer terrainLayer)\n{\n    // Get the LayerGameObject wrapper\n    var layerGO = terrainLayer.GetComponent&lt;LayerGameObject&gt;();\n\n    // Iterate the existing features in this layer\n    foreach (var kvp in layerGO.LayerData.LayerFeatures)\n    {\n        var layerFeature = kvp.Value;\n\n        // Get the material index identifier from the attributes        \n        if (!layerFeature.Attributes.TryGetValue(\"data-materialindex\", out var idxStr)) continue;\n        if (!int.TryParse(idxStr, out var materialIndex)) continue;\n\n        // Choose color based on materialIndex\n        switch (materialIndex)\n        {\n            case footpathIndex: CartesianTileLayerStyler.SetColor(layerGO, layerFeature, footpathColor); break;\n            case residentialIndex: CartesianTileLayerStyler.SetColor(layerGO, layerFeature, residentialColor); break;\n            case roadIndex: CartesianTileLayerStyler.SetColor(layerGO, layerFeature, roadColor); break;\n            // add more cases as needed\n        }\n    }\n}\n</code></pre> <p>What\u2019s happening? For each <code>LayerFeature</code> you find with a given index, <code>SetColor</code> builds an expression like</p> <pre><code>Expression.EqualTo(\n    Expression.Get(\"data-materialindex\"),\n    \"&lt;index&gt;\"\n)\n</code></pre> <p>and installs a <code>StylingRule</code> that fills any real feature with that same index in your layer.</p>"},{"location":"docs/developers/guides/how-to-color-parts-of-the-terrain/#step-4-verify-in-the-editor","title":"Step 4: Verify in the Editor","text":"<ol> <li>Enter Play Mode (or run in the Scene view).</li> <li>Inspect your terrain layer: footpaths should now use <code>footpathColor</code>, residential blocks use <code>residentialColor</code>, and    roads use <code>roadColor</code>.</li> <li>If anything looks off, check the console for parsing errors or confirm the right material indices.</li> </ol>"},{"location":"docs/developers/guides/how-to-color-parts-of-the-terrain/#whats-next","title":"What\u2019s next?","text":"<ul> <li>Combine multiple indices: if \u201croads\u201d span two materials, use a single <code>StylingRule</code> with <code>Expression.Any</code>:   <pre><code>var roadExpr = Expression.Any(\n    Expression.EqualTo(Expression.Get(\"data-materialindex\"), \"2\"), // first road material\n    Expression.EqualTo(Expression.Get(\"data-materialindex\"), \"3\") // second road material\n);\n</code></pre>   It is recommended to add a convenience method, such as <code>SetRoadColor()</code> to the <code>CartesianTileLayerStyler</code> class -or   through an extension method- to have a logical interface how to manipulate the styling of this type of layer.</li> <li>Dynamic UI: build a color-picker panel that reads the current style via <code>GetColor</code> and lets users tweak colors at   runtime.</li> </ul>"},{"location":"docs/developers/guides/how-to-color-parts-of-the-terrain/#performance-tips","title":"Performance tips","text":"<ul> <li>Regroup similar expressions into fewer rules; avoid one-rule-per-feature if you have hundreds.</li> </ul>"},{"location":"docs/developers/guides/how-to-color-parts-of-the-terrain/#further-reading","title":"Further Reading","text":"<ul> <li>Explanation: Layer styling - for more in-depth information how the styling system works.</li> </ul>"},{"location":"docs/developers/guides/loading-a-custom-project-file/","title":"Loading your own customized default Project","text":"<p>In the Netherlands3D application, a default file named <code>ProjectTemplate.nl3d</code> is used. This file is located in the  <code>StreamingAssets</code> folder and is loaded at application startup. It defines the default settings, such as the  location, and allows the twin installation to be customized according to the needs of the organization using the  application.</p>"},{"location":"docs/developers/guides/loading-a-custom-project-file/#creating-the-intended-project","title":"Creating the intended Project","text":"<p>To create a custom project file, use your twin installation to configure the desired view, including layers and settings. Once satisfied with the setup, save the project as a file named <code>ProjectTemplate.nl3d</code>. This file can then be used to define the default settings for your Netherlands3D application.</p>"},{"location":"docs/developers/guides/loading-a-custom-project-file/#built-from-source","title":"Built from Source","text":"<p>If you choose to build the Netherlands3D project from source rather than using the available Docker image, you can directly place the created <code>ProjectTemplate.nl3d</code> file into the <code>StreamingAssets</code> folder before building the  application. This allows the default settings to be included with your custom-built application.</p>"},{"location":"docs/developers/guides/loading-a-custom-project-file/#using-docker-and-mounts","title":"Using Docker and Mounts","text":"<p>The default Netherlands3D application is deployed as a Docker image, built via our GitHub Actions pipeline and hosted in the Github Container Registry. Docker images act as virtual servers with all required files and configurations preconfigured. Typically, this setup offers little flexibility to modify files in the image without rebuilding it.</p> <p>To simplify things for organizations and DevOps specialists, our Docker image is designed to allow an external directory to be mounted in the Docker container. This makes it possible to add a custom project file without rebuilding the image.</p> <p>!!! info What is Mounting?</p> <pre><code>Mounting is a technique that makes an external storage location, such as a folder on a server or in the cloud,\naccessible within an application or container. It works as a virtual link: files or directories from the external\nlocation become accessible as if they were locally available in the container.\n\nFor example:\n\n- By mounting a folder, configurations or files can be modified without rebuilding the container.\n- In environments that support file-level mounts (like Docker), it is more efficient to directly mount a file\n  to `/usr/share/nginx/html/StreamingAssets/DefaultTemplate.nl3d`, as changes become immediately visible without\n  restarting the container.\n</code></pre>"},{"location":"docs/developers/guides/loading-a-custom-project-file/#general-steps-for-configuring-a-mount","title":"General Steps for Configuring a Mount","text":"<ol> <li>Prepare the external storage location:<ul> <li>Ensure the storage location (e.g., a folder on a server or a cloud storage container) is configured and   accessible.</li> </ul> </li> <li>Place the project file:<ul> <li>Place the custom project file (e.g., <code>DefaultTemplate.nl3d</code>) in the external storage location.</li> </ul> </li> <li> <p>Configure the mount:</p> <ul> <li> <p>Set up the mount so that the external storage location is linked to the desired directory in the Docker container,   such as <code>/usr/share/nginx/html/StreamingAssets/Projects/</code>. For a single file mount, use *   <code>/usr/share/nginx/html/StreamingAssets/DefaultTemplate.nl3d</code>*.</p> </li> <li> <p>Restart the application or container to apply the new configuration. A single file mount does not require a   restart.</p> </li> <li>Verify:</li> <li>Check if the application has correctly loaded the changes.</li> </ul> </li> </ol>"},{"location":"docs/developers/guides/loading-a-custom-project-file/#example-configuring-a-mount-locally-via-docker-command-line","title":"Example: Configuring a Mount Locally via Docker Command Line","text":"<p>Here is an example of how to configure a mount using the Docker command line when running Netherlands3D locally:</p> <ol> <li>Make the project file available:<ul> <li>Ensure the custom project file <code>DefaultTemplate.nl3d</code> is available on your local system or an external storage   location.</li> </ul> </li> <li> <p>Start the Docker container with a file mount:</p> <ul> <li> <p>Use the following command to start the container:</p> <pre><code>docker run -d \\\n  -v /path/to/DefaultTemplate.nl3d:/usr/share/nginx/html/StreamingAssets/DefaultTemplate.nl3d \\\n  --name netherlands3d \\\n  ghcr.io/netherlands3d/twin:latest\n</code></pre> </li> </ul> <p>In this example, the file <code>/path/to/DefaultTemplate.nl3d</code> is directly linked to the expected location in the   container. 3. No restart required: - Since the file is mounted directly, changes are immediately visible without restarting the container. 4. Verify: - Check if the application has correctly loaded the changes by opening it in the browser.</p> </li> </ol>"},{"location":"docs/developers/guides/loading-a-custom-project-file/#example-configuring-a-mount-via-azure-portal","title":"Example: Configuring a Mount via Azure Portal","text":"<p>Below are the steps to set this up using the Azure Portal:</p> <ol> <li>Create a Blob Storage Container:<ul> <li>In the Blob Storage for your environment, create a container to store project files, for example, named *   <code>projects</code>*.</li> </ul> </li> <li>Upload the project file:<ul> <li>Upload the new default project file, named <code>DefaultTemplate.nl3d</code>, to the container.</li> </ul> </li> <li>Go to the Web App Service:<ul> <li>Open the Azure Portal and navigate to the Web App Service for your environment.</li> </ul> </li> <li>Open Settings:<ul> <li>Open the <code>Settings</code> menu and go to <code>Configuration</code> in the sidebar.</li> </ul> </li> <li>Configure Path Mappings:<ul> <li>Go to the <code>Path mappings</code> tab.</li> <li>Add a new Azure Storage Mount with a name of your choice, such as \"Projects\".</li> </ul> </li> <li>Link the Blob Storage:<ul> <li>In the <code>Storage Accounts</code> dropdown, select the storage account associated with the Blob Storage containing the   container.</li> <li>In the <code>Storage Container</code> dropdown, select the container you created earlier, such as <code>projects</code>.</li> </ul> </li> <li>Set the Mount Path:<ul> <li>Enter the following value for <code>Mount Path</code>: <code>/usr/share/nginx/html/StreamingAssets/Projects/</code>.</li> <li>This makes the contents of the Blob Storage container available at this location in the Docker container.</li> </ul> </li> <li>Save Settings:<ul> <li>Click <code>Ok</code>, and then <code>Save</code> to save the changes.</li> </ul> </li> <li>Restart the Web App Service:<ul> <li>Go back to the <code>Overview</code> page for the Web App Service and click <code>Restart</code>. This will restart the Docker   container and initialize the <code>DefaultTemplate.nl3d</code> file.</li> </ul> </li> <li>Check in the browser:<ul> <li>Open the application in the browser to verify that the configuration has been applied correctly.</li> </ul> </li> </ol>"},{"location":"docs/developers/guides/troubleshooting-build-pipeline-failures/","title":"Troubleshooting Build Pipeline Failures","text":"<p>This guide outlines common issues, their root causes, and solutions specific to our Unity build pipeline, which uses Game-CI on GitHub Actions.</p>"},{"location":"docs/developers/guides/troubleshooting-build-pipeline-failures/#unity-build-errors","title":"Unity Build Errors","text":"<p>When Unity encounters a problem during the build process, the <code>Game-CI: Build Unity project</code> step fails, and you\u2019ll see the failure reflected in the logs. These errors often stem from issues in the Unity project itself, such as script compilation errors, asset import problems, or build configuration issues.</p>"},{"location":"docs/developers/guides/troubleshooting-build-pipeline-failures/#how-to-identify-the-errors","title":"How to Identify the Errors","text":"<p>Unity build errors can be located in the logs generated by the <code>Game-CI: Build Unity project</code> step. Here's how to locate and analyze these errors:</p> <ol> <li>Access the Build Logs:<ul> <li>Navigate to the failed job in the GitHub Actions interface.</li> <li>Click on the <code>Game-CI: Build Unity project</code> step in the job log to expand it.</li> </ul> </li> <li>Search for \"Error\":<ul> <li>Use the browser's search functionality (usually <code>Ctrl+F</code> or <code>Cmd+F</code>) to search for the word <code>Error</code> in the logs.</li> <li>Look for error messages from Unity, which often indicate the root cause of the failure.</li> <li>The most useful messages usually precede the \"Build Output\" marker in the logs:    <pre><code>###########################\n# Build output #\n###########################\n</code></pre></li> </ul> </li> <li>Common Unity Build Error Patterns:<ul> <li>Script Compilation Errors:   Example: <code>Assets/Scripts/MyScript.cs(10,20): error CS1002: ; expected</code>   These errors indicate issues in your code that must be fixed before the build can proceed.</li> <li>Missing or Corrupted Assets:   Example: <code>Failed to import package: Packages/com.unity.render-pipelines.universal/Runtime/Shaders/UniversalForwardLit.shader</code>   Ensure that all required assets are available and properly configured.</li> <li>Build Configuration Errors:   Example: <code>BuildFailedException: Player export failed. Reason: Invalid BuildTarget</code>   Check your build settings and ensure they match the expected platform.</li> </ul> </li> <li>Download Logs for Local Analysis: If the error is unclear, download the full log from the GitHub Actions    interface and analyze it locally. Look for keywords like <code>Exception</code>, <code>Failed</code>, or <code>Error</code>.</li> </ol>"},{"location":"docs/developers/guides/troubleshooting-build-pipeline-failures/#fixing-unity-build-errors","title":"Fixing Unity Build Errors","text":"<p>After identifying the issue, address it in the Unity project:</p> <ul> <li>For Script Errors:<ul> <li>Open Unity locally and resolve compilation issues.</li> </ul> </li> <li>For Asset Problems:<ul> <li>Ensure all necessary assets are imported and not corrupted.</li> <li>Reimport the asset manually if required.</li> </ul> </li> <li>For Build Configuration Issues:<ul> <li>Verify your <code>Player Settings</code>, platform-specific settings, and other configurations.</li> </ul> </li> </ul>"},{"location":"docs/developers/guides/troubleshooting-build-pipeline-failures/#github-container-registry-403-error","title":"GitHub Container Registry 403 Error","text":"<p>Symptom: The <code>Docker: Login to GitHub Container Registry</code> or <code>Docker: Build and push image</code> step fails with a <code>403 Forbidden</code> error.</p> <p>Cause: Transient authentication issues between GitHub Actions and the GitHub Container Registry.</p> <p>Solution: Restart the failed build pipeline, authentication retries often resolve the issue.</p>"},{"location":"docs/developers/guides/troubleshooting-build-pipeline-failures/#unity-license-server-concurrency-issues","title":"Unity License Server Concurrency Issues","text":"<p>Symptom: The <code>Game-CI: Build Unity project</code> step fails with errors related to Unity license activation.</p> <p>Cause: Multiple builds running simultaneously can cause Unity\u2019s license server to block one of the requests.</p> <p>Solution: Restart the failed pipeline.</p>"},{"location":"docs/developers/guides/troubleshooting-build-pipeline-failures/#disk-space-issues","title":"Disk Space Issues","text":"<p>Symptom: The pipeline fails with errors indicating insufficient disk space, often during the <code>Game-CI: Build Unity project</code> step or Docker build steps.</p> <p>Cause: Limited disk space on the runner due to temporary files or cached data.</p> <p>Solution:</p> <ul> <li>The <code>Free Disk Space (Ubuntu)</code> step in your workflow already clears space. If the issue persists:<ul> <li>Manually clean the runner by removing large or unnecessary files.</li> <li>Ensure <code>tool-cache</code> is enabled if more aggressive cleanup is needed.</li> </ul> </li> </ul>"},{"location":"docs/developers/guides/troubleshooting-build-pipeline-failures/#library-cache-issues","title":"Library Cache Issues","text":"<p>Symptom: The <code>Game-CI: Build Unity project</code> step fails due to corrupted or incompatible files in the <code>Library</code> directory.</p> <p>Cause: The cache may contain outdated or invalid files after changes to assets, packages, or project settings.</p> <p>Solution:</p> <ul> <li>Clear the cache by removing the cached <code>Library</code> directory. Update the cache key in the workflow to force a rebuild:     <pre><code>- uses: actions/cache@v2\n  with:\n    path: Library\n    key: ClearCache-${{ github.run_id }}\n</code></pre></li> </ul>"},{"location":"docs/developers/guides/troubleshooting-build-pipeline-failures/#github-pages-artifact-deployment-issues","title":"GitHub Pages Artifact Deployment Issues","text":"<p>Symptom: The <code>Github Pages: prepare artefact for deployment</code> or <code>Deploy to GitHub Pages</code> step fails.</p> <p>Cause: Issues may arise if the build artifact path is incorrect or the <code>actions/upload-pages-artifact</code> step doesn\u2019t execute properly.</p> <p>Solution:</p> <ul> <li>Verify the <code>path</code> in the <code>actions/upload-pages-artifact</code> step matches the correct build output   directory (<code>build/WebGL/WebGL</code>).</li> <li>Ensure the <code>deploy</code> job includes the correct permissions for GitHub Pages.</li> </ul>"},{"location":"docs/developers/guides/troubleshooting-build-pipeline-failures/#docker-build-and-push-issues","title":"Docker Build and Push Issues","text":"<p>Symptom: The <code>Docker: Build and push image</code> step fails with errors during the build or push process.</p> <p>Cause: Common reasons include:</p> <ul> <li>Incorrect Dockerfile paths.</li> <li>Build arguments (<code>SOURCE_PATH</code>) not resolving correctly.</li> <li>Network or authentication errors with the container registry.</li> </ul> <p>Solution:</p> <ul> <li> <p>Restart the build first to see if it is a temporary issue - otherwise proceed with the following steps</p> </li> <li> <p>Confirm the <code>context</code> and <code>file</code> paths in the Docker build step.</p> </li> <li>Verify that <code>build-args</code> matches the correct path to your Unity WebGL build output (<code>build/WebGL/WebGL</code>).</li> <li>Check Docker authentication using the <code>docker/login-action</code>.</li> </ul>"},{"location":"docs/developers/guides/troubleshooting-build-pipeline-failures/#general-best-practices","title":"General Best Practices","text":"<ol> <li>Monitor Logs:    Each step in your pipeline produces logs. Check these logs for detailed error messages and trace the failure to the    specific step.</li> <li>Retry Builds:    Issues such as transient authentication failures or license conflicts are often resolved by restarting the pipeline.</li> <li>Version Control:    Pin versions of Game-CI tools and Unity to avoid unexpected failures due to updates:     <pre><code>unityVersion: 2022.3.8f1\ncustomImage: unityci/editor:ubuntu-2022.3.8f1-webgl-2\n</code></pre></li> <li>Test Locally:    Run builds locally to catch issues before pushing changes to GitHub. Use Docker to test Game-CI locally:     <pre><code>docker run --rm -it -v \"$(pwd):/project\" unityci/editor:ubuntu-2022.3.8f1-webgl-2\n</code></pre></li> <li>Regular Maintenance:    Periodically update secrets, clean runners, and verify your project dependencies to maintain pipeline reliability.</li> </ol>"},{"location":"docs/developers/packages/creating-and-managing/","title":"Creating and managing Packages","text":"<p>Netherlands3D is a framework where you, as developer, can pick the functionality that you need from a series of  packages. This guide will empower you to develop your own packages by providing step-by-step instructions how you can create your own package, release it and last, but not least, publish it to OpenUPM.</p>"},{"location":"docs/developers/packages/creating-and-managing/#variables-placeholders","title":"Variables / Placeholders","text":"<p>Before we get started, let's define some terms as if they were variables. This documentation and the template files  in the Gist mentioned in the chapter Creating a new package uses various placeholders. These  can recognized as they are between brackets, for example <code>{NAME}</code>. </p> <p>This table provides an overview of them and their meaning.</p> Name Explanation Example NAME The name of the code repository, this is usually the DISPLAY_NAME in PascalCase. It is recommended to limit the name to two words, if more words add clarity than that takes precedence. PeriodicSnapshots PACKAGE_NAME The package name as known in the package manager and/or package.json; always starts with <code>eu.netherlands3d.</code> and followed by the display name -or similar- in kebab-case eu.netherlands3d.periodic-snapshots DISPLAY_NAME The human-readable name of a package, shown in the README or in the Package Manager Periodic Snapshots REPOSITORY_NAME Alias of NAME, used to make explicit that we want the repository name there. PeriodicSnapshots VERSION The version number in the package.json, according to SemVer. Important: contrary to the git tag, this does not start with a letter <code>v</code> 1.0.1 DESCRIPTION A single-line short description describing the package, can also be used on Github as the description for the repository This package provides the means to do take a series of snapshots for specific moments throughout the year. LONG_DESCRIPTION The description of the package detailing what it is used for. USAGE_INFORMATION Documentation how to use this package. See existing packages for examples NOTE One or more entries in the CHANGELOG -according to Keep A Changelog- describing what has been added, changed, removed or deprecated in a package <p>This vocabulary and their definitions will help to have a consistent experience when working with packages.</p>"},{"location":"docs/developers/packages/creating-and-managing/#creating-a-new-package","title":"Creating a new package","text":"<p>When creating a new package, it is recommended to first create it as an embedded package in the  Netherlands3D twin project. This will help to prototype and experiment until  the point where it is stable enough to be distributed.</p> <p>This can be done using the following steps:</p> <ol> <li> <p>Clone the Netherlands3D Twin project, located at https://github.com/Netherlands3D/twin.</p> </li> <li> <p>Make sure Unity is not open while performing the following steps; it generally tends to crash when it updates while setting up a package.</p> </li> <li> <p>Create a directory for your embedded package in the     <code>Packages</code> folder.</p> <p>Important</p> <p>The directory name MUST follow the structure <code>eu.netherlands3d.[name]</code> where <code>name</code> is in lower-case kebab-case.</p> </li> <li> <p>Copy the template files, located at https://gist.github.com/mvriel/8a8251b492d9d8f742da16667c49e412, and fill in the placeholders.</p> </li> <li> <p>Set up the package according to the following recommended directory structure: https://docs.unity3d.com/Manual/cus-layout.html</p> </li> <li> <p>Start Unity and allow for it to install the new package, you should see your new package in the \"Installed Packages\" section of the Package Manager with the tag <code>Custom</code> behind the name.</p> </li> <li> <p>When you want to add Scripts to this package: Make sure you have created the folder <code>Runtime\\Scripts</code> as a location to store them and add an Assembly Definition with the name <code>{PACKAGE_NAME}.Runtime</code>. </p> </li> </ol>"},{"location":"docs/developers/packages/creating-and-managing/#promoting-an-embedded-package","title":"Promoting an embedded package","text":"<p>It takes time and effort to get a package into a usable and moderately stable condition. Because of this the recommended way of working is to first create an embedded package in the Twin project -like an incubator project- and once it is  moderately stable: promote it to its own repository.</p> <p>Promoting an embedded package is done by one of the project maintainers -if not alone for the fact that a repository  needs to be made- and follows the following sequence of steps:</p> <ol> <li> <p>Create a repository whose name matches the <code>{NAME}</code> placeholder, thus a PascalCase representation of the     human-readable name.</p> </li> <li> <p>Move all files from the <code>Packages\\{PACKAGE_NAME}</code> folder in the Twin repository to the newly made repository's root     folder</p> </li> <li> <p>Check and adjust, at least, the URL's for the LICENSE, README and CHANGELOG in the <code>package.json</code>.</p> </li> <li> <p>Release and publish the promoted package, see the chapters on releasing and     publishing for the involved steps.</p> </li> <li> <p>In the Twin project, add a reference to <code>{PACKAGE_NAME}</code> to the package.json or install the package through    the package manager.</p> <p>Important</p> <p>After a package is added to OpenUPM for the first time, it can take between 30 and 60 minutes for it to  show up in the package listing.</p> </li> </ol> <p>Once a package is promoted, you can no longer edit it as part of the Twin project; in the next chapter  Changing a Package it is described how you can change a promoted package without all too much  hassle.</p>"},{"location":"docs/developers/packages/creating-and-managing/#changing-a-package","title":"Changing a package","text":"<p>To be written</p>"},{"location":"docs/developers/packages/creating-and-managing/#releasing-a-package","title":"Releasing a package","text":"<p>When you want to release a new version of a package you generally go through the following steps:</p> <p>Tip</p> <p>Before releasing, make sure you have tested your package in the Twin -or  another Netherlands3D-based project- installed as a local package.</p> <p>Especially important is:</p> <ul> <li>verifying that the correct dependencies are set and installed</li> <li>that the Assembly Definition can be used and</li> <li>that the Assembly Definition does not depend on Assembly Definitions that are not a dependency of your package,   especially Netherlands3D.Core.Runtime should be avoided</li> </ul> <p>Failure to do so may cause extra work because once a package is released, it is impossible to change something in the release and a new release must be made.</p> <ol> <li> <p>Go to the repository of your package. If there is none: see the chapter on     Promoting an embedded package and do that first.</p> </li> <li> <p>Ensure the version number in the package.json is updated</p> </li> <li> <p>Check the CHANGELOG.md: </p> </li> <li> <p>Does it contain all changes since the last version?</p> </li> <li> <p>Is the top-entry <code>[Unreleased]</code>? Fill in the new version number and add a date, see: https://keepachangelog.com/en/1.0.0/#effort</p> </li> <li> <p>Ensure any changes in the above are in the main branch</p> </li> <li> <p>Go to \"Releases\" on Github (<code>https://github.com/Netherlands3D/{NAME}/releases</code>) and</p> </li> <li> <p>Draft a new release       </p> </li> <li>Click on \"Choose a tag\"</li> <li>Enter the version number from the package.json with a preceding letter <code>v</code>, for example: <code>v1.0.1</code>.</li> <li>Click on the option \"Create new tag: <code>v{VERSION}</code> on publish\"</li> <li>(optional) Add a release title and description</li> <li>Click on the button \"Publish Release\"</li> </ol> <p>Once a new release/tag has been made, your new release of your package is all set! If it has already been  published on OpenUPM before, no further action is needed. OpenUPM will automatically pick up on the new tag and make the new version available.</p> <p>When the package has not been published on OpenUPM yet, now is a good time to do it.</p>"},{"location":"docs/developers/packages/creating-and-managing/#publishing-a-package-on-openupm","title":"Publishing a package on OpenUPM","text":"<p>When a package is released for the first time, it needs to be published by registering it on OpenUPM.</p> <p>Tip</p> <p>Before publishing, make sure you have tested your package in https://github.com/Netherlands3D/twin -or another Netherlands3D-based project- installed as a local package.</p> <p>Especially important is:</p> <ul> <li>verifying that the correct dependencies are set and installed</li> <li>that the Assembly Definition can be used and </li> <li>that the Assembly Definition does not depend on Assembly Definitions that are not a dependency of your package,   especially Netherlands3D.Core.Runtime should be avoided</li> </ul> <p>Failure to do so may cause extra work because once a package is published, it is inconvenient to unpublish it or  change publication details such as the name.</p> <p>To do so, you can take the following steps:</p> <ol> <li> <p>Go to https://openupm.com.</p> </li> <li> <p>Click on the \"+\" button in the menu bar to add a new package    </p> </li> <li> <p>Fill out the Github repository name in the intended field and click on \"Go\".        A form expands where you can verify the package name, ReadMe location and more</p> </li> <li> <p>Enter your github username in the \"Discovered by\" field; this is used to base a fork of OpenUPM from and add the     package as a pull request.</p> <p></p> <p>Note</p> <p>The section \"Advanced\" is for advanced use when multiple packages are hosted in the same repository; at the moment this method is not recommended and as such that part of the submission form can be skipped</p> </li> <li> <p>Check the \"Promotion\" section if the package fits any of these categories, and check these.</p> </li> <li> <p>Click on the \"Verify Package\" button, all other fields can be left unchanged.</p> </li> </ol> <p>As soon as the steps above have completed, you are asked to fork the <code>OpenUPM</code> repository and to commit these changes in a feature branch. At this point you can use the \"Create pull request\" button to create a pull request to OpenUPM.</p> <p>Tip</p> <p>If this is your first time submitting a package to OpenUPM, the maintainer of OpenUPM needs to approve the Pull  Request manually; this is generally done within 24 hours. Any subsequent pull requests will be automatically merged.</p> <p>After the pull request is merged, it will take 30 to 60 minutes for <code>OpenUPM</code> to add the package to the registry.</p>"},{"location":"docs/developers/packages/creating-and-managing/#faq","title":"FAQ","text":"<p>Can I depend on the <code>Netherlands3D.Core.Runtime</code> assembly?</p> <p>At time of writing, this assembly is within the code of the https://github.com/Amsterdam/Netherlands3D skeleton; meaning that this dependency only works when the package is used within a project that is based on this skeleton. This can be a problematic dependency since we are actively working on moving the contents of this skeleton into components.</p> <p>Because of the above, it is not recommended for a published package to depend on the <code>Netherlands3D.Core.Runtime</code> assembly.</p> <p>If code from this assembly is needed, it is recommended to extract this code into another package that you can depend  on or duplicate it into your own package until such a package can be made.</p> <p>For more information on this, see the question <code>Can I depend on Assemblies that are not in my own package?</code>.</p> <p>Can I depend on Assemblies that are not in my own package?</p> <p>You sure can! As long as these assemblies are in a package that is published in a Unity Package Registry such as  OpenUPM, and that you have added that package as a dependency to your <code>package.json</code> file.</p> <p>If you add an assembly whose package cannot be included in your <code>package.json</code> -either because it is not a package or a git-based package- then you will need to add installation instructions in the README. Without these instructions, any user of the package will have a missing assembly -and thus errors- without knowing how to fix it.</p> <p>One of the packages does not show up in the Package Manager after publishing</p> <p>Have you checked the minimum unity version in the <code>package.json</code>? If the minimum version is newer than your installed version, it will not be visible.</p> <p>Why OpenUPM and not add packages through a Git URL?</p> <p>Good question! When you add packages through a Git URL you lose certain features that packages hosted on a registry do have. This includes but is not limited to:</p> <ol> <li> <p>Unable to update to a new version: when you use a Git tag/release, then you need to uninstall and reinstall the     package when a new becomes available instead of just using the <code>Update</code> button.</p> </li> <li> <p>Git-url based packages cannot be used as dependencies: this means that if a package depends on another, with git     urls you need to manually install the correct dependencies and face possible version conflicts with newer versions.</p> </li> </ol>"},{"location":"docs/developers/testing/3d-models/","title":"Testing 3D Model Formats","text":""},{"location":"docs/developers/testing/3d-models/#introduction","title":"Introduction","text":"<p>This document provides guidance on testing 3D model formats supported by our system. It includes a list of available test models and a matrix of their properties, enabling systematic evaluation of compatibility, rendering behavior, and feature support.</p>"},{"location":"docs/developers/testing/3d-models/#scope-of-this-document","title":"Scope of This Document","text":"<p>This document focuses on testing the fundamental functionalities of 3D model loading, such as format compatibility, texture support, coordinate system alignment, and performance considerations. Additional features, including animation, material properties, and advanced optimizations, will be considered in later versions of the application. This document will be updated accordingly as new formats and capabilities are introduced.</p>"},{"location":"docs/developers/testing/3d-models/#test-models","title":"Test Models","text":"<p>Below is a list of example 3D models that can be used for testing. Each entry includes a download link and relevant metadata.</p> <p>Please note</p> <p>This is not an exhaustive list. It is recommended to test with as many variations as possible. If a new model highlights a different compatibility issue, please update this list accordingly.</p> Model Name Format Download Link Textures Materials Animation Coordinate System File Size OBJ with 4 colored materials .obj Download / Project \u274c \u2705 \u274c Local XX MB Rietveldhuis (Utrecht) .obj Download \u274c \u2705 \u274c EPSG:28992 (RD) XX MB <p>This table serves as a reference for understanding which formats support different properties, allowing focused testing and troubleshooting.</p> <p>* While compiling this list, some properties might not yet be tested. Please provide a pull request with missing information when encountered.</p>"},{"location":"docs/developers/testing/3d-models/#testing-methodology","title":"Testing Methodology","text":"<ol> <li> <p>Format Validation:</p> <ul> <li>Ensure the file format is correctly recognized and loaded.</li> <li>Check for potential parsing errors when opening the file.</li> </ul> </li> <li> <p>Texture &amp; Material Testing:</p> <ul> <li>(Upcoming) Verify that textures are correctly applied and rendered.</li> <li>Confirm that material properties (e.g., roughness, metallic) are correctly interpreted.</li> </ul> </li> <li> <p>Coordinate System &amp; Alignment:</p> <ul> <li>Ensure that the model loads in the correct orientation.</li> <li>Verify whether georeferenced models are loaded in the correct location</li> </ul> </li> <li> <p>Performance Testing:</p> <ul> <li>Load models with different complexities and file sizes to observe performance.</li> <li>Identify any models that cause excessive rendering lag or memory usage.</li> </ul> </li> </ol>"},{"location":"docs/developers/testing/3d-models/#future-format-support","title":"Future Format Support","text":"<p>We currently support <code>.obj</code> files and plan to add support for additional formats, such as <code>.gltf</code>. As new formats are introduced, this document will be updated with relevant testing procedures and additional test models.</p> <p>Should you encounter issues with a specific model, please document it and submit a report to improve format compatibility.</p>"},{"location":"docs/developers/testing/ogc-webservices/","title":"Testing OGC Web Services","text":""},{"location":"docs/developers/testing/ogc-webservices/#introduction","title":"Introduction","text":"<p>This document provides guidance on testing Open Geospatial Consortium (OGC) Web Map Services (WMS) and Web Feature Services (WFS). It includes a list of available test services and a matrix of their properties, enabling systematic evaluation against different capabilities and constraints.</p>"},{"location":"docs/developers/testing/ogc-webservices/#scope-of-this-document","title":"Scope of This Document","text":"<p>This document focuses on testing the fundamental functionalities of OGC Web Services, such as service availability, supported coordinate reference systems, bounding box capabilities, and format support. Advanced functionalities, including attribute and spatial filtering, will be considered in later versions of the application. This document will be updated accordingly to reflect new testing procedures when such features are introduced.</p>"},{"location":"docs/developers/testing/ogc-webservices/#test-endpoints","title":"Test Endpoints","text":"<p>Below is a list of example WMS and WFS services that can be used for testing. Each service should include its endpoint and relevant metadata -do not forget to scroll sideways to see all information. </p> <p>Please note</p> <p>This is not an exhaustive list, it is recommended to test with as many variations possible. Should a new variant be  found that has a different profile from these, please update this list to include it.</p> Endpoint Service Type Version Default CRS Multiple CRS Support BBOX Support Layer/Feature Count Supported Formats Supports parameterless invocation https://service.pdok.nl/cbs/vierkantstatistieken500m/2022/wfs/v1_0?request=GetCapabilities&amp;service=WFS WFS X.X.X EPSG:XXXX \u2705/\u274c \u2705/\u274c XX X \u2705/\u274c https://service.pdok.nl/cbs/vierkantstatistieken500m/2022/wms/v1_0?request=GetCapabilities&amp;service=WMS WMS X.X.X EPSG:XXXX \u2705/\u274c \u2705/\u274c XX X \u2705/\u274c https://service.pdok.nl/cbs/gebiedsindelingen/2024/wfs/v1_0?request=GetCapabilities&amp;service=WFS WFS X.X.X EPSG:XXXX \u2705/\u274c \u2705/\u274c XX X \u2705/\u274c https://service.pdok.nl/prorail/spoorwegen/wfs/v1_0?service=wfs&amp;request=GetCapabilities https://service.pdok.nl/rioned/beheerstedelijkwater/wfs/v1_0?request=GetCapabilities&amp;service=wfs https://service.pdok.nl/rws/digitaaltopografischbestand/wms/v1_0?request=GetCapabilities&amp;service=WMS https://service.pdok.nl/rws/digitaaltopografischbestand/wfs/v1_0?request=GetCapabilities&amp;service=WFS https://geo.rijkswaterstaat.nl/services/ogc/gdr/bps_kaart/ows?service=WMS&amp;request=getcapabilities&amp;version=1.3.0 https://service.pdok.nl/rvo/natura2000/wfs/v1_0?request=getcapabilities&amp;service=wfs https://service.pdok.nl/rws/ahn/wms/v1_0?request=GetCapabilities&amp;service=WMS https://service.pdok.nl/kadaster/plu/wms/v1_0?request=Getcapabilities&amp;service=WMS&amp;version=1.3.0 https://apps.geodan.nl/public/data/org/gws/YWFMLMWERURF/kea_public/wms?&amp;SERVICE=wms&amp;REQUEST=Getcapabilities https://service.pdok.nl/kadaster/kadastralekaart/wms/v5_0?&amp;service=WMS&amp;Request=GETCapabilities&amp;version=1.3.0 https://service.pdok.nl/hwh/luchtfotorgb/wms/v1_0?request=GetCapabilities&amp;service=wms https://nens.lizard.net/wms/raster_f284fcd9-84ef-4b5a-ad32-d20f6f8978c5/?SERVICE=WMS&amp;REQUEST=Getcapabilities <p>This table serves as a reference for understanding which services support different properties, allowing focused testing and troubleshooting.</p> <p>* While compiling this list, it is possible not all properties are available yet. Please provide a pull request with the missing information when encountering this.</p>"},{"location":"docs/developers/testing/ogc-webservices/#testing-methodology","title":"Testing Methodology","text":"<ol> <li>Service Validation:<ul> <li>Verify that the service responds when accessed directly at its base URL (without <code>service</code> and <code>request</code>   parameters) if the service supports parameterless invocation (see chapter below).</li> <li>Check whether the service responds correctly when providing <code>service=WMS/WFS</code> and <code>request=GetCapabilities</code>   parameters.</li> <li>Validate that individual layers or feature types can be requested using <code>GetMap</code> (for WMS) or <code>GetFeature</code> (for   WFS) and their supporting parameters.</li> </ul> </li> <li>CRS &amp; BBOX Testing:<ul> <li>Request maps or features in different CRSs and bounding boxes to confirm proper handling.</li> </ul> </li> <li>Format Compatibility:<ul> <li>Ensure that the expected image (PNG) and feature formats (GeoJSON) is used if multiple formats are supported.</li> </ul> </li> <li>Feature &amp; Layer Access:<ul> <li>Check layer listings (WMS) and feature queries (WFS) to confirm all advertised data is retrievable.</li> </ul> </li> <li>Performance Testing:<ul> <li>Note high response times while testing to provide guidance when doing performance reviews.</li> </ul> </li> </ol>"},{"location":"docs/developers/testing/ogc-webservices/#parameterless-invocation","title":"Parameterless Invocation","text":"<p>Some GIS endpoints support parameterless invocation, where calling the service using only its base URL (without explicitly providing <code>service</code> and <code>request</code> parameters) automatically returns the GetCapabilities response. While this is not part of the OGC standard, it is a commonly observed behavior in the field.</p> <p>This feature is often referenced in documentation and examples, making it necessary to support and test for. Services that implement parameterless invocation simplify client implementation but also introduce inconsistencies in behavior across different services. When testing, it is recommended to verify whether a service responds correctly when invoked without parameters and compare the results against an explicit <code>GetCapabilities</code> request.</p>"},{"location":"docs/developers/tilekit/","title":"Tilekit","text":""},{"location":"docs/developers/tilekit/#visie","title":"Visie","text":"<p>Tilekit is een raamwerk om geospatiale datasets te visualiseren, inclusief de mogelijkheid om deze data te bevragen.</p>"},{"location":"docs/developers/tilekit/#synopsis","title":"Synopsis","text":"<p>Een geospatiale dataset is een dataset die getegeld aangeboden wordt -zoals 3D Tiles, Webmapper en WMTS-, of een verzameling van geospatiale features -zoals WFS, OGC API Features of GeoJSON-. Tilekit is ontworpen om deze datasets op een getegelde manier te visualiseren.</p> <p>Dit betekent dat Tilekit uit twee aparte maar nauw verbonden delen bestaat:</p> <ul> <li>Het opbouwen en bevragen van een of meer verzamelingen van features</li> <li>Het efficient opdelen van de geospatiale wereld in een verzameling van tegels die features visualiseren</li> </ul> <p>Afhankelijk van de databron kan de volgorde van de processen vari\u00ebren, wat leidt tot een soort kip-of-ei-probleem. Systemen die van nature tegel-geori\u00ebnteerd zijn \u2013 zoals WMTS of 3D Tiles \u2013 zullen doorgaans eerst tegels genereren en tegelijkertijd bepalen welke features aanwezig zijn in die tegels. Het is echter ook mogelijk om te starten met een verzameling features, waarna een deel ervan wordt geselecteerd om bijbehorende tegels van te maken, zoals het geval is bij GeoJSON-bestanden of WFS.</p> <p>Tip</p> <p>Hoewel je genegen zou zijn om bij raster of 3D Data gebaseerde datasets aan te nemen dat er geen features zijn, is  het praktisch om de verbeelding -raster of mesh data- van een tegel als \u00e9\u00e9n feature te beschouwen.</p>"},{"location":"docs/developers/tilekit/#doelen","title":"Doelen","text":"<p>Tilekit heeft ten doel om een raamwerk te bieden voor het visualiseren van alle geospatiale content, deze flexibiliteit vereist een ontwerp waar bij de volgende doelen gesteld zijn:</p> <ul> <li>Raamwerk om, getegeld, geospatiale data in te laden en visualiseren.</li> <li>Makkelijk om onderdelen te vervangen zonder het hele systeem aan te hoeven te passen,    zie Pluggable Architectuur.</li> <li>Asynchroon-first middels Promises</li> <li>Ondersteunt publieke en afgeschermde bronnen middels authenticatie.</li> <li>Live linken (remote datasets) of importeren (lokale datasets) van data moet mogelijk zijn </li> </ul>"},{"location":"docs/developers/tilekit/#filosofie","title":"Filosofie","text":"<p>Tilekit is gebouwd rondom het principe dat als een legoset een tegelsysteem in elkaar kan worden geprikt. Daarbij kunnen onderdelen vervangen worden als voortschrijdend inzicht dat vereist, of juist toegevoegd als er nieuwe databronnen geimplementeerd worden.</p>"},{"location":"docs/developers/tilekit/#duik-dieper-in-de-materie","title":"Duik dieper in de materie","text":"<ul> <li>Pluggable Architectuur</li> <li>Tegelsysteem</li> <li>Features</li> <li>Metadata</li> <li>Ophalen van data</li> <li>Geheugen en performance</li> <li>Appendix A. Casussen</li> <li>Appendix B. Bronvermeldingen</li> <li>Appendix C. Begrippen</li> </ul>"},{"location":"docs/developers/tilekit/#notities-en-todo-tbv-uitwerking","title":"Notities en TODO tbv uitwerking","text":"<ul> <li>Postprocessing van tegels verder toelichten, mogelijk met clipping en masking als voorbeeld</li> <li>Herzien of laden vanaf zichtpunt wel een goede beslissing is</li> <li>Laadvolgorde tegels beter beschrijven</li> <li>Beter beschrijven hoe het tegelsysteem een tussenlaag is en dat het 'werk' door monobehaviours gebeurd</li> <li>Beschrijving hoe hoogte wisselingen te kunnen doen (FAQ?)</li> <li>CRS is nog niet benoemd; dat stuk moet ook nog</li> </ul>"},{"location":"docs/developers/tilekit/appendix-a-casussen/","title":"Appendix a casussen","text":""},{"location":"docs/developers/tilekit/appendix-a-casussen/#appendix-a-casussen","title":"Appendix A. Casussen","text":""},{"location":"docs/developers/tilekit/appendix-a-casussen/#a1-wms","title":"A.1. WMS","text":""},{"location":"docs/developers/tilekit/appendix-a-casussen/#a11-doel","title":"A.1.1. Doel","text":"<p>De casus van het herimplementeren van WMS in het nieuwe tegelsysteem is bedoeld om te demonstreren hoe een vertegeling op basis van HLOD kan helpen om nabij de camera gedetailleerde tegels te tonen, en verder weg steeds grotere onnauwkeurige tegels.</p>"},{"location":"docs/developers/tilekit/appendix-a-casussen/#a12-demonstreert","title":"A.1.2. Demonstreert","text":"<ul> <li>Inladen Capaciteiten en omzetten naar TileSet definitie</li> <li>Impliciete vertegeling van een ongetegelde bron</li> <li>Inladen van een externe databron</li> <li>Verbeelden van remote tegels met afbeeldingen</li> <li>Dynamische aanpassing tegelgrootte en resolutie afhankelijk van afstand camera</li> </ul>"},{"location":"docs/developers/tilekit/appendix-a-casussen/#a13-requirements","title":"A.1.3. Requirements","text":"<ul> <li>Middels de Tileset definitie van dit systeem moet<ul> <li>binnen de bounding box van een WMS laag een tegelset getoond worden</li> <li>een implicit quadtree gebaseerde vertegeling gedefinieerd kunnen worden</li> <li>Meerdere sublevels mogelijk zijn om kleinere en grotere tegels te tonen afhankelijk van de afstand tot het </li> <li>zichtpunt.</li> <li>TBC</li> </ul> </li> </ul>"},{"location":"docs/developers/tilekit/appendix-a-casussen/#a2-geojson","title":"A.2. GeoJSON","text":""},{"location":"docs/developers/tilekit/appendix-a-casussen/#a21-doel","title":"A.2.1. Doel","text":""},{"location":"docs/developers/tilekit/appendix-a-casussen/#a22-demonstreert","title":"A.2.2. Demonstreert","text":"<ul> <li>Impliciete vertegeling van een ongetegelde bron</li> <li>Inladen van een lokale databron</li> <li>Inladen van een externe databron</li> </ul>"},{"location":"docs/developers/tilekit/appendix-a-casussen/#a23-requirements","title":"A.2.3. Requirements","text":""},{"location":"docs/developers/tilekit/appendix-b-bronvermeldingen/","title":"Appendix b bronvermeldingen","text":""},{"location":"docs/developers/tilekit/appendix-b-bronvermeldingen/#appendix-b-bronvermeldingen","title":"Appendix B. Bronvermeldingen","text":""},{"location":"docs/developers/tilekit/appendix-b-bronvermeldingen/#b1-bronnen","title":"B.1. Bronnen","text":"<ul> <li>OGC 3D Tiles<ul> <li>3D Tiles - Implicit tiling in detail</li> </ul> </li> <li>OGC API - Tiles</li> <li>OGC API - Features<ul> <li>Specificatie</li> </ul> </li> <li>https://www.w3.org/TR/sdw-bp/#bib-iso-19101-1-2014</li> <li>OGC CQL</li> <li>Use ScriptableObjects as delegate objects</li> <li>Refactoring Guru - Strategy Design Pattern</li> </ul>"},{"location":"docs/developers/tilekit/appendix-b-bronvermeldingen/#b2-videos","title":"B.2. Videos","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/","title":"Appendix c begrippen","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#appendix-c-begrippen","title":"Appendix C. Begrippen","text":"<p>// TODO: https://github.com/CesiumGS/3d-tiles/blob/main/specification/README.adoc uitkammen en de begrippen hierin zetten, zoals refinement</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#bounding-volume","title":"Bounding Volume","text":"<p>Aliassen: Begrenzingsvolume.</p> <p>Een begrenzingsvolume is een geometrisch volume dat wordt gebruikt om de ruimtelijke omvang van een object of een verzameling objecten te beschrijven. Het wordt vaak gebruikt voor optimalisaties zoals zichtbaarheid, selectie en hi\u00ebrarchische structuren (zoals tile trees).</p> <p>Er zijn drie standaardtypen begrenzingsvolumes:</p> <ul> <li> <p>Box (doosvormig volume): een rechthoekige doos in 3D-ruimte (axis-aligned of geori\u00ebnteerd).</p> </li> <li> <p>Sphere (bolvormig volume): een bol met een middelpunt en straal.</p> </li> <li> <p>Region (regiovormig volume): een complexere beschrijving die een geogra\ufb01sch gebied aanduidt, vaak gedefinieerd door    een rechthoekige uitsnede in lengte- en breedtegraden, met een minimale en maximale hoogte (bijvoorbeeld voor gebruik    op een globe).</p> </li> </ul> <p>Begrenzingsvolumes worden voornamelijk gebruikt om snel te kunnen bepalen of een object zichtbaar is of moet worden ingeladen, zonder alle details van het object zelf te hoeven analyseren.</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#capabilities","title":"Capabilities","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#change","title":"Change","text":"<p>Een Change is een handeling die nodig is om een tegel van begin tot einde - inclusief visualisatie - toe te voegen of te verwijderen uit de wereld.</p> <p>Changes kunnen geannuleerd worden, in welk geval de Status Quo behouden blijft.</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#changeset","title":"Changeset","text":"<p>Een Changeset is een set aan Changes die als 1 geheel uitgevoerd moeten worden - als een ChangeSet geannuleerd wordt, dan wordt de status quo behouden.</p> <p>Toevoegen altijd voor verwijderen, zodra verwijderen loopt mag niet meer geannuleerd</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#databron","title":"Databron","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#design-pattern-builder","title":"Design Pattern: Builder","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#design-pattern-factory","title":"Design Pattern: Factory","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#design-pattern-strategy","title":"Design Pattern: Strategy","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#digitaal-terrein-model-dtm","title":"Digitaal Terrein Model (DTM)","text":"<p>Aliassen: Maaiveld, Grondoppervlak, Digital Terrain Model</p> <p>Een Digitaal Terrein Model (DTM) is een digitale representatie van het aardoppervlak, inclusief de natuurlijke terreinvormen, exclusief bovengrondse objecten zoals gebouwen en vegetatie. Het model bestaat uit een reeks gegevenspunten die hoogte-informatie bevatten, waardoor een driedimensionaal beeld van het terrein kan worden gecre\u00eberd.</p> <p></p> <p>Meer informatie:</p> <ul> <li>https://www.eea.europa.eu/help/glossary/eea-glossary/digital-terrain-model</li> <li>https://nl.wikipedia.org/wiki/Digitaal_hoogtemodel</li> </ul>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#digitaal-oppervlakte-model-dsm","title":"Digitaal Oppervlakte Model (DSM)","text":"<p>Aliassen: Digitaal Hoogtemodel, Digital Surface Model</p> <p>Omvat het Digitaal Terrein Model (DTM) plus alle bovengrondse objecten op het  aardoppervlak zoals gebouwen en vegetatie. Het model bestaat uit een reeks gegevenspunten die hoogte-informatie  bevatten, waardoor een driedimensionaal beeld van het terrein kan worden gecre\u00eberd.</p> <p></p> <p>Meer informatie:</p> <ul> <li>https://www.eea.europa.eu/help/glossary/eea-glossary/digital-terrain-model</li> <li>https://nl.wikipedia.org/wiki/Digitaal_hoogtemodel</li> </ul>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#geoide","title":"Geoide","text":"<p>Aliassen: NAP (soort van)</p> <p>De geo\u00efde is het oppervlak op gemiddeld zeeniveau, waar dezelfde zwaartekrachtspotentiaal( inclusief de potentiaal van de middelpuntvliedende kracht door de draaiing van de Aarde) heerst: hetequipotentiaalvlak. Zonder getijden, wind en verschillen in watertemperatuur en zoutgehalte zou het waterniveau in zee dit oppervlak volgen.</p> <p>Geo\u00efdehoogten zijn de hoogten tussen de geo\u00efde en een referentie-ellipso\u00efdevan eengeodetisch co\u00f6rdinatensysteem, bijvoorbeeldWGS84,ETRS89.</p> <p>Meer informatie:</p> <ul> <li>https://nl.wikipedia.org/wiki/Geo%C3%AFde</li> </ul>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#geometric-error","title":"Geometric Error","text":"<p>De geometricError is een maat (in meters) die zegt hoe \"grof\" een tegel is in vergelijking met zijn fijnere kinderen. Het komt neer op: hoeveel detail je mist als je deze tegel toont in plaats van zijn onderliggende (meer gedetailleerde) tegels.</p> <p>Tijdens het draaien van de app gebruiken we deze geometricError om te bepalen of een tegel voldoende detail geeft op het scherm. Dat doen we door het om te rekenen naar screen space error (SSE) \u2013 dat is de fout uitgedrukt in pixels op je scherm.</p> <p>Bijvoorbeeld:</p> <ul> <li>Stel: een tegel heeft een geometricError van 50 meter.</li> <li>Als die 50 meter visueel overeenkomt met 10 pixels op het scherm, dan is de SSE = 10.</li> <li>Als je een maximum SSE van bijvoorbeeld 8 pixels hanteert, dan weet je: deze tegel moet worden vervangen door zijn   kinderen, want hij is niet precies genoeg.</li> </ul> <p>Waarom dit belangrijk is? Dit helpt het systeem beslissen wanneer het moet inzoomen naar meer detail (kindtegels laden), of wanneer een grove weergave prima is (ouders tonen).</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#hlod","title":"HLOD","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#getegelde-laag","title":"Getegelde laag","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#lagensysteem","title":"Lagensysteem","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#layerdata","title":"LayerData","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#idempotent","title":"Idempotent","text":"<p>Idempotentie is de eigenschap van een object (of systeem) en/of een operatie daarop dat het object niet meer verandert als de operatie nogmaals wordt uitgevoerd.</p> <p>Bron: https://nl.wikipedia.org/wiki/Idempotentie</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#mapping","title":"Mapping","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#midden-van-het-scherm","title":"Midden van het Scherm","text":"<p>Het midden van het scherm betekent concreet het punt in de viewport waar de camera naar kijkt, op de hoogte van het digitale terreinmodel (DTM), en als er geen digitaal terrein model aanwezig voor de gegeven lokatie: de hoogte van de [[#Geoide]].</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#nap-hoogte","title":"NAP hoogte","text":"<p>Zie: [[Orthometrische hoogte]]</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#orthometrische-hoogte","title":"Orthometrische hoogte","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#pluggable-architectuur","title":"Pluggable Architectuur","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#screen-space-error-sse","title":"Screen Space Error (SSE)","text":"<p>De screen space error is een maat voor hoe zichtbaar een geometrische afwijking is op het scherm, uitgedrukt in pixels. Het wordt gebruikt om te bepalen of een object (zoals een tegel in een hi\u00ebrarchie) voldoende detail heeft op basis van de afstand tot de camera. Een hogere SSE betekent dat het detailverlies zichtbaar is voor de gebruiker, wat aangeeft dat een meer gedetailleerde versie (bijvoorbeeld kindtegels) ingeladen moet worden.</p> <p>De berekening is gebaseerd op de <code>geometricError</code> (een waarde in meters die de detailafwijking beschrijft) en de afstand tot de camera. De standaardformule is:</p> <pre><code>SSE = (geometricError / distanceToCamera) * schermProjectieFactor\n</code></pre> <p>Waarbij:</p> <ul> <li><code>geometricError</code> de maximale fout in wereldco\u00f6rdinaten is (bijvoorbeeld 50 meter),</li> <li><code>distanceToCamera</code> de afstand tot de camera is in meters,</li> <li><code>schermProjectieFactor</code> een constante factor is die afhangt van het schermformaat en de field of view.</li> </ul> <p>schermProjectieFactor is 1</p> <p>In onze situatie is <code>schermProjectieFactor</code> gelijk aan 1, dus de formule wordt vereenvoudigd tot:</p> <pre><code>SSE = geometricError / distanceToCamera\n</code></pre> <p>De keuze voor deze constante is omwille van performance en omdat een dergelijke mate van accuraatheid niet nodig is. </p> <p>Deze waarde wordt vergeleken met een ingestelde grenswaarde (<code>maximumScreenSpaceError</code>). Als de SSE groter is dan deze grens, moet een meer gedetailleerde versie worden geladen.</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#spatial-coherence","title":"Spatial Coherence","text":"<p>De gezamenlijke inhoud van alle kindtegels valt volledig binnen het begrenzingsvolume van de oudertegel.</p> <p>Dat betekent niet dat het hele begrenzingsvolume (zie Bounding Volume) van de oudertegel opgevuld  moet zijn, maar wel dat de kindtegels niet buiten de grenzen van hun ouder mogen uitsteken.</p> <p>Kindtegels mogen elkaar onderling wel overlappen, zoals te zien is in deze afbeelding:</p> <p></p> <p>Zie https://portal.ogc.org/files/102132#core-bounding-volume-spatial-coherence voor meer informatie.</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#staging","title":"Staging","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#tick","title":"Tick","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#tile","title":"Tile","text":"<p>Aliassen: Tegel</p> <p>Een tegel is een beschrijving van een voorgedefinieerd geografisch gebied, inclusief een verzameling van nul of meer [[#Feature|features]] en een of meer representaties in de vorm van 3D Data, raster of vector informatie.</p> <p>Officiele OGC Definitie:</p> <p>[!quote] Bron: https://docs.ogc.org/is/20-057/20-057.html#term-tile Geometrische vorm met bekende eigenschappen die al dan niet het resultaat zijn van een betegelingsproces ( tessellatie). Een tegel bestaat uit een enkel samenhangend \u201cstuk\u201d zonder \u201cgaten\u201d of \u201clijnen\u201d (topologische schijf).</p> <p>In de context van een 2D-tegelmatrix is een tegel een van de rechthoekige gebieden in de ruimte, die uniek ge\u00efdentificeerd kan worden door rij- en kolomindices, welke samen de tegelmatrix vormen.</p> <p>In de context van een geospatiale data-tegelset bevat een tegel gegevens voor een dergelijke ruimtelijke indeling als onderdeel van een overkoepelende set tegels voor die betegelde geospatiale data.</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#tilecontentloader","title":"TileContentLoader","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#tilemapper","title":"TileMapper","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#tileselector","title":"TileSelector","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#tileset","title":"TileSet","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#tilesetbuilder","title":"TileSetBuilder","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#tilesetfactory","title":"TileSetFactory","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#tilestransitionplanner","title":"TilesTransitionPlanner","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#transition","title":"Transition","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#visualisatie","title":"Visualisatie","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#zichtpunt","title":"Zichtpunt","text":"<p>De lokatie in de wereld waar de camera naar kijkt; in tegenstelling tot de camerapositie is deze lokatie waarschijnlijk middenin de viewport en de lokatie met het hoogste detailniveau en prioriteit van inladen.</p> <p>Deze lokatie representeert datgeen waar de aandacht van de gebruiker naartoe gaat.</p>"},{"location":"docs/developers/tilekit/appendix-d-frequently-asked-questions/","title":"Appendix d frequently asked questions","text":""},{"location":"docs/developers/tilekit/appendix-d-frequently-asked-questions/#appendix-d-frequently-asked-questions","title":"Appendix D. Frequently Asked Questions","text":""},{"location":"docs/developers/tilekit/appendix-d-frequently-asked-questions/#d1-databronnen-met-meerdere-lagen","title":"D.1. Databronnen met meerdere lagen","text":"<p>Tilekit zelf biedt geen faciliteit om iets te doen met databronnen met meerdere lagen, in Tilekit wordt aangenomen dat dit in de functionaliteit zelf gebeurd. </p> <p>In de afbeelding hiernaast kan je een voorbeeld flow zien waarbij de WMS functionaliteit de een TileSet definitie  opbouwt vanuit de capabilities van de WMS service zelf.</p> <p>In deze zelfde afbeelding is ook te zien hoe Tilekit omgaat met authenticatie, ook hierbij maken we gebruik van de  bestaande authenticatie systemen en kan je Tilekit een sjabloon request -inclusief credentials- aanmaken. </p> <p>Door deze scheiding van verantwoordelijkheden kan Tilekit flexibel omgaan met allerlei vormen van services.</p>"},{"location":"docs/developers/tilekit/changes/","title":"Changes","text":""},{"location":"docs/developers/tilekit/changes/#changes","title":"Changes","text":"<p>Important</p> <p>Dit hoofdstuk is nog in ontwikkeling en moet gaan beschrijven hoe changes los staan van de tegels zelf of features, en ook hoe we het Change subsysteem agnostisch houden van concrete implementaties</p> <p>Een Change is het proces om een tegel toe te voegen of te verwijderen. Elke change gebeurd als transactie, wat betekent dat de change als geheel moet slagen of falen, en dat deze geannuleerd kan worden. Deze handelswijze is essentieel om bij het mappen om te kunnen gaan met snelle bewegingen in de viewer, waarbij het laden van tegels onderbroken moet kunnen worden zonder dat er gaten in het vlak vallen</p>"},{"location":"docs/developers/tilekit/changes/#prioritering","title":"Prioritering","text":"<p>In ons tegelsysteem willen we ervoor zorgen dat de belangrijkste informatie zo snel mogelijk zichtbaar is. Daarom gebruiken we een prioriteitssysteem dat bepaalt welke tegels het eerst worden ingeladen. Dit systeem werkt op basis van twee belangrijke factoren:</p> <ol> <li>Laagprioriteit: Sommige lagen zijn belangrijker dan anderen. Elke laag heeft een gewicht dat aangeeft hoe    belangrijk de informatie in die laag is.</li> <li>Positie op het scherm: Tegels die dichter bij het midden van het scherm liggen, zijn belangrijker dan tegels die    verder weg liggen.</li> </ol>"},{"location":"docs/developers/tilekit/changes/#hoe-werkt-het","title":"Hoe werkt het?","text":"<ul> <li>Gewichten en afstanden: We kijken naar het gewicht van elke laag en de afstand van elke tegel tot   het Midden van het Scherm.</li> <li>Tegels in volgorde inladen: Als de gewichten van de lagen dicht bij elkaar liggen, laden we de tegels eerst in   vanaf het midden van het scherm, dan op basis van de laag. Dit betekent dat tegels in het midden altijd het eerst   worden ingeladen, gevolgd door tegels die verder van het midden af liggen.</li> <li>Hele lagen in volgorde inladen: Als de gewichten van de lagen ver uit elkaar liggen, laden we eerst alle tegels   van de hoogste laag in, voordat we doorgaan naar de volgende laag. Dit betekent dat we eerst een complete laag inladen   voordat we naar de volgende laag gaan.</li> </ul>"},{"location":"docs/developers/tilekit/changes/#voorbeeld","title":"Voorbeeld","text":"<p>Stel je voor dat je naar een kaart kijkt met drie lagen: maaiveld, gebouwen en WMS. De maaiveld en gebouwen liggen dicht bij elkaar qua gewicht, en de WMS laag niet.</p> <ol> <li>Begin in het midden van het scherm.<ol> <li>Laad eerst de maaiveld-tegel in omdat deze de hoogste prioriteit heeft,</li> <li>Gevolgd door de gebouwen-tegel omdat deze zijn prioriteit dichtbij de vorige ligt</li> </ol> </li> <li>Ga naar de volgende tegelpositie vanaf het midden en herhaal stap 1.</li> <li>Zodra alle maaiveld- en gebouwen-tegels zijn ingeladen, begin dan met het inladen van de WMS-tegels, ook vanaf het    midden van het scherm.</li> </ol>"},{"location":"docs/developers/tilekit/features/","title":"Features","text":""},{"location":"docs/developers/tilekit/features/#features","title":"Features","text":"<p>Question</p> <p>Moeten we wel een systeem voor features introduceren, of is dit een gevolg? Dat een WFS bevraagd kan worden door bbox's aan te brengen en de features op dit tegel een bij-effect zijn en gebeuren door observers?</p>"},{"location":"docs/developers/tilekit/features/#wat-is-een-feature","title":"Wat is een feature?","text":"<p>Een abstractie van re\u00eble wereldverschijnselen. Een digitale representatie van een echt bestaande entiteit of een abstractie van de re\u00eble wereld. Voorbeelden van features zijn bijna alles wat in tijd en ruimte geplaatst kan worden, waaronder bureaus, gebouwen, steden, bomen, bospercelen, ecosystemen, bezorgvoertuigen, sneeuwruimroutes, oliebronnen, oliepijpleidingen, olielekkage, enzovoort. De termen feature en object worden vaak door elkaar gebruikt.</p> <p>Bronnen:</p> <ul> <li>ISO-19101-1-2014 - Geographic information -- Reference model -- Part 1: Fundamentals</li> <li>W3C-SDW#feature</li> </ul> <p>Info</p> <p>Een van de beste vertalingen naar het Nederlands is het woord \"Kenmerk\"; hoewel een exacte vertaling van het woord Feature niet in het Nederlands voorkomt. Als gevolg daarvan zal in dit document het woord Feature gebruikt worden.</p>"},{"location":"docs/developers/tilekit/features/#doelen","title":"Doelen","text":"<ul> <li>Ondersteunt 3D en 2D data</li> <li>Gemakkelijk uit te breiden met ondersteuning voor nieuwe GIS formaten</li> <li>Vergemakkelijkt implementaties van WFS en OGC API : Features omdat deze formaten   feature-first zijn en niet tegel-first</li> <li>Spatial querying<ul> <li>Important: Datasets have features - real or not</li> <li>https://www.youtube.com/watch?v=vxZx_PXo-yo&amp;t=2s</li> <li>Jobs/Burst - een findAll doet een Depth First Search; elke branch in de tree kan in parallel; werkt mogelijk niet   in WebGL - experiment nodig</li> <li>Promise-based? Dat een search in basis asynchroon is en over frames uitgesmeerd kan worden in WebGL</li> <li>Search in this area - Google Maps zoekt op features in het huidige zoekgebied</li> <li>Querying kan als geheel - maar ook in een tile. Als het een tile is, dan kan een lijst gelooped worden<ul> <li>Of kunnen we bij het inlezen van een tile deze onderverdelen middels een grid of quadtree en de features   spatial onderverdelen zodat we hier ook een Depth First Search kunnen doen?</li> </ul> </li> <li>Map/Reduce patroon om te filteren?<ul> <li>https://www.youtube.com/watch?v=gX5nD2LeAvQ - ZLinq</li> </ul> </li> </ul> </li> <li>https://portal.ogc.org/files/96288 CQL</li> <li>Temporele ondersteuning - als de tijd wijzigt van de applicatie kan de URL beinvloed worden<ul> <li>WFS: Queryen op tijdgebaseerde attributen - Zie https://docs.ogc.org/is/17-069r4/17-069r4.html#_identifiers</li> <li>Hele URL, zoals Amsterdam Time Machine</li> <li>https://docs.ogc.org/is/20-057/20-057.html#toc52</li> </ul> </li> <li>Zijn sensor metingen ook features? Check SensorThings</li> <li>Wat te doen met overlappende features, zoals gebouwen die kort op elkaar zitten? die kunnen dubbel voor gaan komen   of we moeten bijhouden op welke tegels (meervoud) een feature kan voorkomen. Die moet dan ook pas opgeruimd worden   zodra alle gerelateerde tegels uit beeld zijn. Maar hoe bepalen we of een feature dubbel is?</li> </ul>"},{"location":"docs/developers/tilekit/features/#datamodel","title":"Datamodel","text":""},{"location":"docs/developers/tilekit/features/#services","title":"Services","text":""},{"location":"docs/developers/tilekit/geheugen-en-performance-optimalisatie/","title":"Geheugen en performance optimalisatie","text":""},{"location":"docs/developers/tilekit/geheugen-en-performance-optimalisatie/#geheugen-en-performance-optimalisatie","title":"Geheugen en performance optimalisatie","text":"<p>Netherlands3D is een WebGL applicatie met de bijbehorende beperkingen zoals een maximaal inzetbaar geheugenbereik van  2GB RAM en dat de applicatie zelf single-threaded is.</p> <p>De volgende richtlijnen zijn van toepassing om het tegelsysteem optimaal te laten functioneren:</p> <ul> <li>Caching, informatie die infrequent opnieuw ingeladen moet worden moet niet in geheugen blijven, maar gecached    worden naar <code>Application.temporaryCachePath</code>.</li> <li>Gebruik van unmanaged en value types ten behoeve van een optimale geheugenlayout en om CPU cache misses te    beperken.</li> <li>Jobs/Burst-systeem vermijden</li> </ul> <p>In de hoofdstukken hieronder staat beschreven waarom deze keuzes gemaakt worden en ook wat de impact is voor de  ontwikkelaar om rekening mee te houden. </p> <p>Unity WebGL is niet 100% single-threaded</p> <p>Een veelvoorkomend misverstand is dat Unity WebGL en JavaScript volledig single-threaded zijn. Hoewel beide \u00e9\u00e9n  main loop (\u201cplayer loop\u201d of \u201cevent loop\u201d) hebben, lopen sommige van de acties die ze starten wel degelijk op aparte  threads:</p> <ul> <li> <p>Web Workers: kun je expliciet in JavaScript aanmaken om reken-intensieve taken parallel uit te voeren, buiten    de main loop om.</p> </li> <li> <p>Web Requests: Unity gebruikt voor UnityWebRequest de JavaScript Fetch-API. Die delegeert netwerk-activiteiten    aan de browser, die deze op achtergrond threads afhandelt. Hierdoor kun je meerdere requests tegelijk in    behandeling hebben.</p> </li> </ul> <p>Zodra een achtergrond taak (bijvoorbeeld een web request) gereed is, keert de callback terug naar JavaScript en dus  weer naar de Unity-player loop. Pas dan wordt het resultaat in de hoofd-loop verwerkt.</p> <p>Meer informatie is hier te lezen.</p>"},{"location":"docs/developers/tilekit/geheugen-en-performance-optimalisatie/#caching","title":"Caching","text":"<p>Om in een Unity WebGL-applicatie binnen de strikte geheugen-limieten te blijven, hanteren we een meer-laagse cache-strategie voor tile-content. Elke tegel\u00adcontent doorloopt vier mogelijke staten\u2014van \u201chelemaal niet aanwezig\u201d tot \u201cactief in geheugen\u201d\u2014zodat we alleen de \u00e9cht benodigde data in RAM houden, en de rest elders opslaan.</p> <p>Todo</p> <ul> <li>Cache eviction beschrijven, bijv. bij memory pressure</li> <li>Kan dit ingezet worden voor alle soorten content in het project en niet alleen tiles? Denk aan MTL bestanden</li> <li>Beschrijf verschil tussen remote en local assets; local assets kunnen niet stale worden en hoeven niet naar Warm.   local assets leven altijd in cold storage, en om dan dat te dupliceren naar warm is zonde.</li> <li>Zouden we middels een strategy een van de niveaus kunnen 'aanpassen'? Bijvoorbeeld cold storage naar    memcache/redis laten schrijven als de gebruiker dat heeft? </li> <li>Moet het mogelijk zijn om per laag een retention policy te kunnen inregelen?</li> </ul>"},{"location":"docs/developers/tilekit/geheugen-en-performance-optimalisatie/#cache-niveaus","title":"Cache-niveaus","text":"<p>1. Hot</p> <ul> <li>Definitie: De content is geladen als een Unity-object (bijvoorbeeld een <code>Texture2D</code>) en staat in het actieve   geheugen.</li> <li>Gevolg: Telt volledig mee voor de WebAssembly-heap (de Unity-Memory.buffer), dus draagt bij aan de limiet die je   instelt via WebGL Memory Size.</li> </ul> <p>2. Warm</p> <ul> <li>Definitie: De content is ge\u00ebxporteerd naar een bestand in <code>Application.temporaryCachePath</code> (Emscripten\u2019s MEMFS).</li> <li>Gevolg: Verdwijnt uit de WebAssembly-heap, maar leeft voort in de JavaScript-heap als TypedArray. Dat betekent dat   het niet meer onder Unity\u2019s MAX_MEMORY valt, maar w\u00e9l ruimt opeist van de browser-JS-heap (\u00b14 GB in Chrome 64-bit).</li> </ul> <p>3. Cold</p> <ul> <li>Definitie: De content is verplaatst naar IndexedDB, via Emscripten\u2019s IDBFS of eigen JS-interop.</li> <li>Gevolg: Telt niet mee voor de JS-heap, maar wel voor de browser-schijfruimte-quota (meestal tot ~6 % van de vrije   schijfruimte). Perfect voor grote bestanden die je langer wilt bewaren.</li> </ul> <p>4. Stale</p> <ul> <li>Definitie: De content is niet aanwezig (nooit geladen of expliciet verwijderd/exired).</li> <li>Gevolg: Bij next-request moet de data weer vanaf de bron (WMS, server, etc.) worden opgehaald.</li> </ul>"},{"location":"docs/developers/tilekit/geheugen-en-performance-optimalisatie/#overgangs-mechanisme","title":"Overgangs-mechanisme","text":"<p>Quote</p> <p>There are 2 hard problems in computer science: cache invalidation, naming things, and off-by-1 errors.</p> <p>-- Leon Bambrick</p> <ol> <li>Initialisatie \u2192 alle tiles starten in Stale.</li> <li>Gebruiker in zicht \u2192 tile laadt, content wordt Hot (direct in geheugen).</li> <li>Uit zicht maar binnenkort weer nodig \u2192 verplaats Hot \u2192 Warm (MEMFS).</li> <li>Lang uit zicht, low-priority \u2192 verplaats Warm \u2192 Cold (IndexedDB).</li> <li>Verwijderd of verlopen \u2192 ruim Cold op \u2192 terug naar Stale.</li> </ol> <p>Op deze manier blijft alleen wat n\u00fa \u00e9cht nodig is in het dure RAM staan, en gebruik je de goedkopere lagen (MEMFS of IndexedDB) voor de rest.</p>"},{"location":"docs/developers/tilekit/geheugen-en-performance-optimalisatie/#voorbeeld-wms-tegels","title":"Voorbeeld: WMS-tegels","text":"<ol> <li>Stale: bij opstart zijn alle WMS-tegels ongekend.</li> <li>Hot: als een tegel in view komt, vraagt <code>TileContentLoader</code> de afbeelding op en slaat deze als <code>Texture2D</code> in RAM op.</li> <li>Warm: zodra de gebruiker de tegel even niet meer ziet maar mogelijk snel terugkeert, schrijven we de data weg naar <code>temporaryCachePath</code>. De tegel zelf blijft verwijzen naar het bestand in MEMFS, maar geeft RAM vrij.</li> <li>Cold: bij zeer ver uit zicht of bij geheugendruk plaatsen we de tegeldata in IndexedDB.</li> <li>Stale: als de laag wordt verwijderd, of wanneer een cache-expiry is bereikt, wissen we de IndexedDB-versie; de volgende keer valt de tegel weer in Stale en moet hij opnieuw worden geladen.</li> </ol>"},{"location":"docs/developers/tilekit/geheugen-en-performance-optimalisatie/#data-structuren-en-geheugenlayout","title":"Data Structuren en Geheugenlayout","text":"<p>In WebGL-applicaties heb je te maken met strikte limieten op zowel CPU-tijd als geheugen (zowel WASM-heap als JavaScript-heap). Slecht ontworpen datastructuren leiden tot:</p> <ul> <li>Onvoorspelbare GC-pauzes die zorgen voor framerate-hicks en mindere gebruikerservaring.</li> <li>CPU-cache-misses die loops vertragen en de laadtijd van tiles opvoeren.</li> <li>Geheugenlekken of overallocaties die tot uitval (out-of-memory) kunnen leiden, vooral op mobiele of low-end devices.</li> </ul> <p>Deze richtlijnen helpen om:</p> <ol> <li>Consistente performance te verkrijgen bij verschillende hardware en browsers.</li> <li>Voorspelbare geheugencapaciteit te behouden, binnen de limieten van Unity WebGL en de browser.</li> <li>Debuggen en onderhoud te vereenvoudigen door eenduidige patterns (value types, Native-collecties) toe te passen.</li> </ol> <p>Als het in Unity zijn Jobs systeem werkt, dan is het goed</p> <p>Hoewel we het Unity Jobs systeem niet gebruiken, is het aan te raden om data structuren zo te schrijven dat die daarin toe te passen zijn. Unity Jobs is ontworpen met Data-Oriented Design in gedachten en op deze manier weet je wanneer je datamodel klopt.</p>"},{"location":"docs/developers/tilekit/geheugen-en-performance-optimalisatie/#structuurkeuze","title":"Structuurkeuze","text":"<p>1. Gebruik altijd value types (<code>struct</code>)</p> <ul> <li>Waarom: Inline opslag, geen managed heap\u2013allocaties, geen onvoorspelbare GC-pauzes.</li> <li>Hoe: Definieer <code>TileSet</code>, <code>TilesInView</code>, en alle gerelateerde data als <code>struct</code>.</li> </ul> <p>2. Vermijd reference types (<code>class</code>, <code>string</code>)</p> <ul> <li>Waarom niet: Leven op managed heap, leiden tot garbage-collectie en fragmentatie.</li> <li>Tekstdata: Gebruik <code>NativeText</code> of <code>FixedString32Bytes</code>/<code>FixedString64Bytes</code> voor tekst.</li> </ul> <p>3. Geen class-inheritance voor data</p> <ul> <li>Beperkingen: <code>struct</code> ondersteunt geen inheritance.</li> <li>Alternatief: Pas composition toe:<ul> <li>Maak kleinere, uniforme data-<code>structs</code> en combineer ze in grotere struct-velden.</li> <li>Voor polymorfische gedrag, gebruik discriminated unions (een enum + union-struct).</li> </ul> </li> </ul>"},{"location":"docs/developers/tilekit/geheugen-en-performance-optimalisatie/#geheugenbeheer-met-unitycollections","title":"Geheugenbeheer met Unity.Collections","text":"<p>1. Native-collecties</p> <ul> <li>Gebruik: <code>NativeArray&lt;T&gt;</code>, <code>NativeList&lt;T&gt;</code>, <code>NativeHashMap&lt;K,V&gt;</code>, <code>NativeQueue&lt;T&gt;</code>.</li> <li>Voordeel: Contigu\u0308e, unmanaged geheugenblokken buiten de managed heap.</li> </ul> <p>2. Lifecycle (\u201callocatie \u2192 gebruik \u2192 vrijgave\u201d)</p> <ul> <li>Allocatie:</li> </ul> <pre><code>var buffer = new NativeArray&lt;MyStruct&gt;(count, Allocator.Persistent);\n</code></pre> <ul> <li> <p>Gebruik: lees/schrijf data direct.</p> </li> <li> <p>Vrijgave:</p> </li> </ul> <pre><code>buffer.Dispose();\n</code></pre> <ul> <li> <p>Checklist:</p> <ul> <li>Sluit alle <code>Allocator.Persistent</code>-allocaties af met <code>Dispose</code>.</li> <li>Controleer op dubbele <code>Dispose</code> (risico op ObjectDisposedException).</li> </ul> </li> </ul>"},{"location":"docs/developers/tilekit/geheugen-en-performance-optimalisatie/#samenvatting-dos-donts","title":"Samenvatting: Do\u2019s &amp; Don\u2019ts","text":"Do\u2019s Don\u2019ts Definieer data als <code>struct</code> Gebruik geen <code>class</code> voor data Gebruik <code>NativeArray&lt;T&gt;</code> en <code>NativeList&lt;T&gt;</code> Sla data niet op in managed heap Breng data contigu\u0308e onder Gebruik geen pointer-indexen Beheer memory expliciet (<code>Dispose</code>) Verwaarloos geen <code>Dispose</code>-calls Pas composition toe ipv inheritance voor structs Gebruik geen polymorphe classes"},{"location":"docs/developers/tilekit/geheugen-en-performance-optimalisatie/#waarom-geen-unity-jobs","title":"Waarom g\u00e9\u00e9n Unity Jobs?","text":"<p>Unity\u2019s Job-systeem is ontworpen om data binnen meerdere threads gelijktijdig te verwerken. Echter, in de context van WebGL biedt het Jobs-systeem nauwelijks voordelen:</p> <ol> <li> <p>Beperkte WebGL-threading</p> <ul> <li>Browsers ondersteunen WebAssembly threads alleen via experimentele Web Workers + SharedArrayBuffer, wat door veel   platformen (zoals iOS/Safari) niet of beperkt wordt aangeboden.</li> <li>Unity WebGL builds zijn standaard single-threaded, waardoor alle jobs alsnog op de hoofdthread worden geplant.</li> </ul> </li> <li> <p>Extra complexiteit en overhead</p> <ul> <li>Jobs vereisen opzet rond <code>JobHandle</code>, memory fences en (optioneel) Burst-compilatie.</li> <li>Omdat threads niet daadwerkelijk parallel werken in WebGL, ontstaan onnodige synchronisatiekosten en extra   API-overhead.</li> </ul> </li> <li> <p>Onderhoud en foutgevoeligheid</p> <ul> <li>De complexiteit van Jobs verhoogt de test- en debugging-load.</li> <li>De ontwikkeltijd neemt toe omdat er meer expertise nodig is om dit te bouwen en onderhouden.</li> </ul> </li> </ol> <p>In WebGL-projecten voegen Unity Jobs meer overhead en complexiteit toe dan dat ze performance opleveren. We kiezen er daarom bewust voor om sequenti\u00eble loops en native collecties te gebruiken, zonder Job-dispatching.</p>"},{"location":"docs/developers/tilekit/metadata/","title":"Metadata","text":""},{"location":"docs/developers/tilekit/metadata/#metadata","title":"Metadata","text":"<p>Important</p> <p>Dit hoofdstuk is nog in ontwikkeling en moet gaan beschrijven wat de invloed van Metadata kan zijn, en hoe metadata ook gestructureerd kan zijn in \"classes\". Daarbij moet uitgezocht worden welke rol metadata wel of niet gaat spelen in de selectie van het bestandstype voor de Tegel inhoud; sommige bestanden hebben een mimetype die je hier zou kunnen opgeven als de bestandsextensie niet afdoende is.</p>"},{"location":"docs/developers/tilekit/ophalen-van-data/","title":"Ophalen van data","text":""},{"location":"docs/developers/tilekit/ophalen-van-data/#ophalen-van-data","title":"Ophalen van data","text":"<ul> <li>Moet Asynchroon middels promises</li> <li>Network requests moeten gethrottled kunnen worden opgehaald (per host)<ul> <li>Is dit een verantwoordelijkheid van de ChangeScheduler?</li> </ul> </li> <li>Er moet er een retry mechanisme in komen<ul> <li>Is dat iets voor Uxios? https://dev.to/scrapfly_dev/how-to-retry-in-axios-5e87</li> <li>Kijk naar https://cesium.com/learn/cesiumjs/ref-doc/Resource.html</li> </ul> </li> <li>Injecteren van een sjabloon-request (Uxios.Config) voor, bijv, authenticatie en custom headers.</li> <li>Zowel remote als bestanden uit de persistent data storage kan worden opgehaald op een eenduidige manier<ul> <li>middels de HTTP Client Uxios.</li> <li>Zie https://kind-men.github.io/uxios/guides/working-with-persistent-data/ voor bestanden in de Persistent Data Storage, en https://kind-men.github.io/uxios/guides/fetching-pokemon-using-get/ voor URLs.</li> </ul> </li> <li>Filesystem abstractie?<ul> <li>Kunnen we hergebruiken wat er al is in het projectsysteem en daar een systeem van maken?</li> <li>Dit zijn nu verschillende manieren; ik doel vooral op de <code>project://</code> prefix en het inladen daarvan</li> </ul> </li> <li>Als we hier een aparte adapter van maken, dan kunnen we itereren op dit stuk en hoeft bovenstaande niet in een keer.<ul> <li>Gaan we met <code>project://</code> werken, of met <code>unity+persistent://</code>? Die laatste is Uxios, die eerste is onze eigen manier. Met de laatste kunnen we ook bestanden openen die niet in het project zijn maar wel in de persistent storage; nadeel is dat je je bestandslokaties moet weten</li> </ul> </li> <li>Gaan we abstraheren, of juist op Uxios leunen? Dat eerste is flexibeler, dat tweede minder complex.</li> <li>TileContentLoader moet aan begin meegegeven worden</li> <li>Elke TileRenderer of de GameObject die geinstantieerd wordt wil toegang hebben tot de TileContentLoader? Of tot de TileContentData?</li> </ul>"},{"location":"docs/developers/tilekit/ophalen-van-data/#authenticatie-en-autorisatie","title":"Authenticatie en Autorisatie","text":"<p>Het bepalen van de juiste credentials voor een databron gebeurt v\u00f3\u00f3r het inladen van een laag met Tilekit. Tilekit voorziet hierin geen interactief loginmechanisme of eigen authenticatieflow.</p> <p>In plaats daarvan gaat Tilekit ervan uit dat credentials reeds bekend zijn. Deze credentials worden vervolgens ge\u00efnjecteerd in het sjabloon van alle HTTP-verzoeken die de TileContentLoader gebruikt om tegels op te halen.</p> <p>Deze aanpak biedt de volgende voordelen:</p> <ul> <li> <p>Scheidt verantwoordelijkheden: authenticatie wordt volledig uitbesteed aan een bovenliggende laag of reeds   bestaand authenticatiemechanisme zoals het <code>Netherlands3D.Credentials</code> systeem.</p> </li> <li> <p>Maakt Tilekit eenvoudiger en modulair: er is geen noodzaak voor ingebouwde ondersteuning van verschillende   authenticatieprotocollen binnen Tilekit zelf.</p> </li> <li> <p>Ondersteunt variabele autorisatie-eisen per databron: omdat elke TileContentLoader zijn eigen verzoek-sjabloon kan   krijgen, kunnen per laag of bron andere headers, tokens of endpoints gebruikt worden.</p> </li> </ul> <p>Voorbeeld: een WFS-bron met een OAuth2-authenticatie kan door een aparte module een access token laten ophalen. Dit token wordt vervolgens in de Authorization-header geplaatst van het HTTP-sjabloon waarmee de TileContentLoader tegels ophaalt. Tilekit is hier volledig agnostisch in \u2014 zolang het sjabloon correct is ingevuld, zal de bron benaderd worden met de juiste credentials.</p> <p>In situaties waarin authenticatie moet worden hernieuwd (zoals bij vervallen tokens), ligt de verantwoordelijkheid bij de bovenliggende laag om het sjabloon te vernieuwen of de TileContentLoader opnieuw te initialiseren met bijgewerkte credentials.</p>"},{"location":"docs/developers/tilekit/ophalen-van-data/#flow","title":"Flow","text":"<p>Vraag: moeten we een TileRenderer en TileContentRenderer hebben? Of is een Tile een algemene prefab die als container gebruikt kan worden maar de TileRenderer eigenlijk een TileContentRenderer?</p> <ol> <li>Een Change voor het toevoegen van een tegel wordt gestart</li> <li>De change zoekt de juiste TileRenderer op en initieert het aanmaken van de tegel</li> <li>De TileRenderer bevraagt de TileContents (meervoud) en voor elke TileContent gebruikt de TileContentLoader om<ol> <li>een Request samen te stellen op basis van het Sjabloon request en de TileContent zijn URI, en</li> <li>het bestand te downloaden, en</li> <li>Zodra de download klaar is, de TileRenderer te informeren</li> </ol> </li> <li>Zodra alle TileContentData ingeladen is, dan</li> <li>Gaat de TileRenderer de visualisatie aanmaken (PolygonVisualisation, Prefabs, etc)</li> <li>Gaat de visualisatie de gedownloadde informatie toepassen (voorbeeld: Texture aan de nieuw aangemaakte DecalProjector koppelen)</li> <li>Meld de TileRenderer de Change af als geslaagd</li> </ol>"},{"location":"docs/developers/tilekit/ophalen-van-data/#services","title":"Services","text":"<pre><code>classDiagram\n    class TileContentData {     \n        // which tile is connected to the data\n        + Tile tile\n\n        // which content in the tile is this data for, we store an index number \n        // but can return the value using a property\n        - TileContent tileContentIndex\n        + TileContent TileContent\n\n        // where is the data on the filesystem\n        + FileInfo fileInfo\n    }\n\n    class ITileContentLoader {\n        UsingAuthentication(StoredAuthorization authentication)\n        Load(Tile tile, int tileContentIndex) Promise~TileContentData~\n    }\n    class UxiosTileContentLoader {\n        UxiosTileContentLoader(Uxios.Config requestTemplate)\n    }\n\n    &lt;&lt;interface&gt;&gt; ITileContentLoader\n\n    ITileContentLoader &lt;|-- UxiosTileContentLoader\n    TileContentData -- ITileContentLoader\n    StoredAuthorization -- ITileContentLoader\n    Tile -- ITileContentLoader\n    Tile -- TileContentData\n    TileContent -- TileContentData\n    FileInfo -- TileContentData\n    UxiosTileContentLoader -- Uxios.Config</code></pre>"},{"location":"docs/developers/tilekit/pluggable-architectuur/","title":"Pluggable architectuur","text":""},{"location":"docs/developers/tilekit/pluggable-architectuur/#pluggable-architectuur","title":"Pluggable Architectuur","text":""},{"location":"docs/developers/tilekit/pluggable-architectuur/#kenmerken","title":"Kenmerken","text":"<ul> <li>Er is \u00e9\u00e9n MonoBehaviour dat als orchestrator,   of context, werkt - de   TileMapper.</li> <li>Een serie ScriptableObjects dat ieder 1 specifieke functie heeft, zoals de TileSelector, ChangeScheduler,   TilesTransitionPlanner.</li> <li>Elke van deze ScriptableObjects representeert een Strategy.</li> <li>Elke functie kan hiermee makkelijk vervangen worden door een andere implementatie</li> </ul> <p>Voorbeeld: </p> <p>Zie https://unity.com/how-to/scriptableobjects-delegate-objects#pluggable-behavior voor een beschrijving van Unity, en https://refactoring.guru/design-patterns/strategy voor meer informatie over het Strategy Design Pattern.</p>"},{"location":"docs/developers/tilekit/pluggable-architectuur/#waarom","title":"Waarom?","text":"<ul> <li>Vertegeling is complex - door opsplitsen in kleine verantwoordelijkheden is het makkelijk om van elk onderdeel te   zien wat het moet doen</li> <li>Toekomstbestendig - door een aantal functionaliteiten te maken met duidelijke boundaries kan ieder onderdeel   individueel vervangen worden zonder grote refactorings</li> <li>Modulair - functionaliteiten, zoals WMS en WFS, kunnen specifieke implementaties van functies bijdragen -zoals   maken van de TileSet op basis van GetCapabilities- zonder dat het de rest hoeft te raken</li> <li>Minder uitzonderingen - code doet maar een ding en heeft daarmee ook minder uitzonderingen; als een   functionaliteit een bijzonderheid heeft die niet gevangen wordt in de bestaande implementaties, dan kan je een   specifieke implementatie maken voor die functionaliteit.</li> </ul>"},{"location":"docs/developers/tilekit/tegelsysteem/","title":"Tegelsysteem","text":""},{"location":"docs/developers/tilekit/tegelsysteem/#tegelsysteem","title":"Tegelsysteem","text":""},{"location":"docs/developers/tilekit/tegelsysteem/#doelen","title":"Doelen","text":""},{"location":"docs/developers/tilekit/tegelsysteem/#functionaliteit","title":"Functionaliteit","text":"<ul> <li> <p>Uitbreidbaarheid</p> <ul> <li>Ondersteuning voor nieuwe GIS-standaarden (WFS, OGC API Features, WMS)</li> <li>Ondersteuning voor extra bestandsformaten (PNG, Raster, GLB, FBX, OBJ)</li> </ul> </li> <li> <p>Laagstructuur &amp; Databronnen</p> <ul> <li>E\u00e9n TileSet kan meerdere lagen visualiseren vanuit gedeelde bron (bijv. WMS)</li> <li>E\u00e9n TileSet kan tegels uit andere TileSets bevatten als remote TileSet</li> </ul> </li> <li> <p>Authenticatie</p> <ul> <li>Ondersteuning voor afgeschermde bronnen met authenticatie</li> </ul> </li> <li> <p>Featurebeheer</p> <ul> <li>Features kunnen in meerdere tegels voorkomen, maar worden slechts eenmaal gerenderd; zie Features.</li> <li>Features moeten bevraagd kunnen worden middels querying.</li> </ul> </li> <li> <p>Styling &amp; Events</p> <ul> <li>Event-systeem voor be\u00efnvloeding van tegels (bijv. styling bij creatie)</li> <li>Mechanisme voor verversen van tegels bij runtime-styling</li> </ul> </li> </ul>"},{"location":"docs/developers/tilekit/tegelsysteem/#tilingstructuur","title":"Tilingstructuur","text":"<ul> <li> <p>LOD-ondersteuning (HLOD)</p> <ul> <li>Variabele tegelgrootte (zoals 3D Tiles)</li> <li>Variabele databron (zoals Cartesian Tiles)</li> <li>Combinatie van beide (bijv. WMS op afstand/lokaal)</li> </ul> </li> <li> <p>Tilingmodellen</p> <ul> <li>Impliciet tiling voor wereld-dekkende datasets</li> <li>Expliciet tiling voor vooraf gedefinieerde hi\u00ebrarchie\u00ebn</li> </ul> </li> <li> <p>Geometric Error Threshold</p> <ul> <li>Instelbare fouttolerantie voor LOD-keuze</li> </ul> </li> </ul>"},{"location":"docs/developers/tilekit/tegelsysteem/#architectuur-techniek","title":"Architectuur &amp; Techniek","text":"<ul> <li> <p>Gebaseerd op field-tested standaarden en concepten</p> <ul> <li>3D Tiles</li> <li>GeoJSON</li> <li>OGC API<ul> <li>Tiles</li> <li>Maps</li> <li>Features</li> </ul> </li> <li>OGC WMS</li> <li>OGC WMS</li> <li>OGC WFS</li> </ul> </li> <li> <p>Co\u00f6rdinaten &amp; Projectie</p> <ul> <li>Abstract Coordinate System; projectie door developers configureerbaar.</li> <li>Aanbevolen: EPSG:4978 (XYZ)</li> <li>Ondersteuning voor EPSG:4979 (lat/lon/height) in bounding volumes</li> </ul> </li> <li> <p>Floating Origin</p> <ul> <li>Compatibel zonder directe koppeling</li> </ul> </li> <li> <p>Unity-integratie</p> <ul> <li>Intu\u00eftieve structuur met MonoBehaviours &amp; ScriptableObjects voor configuratie</li> </ul> </li> </ul>"},{"location":"docs/developers/tilekit/tegelsysteem/#niet-functionele-aspecten","title":"Niet-functionele aspecten","text":"<ul> <li> <p>Performance</p> <ul> <li>Caching van tegels en datasets</li> <li>Minimaliseren van geheugenverbruik (WebGL-geschikt)</li> <li>Actieve resource-opruiming vereist</li> </ul> </li> <li> <p>Robuustheid</p> <ul> <li>Fouttolerantie bij netwerkproblemen of externe fouten</li> </ul> </li> <li> <p>Gebruiksvriendelijkheid</p> <ul> <li>Eenvoudig beheer en uitbreiding van datasets</li> </ul> </li> <li> <p>Debugging</p> <ul> <li>Visuele tools voor tile-analyse en debugging</li> </ul> </li> <li> <p>Laadstrategie</p> <ul> <li>Progressive enhancement: eerst goedkope, daarna detail</li> <li>Prioritering: nabijgelegen tegels eerst laden</li> </ul> </li> </ul>"},{"location":"docs/developers/tilekit/tegelsysteem/#expliciete-en-impliciete-tilesets","title":"Expliciete en impliciete TileSets","text":"<p>Bij het ontwerpen van een tegelsysteem maken we onderscheid tussen expliciete en impliciete tegelsystemen. Beide benaderingen beschrijven hoe tegels binnen een (hi\u00ebrarchische) structuur worden georganiseerd en aangesproken, maar ze verschillen fundamenteel in hoe deze wordt gedefinieerd.</p>"},{"location":"docs/developers/tilekit/tegelsysteem/#expliciet-tegelsysteem","title":"Expliciet Tegelsysteem","text":"<p>Een expliciet tegelsysteem beschrijft elke tegel individueel, inclusief zijn positie, relatie tot andere tegels en metadata. Hierbij maken we gebruik van een vooraf gedefinieerde lijst van tegels in de TileSet. Elke tegel kent zijn kinderen expliciet, inclusief verwijzingen naar onderliggende tegels.</p> <p>Kenmerken</p> <ul> <li>Structuur is volledig gespecificeerd.</li> <li>Onderlinge relaties (ouder-kind) zijn expliciet gedefinieerd.</li> <li>Geschikt voor complexe hi\u00ebrarchie\u00ebn of geoptimaliseerde datastructuren.</li> <li>Maakt vaak gebruik van LOD's (Levels of Detail) per tegel.</li> </ul> <p>Voordeel: Volledige controle en flexibiliteit over de positie, hi\u00ebrarchie en metadata per tegel. Nadeel: Grotere initi\u00eble payload en ongeschikt voor grootschalige datasets.</p>"},{"location":"docs/developers/tilekit/tegelsysteem/#impliciet-tegelsysteem","title":"Impliciet Tegelsysteem","text":"<p>Een impliciet tegelsysteem beschrijft geen individuele tegels, maar maakt gebruik van een algoritme om tegels af te leiden op basis van een vaste structuur. Dit systeem is schaalbaar en effici\u00ebnt, omdat de hi\u00ebrarchie en locatie van een tegel volledig kunnen worden afgeleid uit de tegel-ID.</p> <p>Netherlands3D ondersteunt binnen het impliciete systeem drie hoofdstructuren:</p> <p>1. Quadtree De quadtree-structuur deelt de ruimte op in vier gelijke kwadranten per niveau. Elke tegel heeft maximaal vier kinderen (NO, NW, ZO, ZW). Deze structuur is ideaal voor tweedimensionale datasets of geografische informatie.</p> <p>2. Octree De octree is de driedimensionale tegenhanger van de quadtree. Elke tegel wordt opgesplitst in acht kinderen, waarbij de ruimte langs de x-, y- en z-as wordt gehalveerd. Deze structuur is geschikt voor volumetrische datasets of 3D-sc\u00e8nes met LOD.</p> <p>3. Uniform Grid Bij een uniform grid worden tegels op een vlak verdeeld in een vast raster, zonder hi\u00ebrarchie. Dit type wordt meestal gebruikt wanneer elke tegel gelijkwaardig is en er geen behoefte is aan dynamische detaillering of LOD.</p> <p>Kenmerken van impliciete systemen:</p> <ul> <li>Hi\u00ebrarchie wordt bepaald door een patroon (bijv. depth en tile indices).</li> <li>Geen beschrijving van elke individuele tegel nodig: structuur is afleidbaar.</li> <li>Lichtgewicht en geschikt voor grote datasets.</li> <li>Relaties worden bepaald door index-berekening in plaats van expliciete verwijzingen.</li> </ul> <p>Voordeel: Hoge schaalbaarheid en lage overhead. Nadeel: Minder flexibiliteit voor per-tegel metadata of uitzonderingen.</p> <p>Zie https://github.com/CesiumGS/3d-tiles/blob/main/specification/ImplicitTiling/README.adoc voor details hoe de 3D Tiles specificatie omgaat met Impliciete Tiling, Tilekit zijn ontwerp is gebaseerd op deze principes met extra ondersteuning voor uniforme grids.</p>"},{"location":"docs/developers/tilekit/tegelsysteem/#levenscyclus-van-een-kaartlaag","title":"Levenscyclus van een kaartlaag","text":"<p>De levenscyclus van een kaartlaag bestaat uit de volgende stappen:</p> <ol> <li>Inladen van een laag: in dit stadium worden de capabilities opgehaald van de gekozen databron, en    omgezet in Tilekit zijn eigen tegelset definitie. Dit garandeert dat het klaarzetten van de tegels en het bijwerken    van de weergave altijd dezelfde informatie hebben, ongeacht de bron.</li> <li>Klaarzetten van tegels (Staging): Bij het klaarzetten van tegels wordt bepaald welke tegels ingeladen    en ontladen moeten worden; hierbij wordt gekeken naar de actuele situatie, een gewenste situatie en lopende    wijzigingen om te bepalen welke wijzigingen in de wachtrij gezet moeten worden.</li> <li>Bijwerken van de weergave (Mapping): In dit stadium wordt de wachtrij van wijzigingen afgelopen en    wijzigingen ingestart en gemonitored.</li> </ol> <p>Het klaarzetten van de tegels (Staging) en het bijwerken van de weergave (Mapping) is een herhalend proces. De standaard aanname van Tilekit is dat een Timer klasse geimplementeerd is die beide stadia in volgorde afhandeld; maar Tilekit ondersteunt ook dat het stagen en mappen door andere processen worden uitgevoerd.</p> <p>Staging en mapping zijn idempotent</p> <p>Bovenstaande betekent staging en mapping geen afhankelijkheid mogen hebben en dat beide handelingen Idempotent zijn. Staging mag meermaals uitgevoerd kunnen worden voordat mapping wordt uitgevoerd en andersom.</p> <pre><code>Deze ontwerpkeuze is fundamenteel om asynchrone handelingen te ondersteunen omdat de mapping fase alleen een change\nkan starten, maar de change zelf meerdere frames en cycli van staging zou kunnen duren.\n</code></pre>"},{"location":"docs/developers/tilekit/tegelsysteem/#inladen-van-een-tileset","title":"Inladen van een TileSet","text":"<p>In hoofdstuk 7.4. Datamodel is beschreven welke elementen de definitie van een TileSet heeft. Hiermee kan je flexibel een breed scala aan tegelsystemen mee weergeven, maar dit van begin af aan inrichten is een uitdaging zonder de effecten te weten van alle knoppen waar je aan kan draaien.</p> <p>Om dit proces te versimpelen zijn er 2 ondersteunende services die gebruikt kunnen worden om op een simpele manier een TileSet te kunnen configureren:</p> <ol> <li>TileSetBuilder, een Builder service waarmee je met een paar    korte instructies tiles kan builden en een TileSet valideren.</li> <li>TileSetFactory, een Factory service waarmee je in een    keer een gehele TileSet instantieert met een specifieke configuratie.</li> </ol> <p>Middels dit proces kunnen willekeurige databronnen omgezet worden in TileSet definities, en uniform afgehandeld worden in de rest van het systeem.</p>"},{"location":"docs/developers/tilekit/tegelsysteem/#voorwaarden-voor-een-valide-tileset","title":"Voorwaarden voor een valide TileSet","text":"<p>Spatial Coherence</p> <p>Bij het omzetten van de data van een databron naar expliciete tegels is van belang dat de bounding volume van alle tegels Spatial Coherence hebben. Deze beperking zorgt ervoor dat tegels benaderd kunnen worden als een R-tree datastructuur en geeft optimalisatiemogelijkheden, zoals het volledig overslaan van een complete branch aan tegels als de applicatie niet eens in de buurt is.</p> <p>Voorbeeld</p> <p>Als we ergens in Nederland naar een lokatie kijken dan kunnen we alle tegels -van elk LOD niveau- overslaan buiten Nederland, zoals Duitsland of geheel Afrika. Dit kan alleen als de tegels in Nederland Spatial Coherence hebben.</p> <p>Aanwezigheid van een Geometrische Error</p> <p>Elke tegel moet een geometricError waarde bevatten. Deze waarde, uitgedrukt in meters, geeft aan hoeveel detail er verloren gaat als deze tegel wordt weergegeven in plaats van zijn fijnmazigere kindtegels. Zonder deze waarde is automatische LOD-switching niet mogelijk.</p> <p>Oplopende Detailniveaus (Geometrische Hi\u00ebrarchie)</p> <p>Kindtegels moeten altijd een lagere geometricError hebben dan hun ouder. Dit weerspiegelt de hi\u00ebrarchische structuur van het tegelsysteem, waarbij lagere niveaus (meer gedetailleerde tegels) nauwkeuriger zijn.</p> <p>Als deze relatie niet klopt, kan de applicatie verkeerde beslissingen nemen over welke tegel in beeld moet komen, met visuele artefacten of onnauwkeurigheden als gevolg. Het afdwingen van deze regel zorgt ervoor dat LOD-logica zoals Screen Space Error correct werkt.</p>"},{"location":"docs/developers/tilekit/tegelsysteem/#tilesetbuilder","title":"TileSetBuilder","text":"<p>De TileBuilder biedt een aantal gemaksfuncties waarmee een TileSet gemakkelijk opgebouwd kan worden. Aangezien een TileSet zelf bestaat uit een paar korte instructies en vervolgens een boomstructuur aan Tile objecten zal de TileBuilder</p> <p>Voorbeeld:</p> <pre><code>quadTreeTileBuilder = TileSetBuilder.QuadTree(bounds);\n</code></pre>"},{"location":"docs/developers/tilekit/tegelsysteem/#tilesetfactory","title":"TileSetFactory","text":""},{"location":"docs/developers/tilekit/tegelsysteem/#staging","title":"Staging","text":"<p>De Staging fase in de TileMapper is bedoeld om te bepalen welke tegels in- en uitgeladen moeten worden om in de 7.3.4. Mapping fase dit in gang te kunnen zetten. De staging fase, net als de mapping fase is bedoeld om idempotent uitgevoerd te worden. Dit betekent dat het mogelijk is om meermaals deze stap uit te kunnen voeren en dat de uitkomst altijd 1-op-1 toegepast kan worden in de mapping fase.</p> <p></p> <p>Het staging proces is verdeeld in 3 stappen:</p> <ol> <li>Welke tegels zijn er nu in beeld middels de <code>TilesInView</code> verzameling</li> <li>Welke tegels moeten er in beeld komen middels een <code>TileSelector</code> service</li> <li>Welke wijzigingen moeten worden uitgevoerd om van de huidige naar de nieuwe situatie te komen -genaamd    een Transition - middels een TilesTransitionPlanner.</li> </ol>"},{"location":"docs/developers/tilekit/tegelsysteem/#tegel-selectie","title":"Tegel selectie","text":"<p>De TileSelector is een service die bepaald welke tegels er in beeld zouden moeten zijn. Van de TileSelector kunnen meerdere strategieen zijn, degene die standaard toegepast wordt is de \"TilesInView\" tile selector.</p> <p>De TilesInView tile selector zal middels een \"Depth First Search\" de TileSet definitie doorlopen. Depth First Search is een recursief zoek algoritme waarbij je begint met een enkele \"root\" tegel, en vervolgens de volgende vragen stelt:</p> <ol> <li>Is deze tegel in beeld?<ol> <li>Als de tegel niet in beeld is, dan eindigt onze zoektocht. Deze tegel wordt niet geladen en we negeren zijn    kinderen,</li> <li>Anders:</li> </ol> </li> <li>Is het type van refinement \"Add\" of \"Replace\"?<ol> <li>is het type \"Replace\", dan starten we een serie van geselecteerde tegels</li> <li>is het type \"Add\", dan voegen we deze tegel toe aan de serie van geselecteerde tegels</li> </ol> </li> <li>Is dit het juiste LOD voor deze tegel?<ol> <li>Als de juiste LOD van een tegel gevonden dan onthouden we de serie aan geselecteerde tegels,</li> <li>Anders: herhaal deze stappen voor elke kind-tegel van deze tegel</li> </ol> </li> </ol> <p>Aan het einde van deze handeling zouden we een lijst moeten hebben van tegels die in beeld moeten gaan zijn. In stap 2 is dus van belang dat we niet altijd op zoek zijn naar 1 tegel in een aftakking van de R-tree. Het is ook mogelijk een reeks aan kinderen te verkrijgen omdat bij een ADD de kind tegel niet de ouder tegel vervangt, maar juist in combinatie met een ouder tegel wordt ingeladen.</p> <p>// TODO Update schema, en controleer de exacte werking als afwisselend ADD en REPLACE door elkaar gebruikt worden</p> <p>Wat is \"de juiste LOD\"?</p> <p>Tegels moeten een \"Geometric Error\" hebben. De geometric error is een maat (in meters) die zegt hoe \"grof\" een tegel is in vergelijking met zijn fijnere kinderen. Het komt neer op: hoeveel detail je mist als je deze tegel toont in plaats van zijn onderliggende (meer gedetailleerde) tegels.</p> <p>Tijdens het draaien van de app gebruiken we deze geometricError om te bepalen of een tegel voldoende detail geeft op het scherm. Dat doen we door het om te rekenen naar screen space error (SSE) \u2013 dat is de fout uitgedrukt in pixels op je scherm.</p> <p>Bijvoorbeeld:</p> <ul> <li>Stel: een tegel heeft een geometricError van 50 meter.</li> <li>Als die 50 meter visueel overeenkomt met 10 pixels op het scherm, dan is de SSE = 10.</li> <li>Als je een maximum SSE van bijvoorbeeld 8 pixels hanteert, dan weet je: deze tegel moet worden vervangen door zijn   kinderen, want hij is niet precies genoeg.</li> </ul> <p>Bepalen van de juiste LOD</p> <p>De <code>TileSelector</code> gebruikt onderstaande logica om te bepalen of een tegel voldoende detail biedt:</p> <ol> <li>Bepaal het dichtstbijzijnde punt van de bounding volume van de tegel ten opzichte van de camera.</li> <li>Bereken de afstand van de camera tot dit punt, aangeduid als <code>distanceToCamera</code>.</li> <li>Bereken de screen space error (SSE) met de formule:</li> </ol> <pre><code>SSE = (geometricError / distanceToCamera) * schermProjectieFactor\n</code></pre> <p>In ons systeem is de <code>schermProjectieFactor</code> altijd 1. Dit betekent dat deze vermenigvuldiging in de praktijk kan    worden weggelaten, waardoor de vereenvoudigde formule in code vaak als volgt wordt gebruikt:</p> <pre><code>SSE = geometricError / distanceToCamera\n</code></pre> <ol> <li>Vergelijk met de ingestelde drempelwaarde <code>maximumScreenSpaceError</code>:<ul> <li>Als <code>SSE &gt; maximumScreenSpaceError</code>: de tegel is niet gedetailleerd genoeg \u2192 zoom in naar kindtegels.</li> <li>Als <code>SSE &lt;= maximumScreenSpaceError</code>: deze tegel is voldoende \u2192 toon deze en stop het inzoomen.</li> </ul> </li> </ol> <p>Let op: als <code>distanceToCamera</code> bijna nul is (bijvoorbeeld als de camera zich binnen de bounding volume van een tegel bevindt), dan wordt de SSE oneindig groot. In dat geval wordt de SSE behandeld als <code>float.MaxValue</code>.</p>"},{"location":"docs/developers/tilekit/tegelsysteem/#mapping","title":"Mapping","text":"<p>Dit hoofdstuk is nog in ontwikkeling.</p> <p></p> <ul> <li>Tegels mogen pas \"InView\" als een change succesvol afgemeld is</li> <li>Tegel GameObjecten kunnen er al zijn voordat een Tegel in view is; dan kan een Change nog pending zijn</li> <li>Als een dergelijke change geannuleerd wordt; dan moet het gameobject opgeruimd worden<ul> <li>Ergo: Changes moeten een Cancel mogelijkheid hebben, die een contra actie/opruim actie uitvoert</li> </ul> </li> <li>Een Tegel kent een aantal dingen<ul> <li>de \"Tile\" definitie uit de TileSet</li> <li>de Tegeldata - zoals de GeoJSON - die uit een WFS ingeladen is</li> <li>een visualisatie - zoals een GameObject of PolygonVisualiser?</li> </ul> </li> </ul>"},{"location":"docs/developers/tilekit/tegelsysteem/#verversen-van-tegels","title":"Verversen van tegels","text":"<p>Externe factoren, zoals styling of filtering, kunnen reeds ingeladen tegels be\u00efnvloeden. Wanneer dit gebeurd is het nodig om tegels te kunnen verversen.</p> <p>Om dit te kunnen doen, is het nodig dat een tegel gemarkeerd kan worden als Dirty. Dit geeft aan dat een tegel zijn staat moet terugbrengen naar de \"primaire staat\" - zoals deze ontvangen was van de brondata - en dan opnieuw alle aanpassingen toepast, zoals Styling of Filtering.</p> <p>De volgende voorwaarden zijn hierbij van belang:</p> <ul> <li>Dit gebeurt niet onmiddellijk, maar op zijn minst 1 frame later -of zelfs langer- zodat niet   onnodig bewerkingen uitgevoerd worden.</li> <li>Het verversen van een enkele tegel is een synchroon proces zodat er geen verstoring voor de gebruikersbeleving.</li> </ul> <p>Als een ingrijpendere wijziging nodig is, dan moet de tegel vervangen worden middels een ChangeSet zodat de oude tegel in beeld blijft en een nieuwe tegel asynchroon wordt aangemaakt.</p>"},{"location":"docs/developers/tilekit/tegelsysteem/#datamodel","title":"Datamodel","text":"<p>Todo</p> <p>Kijk naar https://github.com/CesiumGS/3d-tiles/blob/main/specification/ImplicitTiling/README.adoc#availability om na te gaan of er een betere manier is om de ID van een tegel te bepalen middels de Morton Z-order curve.</p> <pre><code>classDiagram\n    class Tileset {\n        + Tile Root\n    }\n\n    class Tile {\n        Guid Id\n        BoundingVolume BoundingVolume\n        double GeometricError\n        TileContents Contents\n        Matrix4x4 Transform\n        Metadata Metadata\n        Tiles Children\n        ImplicitTilingScheme ImplicitTiling = None\n        MethodOfRefinement Refine = MethodOfRefinement.Replace\n    }\n\n    class Tiles {\n\n    }\n\n    class TileContents {\n\n    }\n\n    class BoundingVolume {\n        + Vector3Double Center\n        + Vector3Double Size\n\n        + BoundsDouble ToBounds()\n    }\n\n    namespace BoundingVolumes {\n        class BoxBoundingVolume\n        class SphereBoundingVolume\n        class RegionBoundingVolume\n    }\n\n\n    class TileContent {\n        TemplatedUri Uri\n        BoundingVolume BoundingVolume\n        Metadata Metadata\n    }\n\n    class Metadata {\n    }\n\n    class ImplicitTilingScheme {\n        + SubdivisionScheme SubdivisionScheme\n        + int SubtreeLevels\n        + int AvailableLevels\n        + TemplatedUri Subtrees\n    }\n\n    namespace ImplicitTilingSchemes {\n        class None {\n        }\n\n        class UniformGrid {\n            + Dimensions Dimensions\n        }\n\n        class QuadTree {\n            + int SubtreeLevels\n            + int AvailableLevels\n        }\n\n        class OcTree {\n            + int SubtreeLevels\n            + int AvailableLevels\n        }\n    }\n\n    class MethodOfRefinement {\n        Replace\n        Add\n    }\n\n    class SubdivisionScheme {\n        UniformGrid\n        QuadTree\n        Octree\n    }\n\n    &lt;&lt;Enumeration&gt;&gt; MethodOfRefinement\n    &lt;&lt;Enumeration&gt;&gt; SubdivisionScheme\n    &lt;&lt;Abstract&gt;&gt; BoundingVolume\n    &lt;&lt;Abstract&gt;&gt; ImplicitTilingScheme\n\n    Metadata --|&gt; Dictionary~string, string~\n    BoundingVolume &lt;|-- BoxBoundingVolume\n    BoundingVolume &lt;|-- RegionBoundingVolume\n    BoundingVolume &lt;|-- SphereBoundingVolume\n    ImplicitTilingScheme &lt;|-- None\n    ImplicitTilingScheme &lt;|-- UniformGrid\n    ImplicitTilingScheme &lt;|-- QuadTree\n    ImplicitTilingScheme &lt;|-- OcTree\n\n    Tileset \"1\" *-- \"1\" Tile : Has\n    Tile \"1\" *-- \"1\" BoundingVolume : Affects\n    Tile \"1\" *-- \"1\" TileContents : Has\n    TileContents \"1\" *-- \"0..*\" TileContent : Contains\n    Tile \"1\" *-- \"1\" Metadata : Is described by\n    Tile \"1\" *-- \"1\" Tiles : Has\n    Tiles \"1\" *-- \"0..*\" Tile : Contains\n    Tile \"1\" *-- \"0..1\" ImplicitTilingScheme : Can have\n    Tile \"1\" *-- \"1\" MethodOfRefinement : Will interact with parent by\n    TileContent \"1\" *-- \"1\" BoundingVolume : Affects\n    TileContent \"1\" *-- \"1\" Metadata : Is described by\n    TileContent \"1\" ..&gt; \"0..1\" Tileset : Can import external tileset\n    ImplicitTilingScheme \"1\" *-- \"1\" SubdivisionScheme : Is subdivided as</code></pre> <ul> <li>TileContent mag ook verwijzen naar een externe tileset: https://docs.ogc.org/cs/22-025r4/22-025r4.html#core-external-tilesets</li> </ul>"},{"location":"docs/developers/tilekit/tegelsysteem/#services","title":"Services","text":"<pre><code>classDiagram\n    class TileMapper {\n        + Load(TileSet tileSet)\n        + Stage()\n        + Commit()\n    }\n\n    class ComposableTileMapper {\n        TileSelector TileSelector\n        ChangeScheduler ChangeScheduler\n        TileRenderer TileRenderer\n    }\n\n    class LegacyCartesianTilesTileMapper {\n    }\n\n    class Legacy3DTilesTileMapper {\n    }\n\n    class TileSelector {\n        + Select()\n    }\n\n    class TileRenderer {\n        + Add()\n        + Replace()\n        + Remove()\n    }\n\n    class ChangeScheduler {\n        ChangePlan ChangePlan\n\n        + Schedule()\n        + Apply()\n    }\n\n    class ImmediateChangeScheduler {\n    }\n\n    class ChangePlan {\n        List~Change~ Changes\n\n        + Plan()\n        + FindByTile\n        + Cancel\n    }\n\n    class Change {\n        StatusOfChange Status\n        TypeOfChange Type\n        ChangeAction Action\n        Tile Tile\n\n        Action~Change~ Planned\n        Action~Change~ Triggered\n        Action~Change~ Cancelled\n        Action~Change~ Completed\n\n        + bool IsPending\n        + bool InProgress\n        + bool IsCancelled\n        + bool IsCompleted\n\n        + Plan()\n        + Trigger()\n        + Cancel()\n        + Complete()\n        + UsingAction()\n        + Add()$\n        + Remove()$\n    }\n\n    class ChangeSet {\n        + Changes()\n    }\n\n    class TypeOfChange {\n        Add\n        Remove\n    }\n\n    class StatusOfChange {\n        Pending\n        InProgress\n        Cancelled\n        Completed\n    }\n\n    &lt;&lt;MonoBehaviour&gt;&gt; TileMapper\n    &lt;&lt;ScriptableObject&gt;&gt; TileSelector\n    &lt;&lt;ScriptableObject&gt;&gt; ChangeScheduler\n    &lt;&lt;Enumeration&gt;&gt; StatusOfChange\n    &lt;&lt;Enumeration&gt;&gt; TypeOfChange\n\n    ImmediateChangeScheduler --|&gt; ChangeScheduler\n    TileMapper &lt;|-- ComposableTileMapper\n    TileMapper &lt;|-- LegacyCartesianTilesTilesetRenderer\n    TileMapper &lt;|-- Legacy3DTilesTilesetRenderer\n\n    note for TileMapper \"Selects the Tiles in view, \n        stages these tiles by passing to the ChangePlan \n        which tiles need to be added, removed or replaced\"\n    note for TileMapper \"Can also be a wrapper around legacy \n        tile handlers, in which case nothing further of the new \n        system is used\"\n\n    TileMapper o-- \"1\" TileSet\n    ComposableTileMapper *-- \"1\" TileSelector\n    ComposableTileMapper *-- ChangeScheduler\n    ComposableTileMapper *-- TileRenderer\n    ChangeScheduler *-- ChangePlan\n    ChangePlan *-- \"*\" Change\n    ChangePlan *-- \"*\" ChangeSet\n    ChangeSet o-- Change\n    Change *-- TypeOfChange\n    Change *-- StatusOfChange\n    Change o-- Tile\n</code></pre> <p>Projector has been omitted from the scheme above because I need to think about it</p> <p>Middlewares for styling need to be added</p>"},{"location":"docs/developers/ui/introduction/","title":"Introduction","text":"<p>Welcome to the foundational section of our technical documentation, where we introduce the user interface (UI) design system of Netherlands3D. This documentation is crafted to guide developers, designers, and contributors through the  design architecture that shapes the user experience within our digital twin environment.</p>"},{"location":"docs/developers/ui/introduction/#purpose-of-the-design-system","title":"Purpose of the Design System","text":"<p>The design system serves as a comprehensive framework that harmonizes UI design and development, ensuring consistency, scalability, and efficiency across the application. It is the blueprint that orchestrates the visual and interactive elements, making the digital twin not only a technological marvel but also an intuitive and engaging experience for users.</p>"},{"location":"docs/developers/ui/introduction/#overview-of-the-ui-design-system","title":"Overview of the UI Design System","text":"<p>At the heart of our UI design system are two fundamental concepts: Blocks and Components. These elements are the building blocks of our application's interface, structured to offer clarity and flexibility in design and implementation. Inspired by the BEM (Block, Element, Modifier) methodology, our system disambiguates between blocks and components to streamline the development process and enhance the UI's modularity and reusability.</p>"},{"location":"docs/developers/ui/introduction/#blocks","title":"Blocks","text":"<p>Blocks are the larger, more general sections of the UI that function as the containers for components. They define the structural layout and set the stage for the detailed elements within. Blocks can be as broad as the entire application window or as specific as a user interaction panel.</p>"},{"location":"docs/developers/ui/introduction/#components","title":"Components","text":"<p>Components, on the other hand, are the more granular, reusable elements that reside within blocks. They are the nuts and bolts of the UI, encompassing buttons, sliders, text fields, and other interactive elements. Components are designed with flexibility in mind, allowing them to be adapted and reused across different blocks.</p>"},{"location":"docs/developers/ui/introduction/#objectives-of-this-documentation","title":"Objectives of This Documentation","text":"<p>The subsequent chapters of this documentation are dedicated to diving deeper into the specifics of blocks and components, outlining their characteristics, how they are designed, and how they interact within the UI framework of our digital twin platform. Our goals are to:</p> <ul> <li>Clarify the distinction between blocks and components, providing a clear understanding of their roles within the   UI design system.</li> <li>Guide the design and development process, offering insights into best practices for creating and integrating   blocks and components.</li> <li>Facilitate scalability and customization, enabling developers and designers to extend the UI efficiently and   creatively.</li> </ul> <p>As we proceed, this documentation will serve as a reference for enhancing and expanding the user interface of  Netherlands3D, ensuring that the developers and designers within the ecosystem are aligned.</p> <p>In the next chapter, we will explore the concept of blocks in detail, examining their structure, functionality, and how they contribute to the overall user experience of the application.</p>"},{"location":"docs/developers/ui/understanding-blocks/","title":"Understanding Blocks","text":"<p>In the Netherlands3D platform, our design system is structured for clear organization and effective scaling. Blocks form the fundamental part of this structure, acting as the primary containers for the interface's elements. This chapter focuses on blocks, explaining their purpose, features, and their role in creating a unified user experience in Netherlands3D.</p>"},{"location":"docs/developers/ui/understanding-blocks/#what-are-blocks","title":"What Are Blocks?","text":"<p>Blocks are the large-scale elements of our UI design system. They serve as the main sections that organize and contain various components. Think of blocks as the framework of a building, providing structure and defining the layout within our digital environment. In Netherlands3D, blocks have specific functions, such as guiding navigation, displaying information, facilitating user interactions, or showcasing data visually.</p>"},{"location":"docs/developers/ui/understanding-blocks/#features-of-blocks","title":"Features of Blocks","text":"<ul> <li> <p>Modular: Blocks are designed as self-contained units that can be mixed and matched in different layouts, offering   flexibility and reuse across the platform.</p> </li> <li> <p>Scalable: They are built to support the platform's growth, making it easy to add new features or adapt to changing   user needs without disrupting the existing design.</p> </li> <li> <p>Consistent: Despite their variety, blocks maintain a unified design language and user experience across   Netherlands3D.</p> </li> </ul>"},{"location":"docs/developers/ui/understanding-blocks/#designing-blocks","title":"Designing Blocks","text":"<p>Creating blocks for Netherlands3D requires attention to:</p> <ul> <li> <p>User Needs: Design each block with the user's requirements in mind, ensuring it fulfills its intended purpose   effectively.</p> </li> <li> <p>Adaptability: Make blocks adaptable for different types of content and scenarios within the platform.</p> </li> </ul>"},{"location":"docs/developers/ui/understanding-blocks/#managing-blocks","title":"Managing Blocks","text":"<p>The evolution of Netherlands3D involves regular updates to blocks, including additions, removals, or modifications. This process entails:</p> <ol> <li> <p>Planning: Identifying the need based on user feedback or new functionalities.</p> </li> <li> <p>Design and Development: Crafting the block to fit Netherlands3D's design norms and technical specifications.</p> </li> <li> <p>Testing: Ensuring compatibility and performance across devices.</p> </li> <li> <p>Implementation: Incorporating the block into Netherlands3D and monitoring its effectiveness.</p> </li> </ol>"},{"location":"docs/developers/ui/understanding-blocks/#distinction-between-blocks-and-components","title":"Distinction Between Blocks and Components","text":"<p>Blocks and components are fundamental elements of the Netherlands3D UI, but they serve distinct purposes.</p> <p>Blocks are the overarching sections that structure and organize the user interface, similar to the chapters in a book. They are designed for flexibility, accommodating a variety of components to fulfill different functionalities within the platform. Blocks ensure a consistent layout and design language across Netherlands3D, providing a cohesive user experience.</p> <p>Components, on the other hand, are the detailed, interactive or static elements such as buttons, text fields, and sliders that reside within blocks. These elements are highly customizable and reusable, designed to perform specific functions or convey particular information. Components depend on blocks for context and placement, but their modularity allows them to be used in multiple scenarios across the platform.</p> <p>The primary distinction lies in their scale and function: blocks form the UI's structural foundation, while components populate these structures with content and interactivity. Understanding this difference is crucial for efficient design and development within Netherlands3D, ensuring a robust and user-friendly interface.</p>"},{"location":"docs/developers/ui/understanding-blocks/#conclusion","title":"Conclusion","text":"<p>Blocks are foundational to the Netherlands3D UI design system, offering the structural basis for our digital twin platform. By leveraging blocks effectively, we can ensure a robust, user-friendly interface that reflects the innovative spirit of digital twin technology.</p> <p>The following chapter will detail the components within these blocks, including their design and role in enhancing the interactive experience of Netherlands3D.</p>"},{"location":"docs/developers/ui/understanding-components/","title":"Understanding Components","text":"<p>In this chapter, we delve deeper into the essence of components\u2014the dynamic and interactive elements that enable users to engage with the Netherlands3D platform effectively. Components are the individual pieces of the user interface, such as buttons, sliders, dropdown menus, and data visualization charts, which users interact with directly.</p>"},{"location":"docs/developers/ui/understanding-components/#what-are-components","title":"What Are Components?","text":"<p>Components are the versatile and interactive building blocks housed within the UI's structural blocks. They range from  input fields (where users can enter data), buttons (like 'Submit' or 'Cancel'), sliders (for adjusting settings or zoom levels), to more complex elements such as the minimap (allowing users to explore).</p>"},{"location":"docs/developers/ui/understanding-components/#features-of-components","title":"Features of Components","text":"<ul> <li> <p>Reusability: Designed for reuse, components like toggle switches for on/off settings ensure consistency and    streamline development across Netherlands3D.</p> </li> <li> <p>Customization: Components can be tailored for different informational purposes to adhere to the specific aesthetic    of the platform.</p> </li> <li> <p>Interactivity: Interactive components, such as accordions, for customization features or detailed content    display, to engage users directly, offering a dynamic experience.</p> </li> </ul>"},{"location":"docs/developers/ui/understanding-components/#designing-components","title":"Designing Components","text":"<p>The design of components focuses on the user's needs, aiming for clarity, efficiency, and aesthetic harmony:</p> <ul> <li> <p>User-Centric Design: Components are crafted to be intuitive and accessible for easy   navigation or with validation to guide user input.</p> </li> <li> <p>Aesthetic Consistency: Despite their diversity, components maintain the Netherlands3D's cohesive design language, </p> </li> <li>reinforcing brand identity.</li> </ul>"},{"location":"docs/developers/ui/understanding-components/#managing-components","title":"Managing Components","text":"<p>The lifecycle of components in Netherlands3D involves continuous evaluation and refinement:</p> <ol> <li> <p>Identification of Needs: New functionalities might require the development of novel components interaction with     the 3D environment or its data.</p> </li> <li> <p>Rigorous Testing: Components undergo extensive testing.</p> </li> <li> <p>Iterative Improvement: Feedback might lead to the evolution of components, such as enhancing them    for better data visualization or for improved usability.</p> </li> </ol>"},{"location":"docs/developers/ui/understanding-components/#conclusion","title":"Conclusion","text":"<p>Components are vital for the interactive and functional richness of the Netherlands3D platform. Each component plays a  crucial role in engaging users and facilitating a smooth experience. Through careful design and management, components  ensure Netherlands3D remains an intuitive, efficient, and visually appealing platform.</p>"},{"location":"docs/developers/ui/blocks/property-panel-and-sections/","title":"Properties","text":""},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#design","title":"Design","text":""},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#usage","title":"Usage","text":"<p>The \"Properties\" block in Netherlands3D serves as a critical interface element, allowing users to interact with and modify the attributes of various layers within the application. This documentation provides insights into the design considerations and implementation strategies for this block, ensuring a seamless integration within the Netherlands3D platform.</p> <p>This block enables users to access and adjust the transformation properties (position, rotation, scale) of selected 3D objects or layers. Additionally, it provides access to specific attributes for certain objects, such as Windmills, which may include properties like axis height or rotor diameter.</p> A screenshot of a windmill with an open properties panel"},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#anatomy","title":"Anatomy","text":"Anatomical breakdown of the properties block <p>The Properties panel is constructed using a Card component, organized into several key areas for intuitive user interaction:</p> <ol> <li>Card: The overarching container for the Properties panel, designed for clarity and    cohesion.</li> <li>Card Header: Displays the Properties icon and the term \"Eigenschappen,\" indicating the    panel's purpose.</li> <li>Section: Each layer or object type, such as Windmills, has its dedicated section within the card.</li> <li>Section Header: Identifies the specific layer or object type, e.g., \"Windmolen\" for Windmills, guiding users to the    relevant properties.</li> <li>Section Content: Contains form elements for adjusting the specific properties of the selected layer or object. This    area is designed for direct interaction, allowing users to modify attributes like axis height or rotor diameter.</li> </ol>"},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#design-principles","title":"Design Principles","text":"<ul> <li>Clarity: The use of a card-based layout ensures that the Properties panel is easily navigable and understandable,   with distinct sections for different layers or objects.</li> <li>Consistency: Maintaining a uniform structure across different sections ensures that users have a cohesive   experience, regardless of the variety of objects or layers they interact with.</li> <li>Immediate Feedback: Interactions within the Properties panel are designed to provide immediate visual feedback in   the Netherlands3D environment, emphasizing the panel's role in direct manipulation of objects and layers.</li> </ul>"},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#interaction","title":"Interaction","text":"<p>Users interact with the Properties panel by selecting an object or layer within the Netherlands3D platform, and clicking on the properties button with that layer.</p> <p>Upon opening, the panel updates to display the relevant sections for the chosen item. Adjustments made within the form elements of a section are immediately applied, allowing users to see the effects of their changes in real-time. This design supports a tactile and intuitive experience, encouraging exploration and modification within the digital twin environment.</p>"},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#implementation","title":"Implementation","text":""},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#overview","title":"Overview","text":"<p>The Properties panel's functionality in the Netherlands3D platform is achieved through a combination of Unity prefabs and scripting. This implementation ensures dynamic interaction within the UI, allowing for the seamless addition of properties sections based on the selected layer or object.</p>"},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#prefab-structure","title":"Prefab Structure","text":"<ul> <li> <p>Main Properties Prefab: The core of the Properties panel, this prefab is a part of the default canvas and acts as   the container for all dynamically added sections.</p> </li> <li> <p>Section Prefabs: Individual prefabs for each type of section (e.g., Windmill properties) that can be instantiated   within the main Properties panel.</p> </li> </ul>"},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#scripting-and-interfaces","title":"Scripting and Interfaces","text":""},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#ipropertysection-interface","title":"IPropertySection Interface","text":"<p>An essential element in the dynamic nature of the Properties panel is the <code>IPropertySection</code> interface. This interface allows for the detection and instantiation of properties sections based on the presence of specific MonoBehaviours within a layer's prefab.</p> <ul> <li> <p>Detection and Instantiation: A script running in the layer system detects MonoBehaviours that implement   the <code>IPropertySection</code> interface on a layer's prefab being added to the scene. Upon detection, the <code>AddToProperties</code>   method of the interface is called.</p> </li> <li> <p>Factory Behavior: Implementations of the <code>IPropertySection</code> can act as factories, instantiating the appropriate   section prefab and adding it to the Properties panel as a \"slot\". The <code>AddToProperties</code> method is being provided with   the properties content area to which the section can be added.</p> </li> </ul>"},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#addtoproperties-method","title":"AddToProperties Method","text":"<p>The <code>AddToProperties</code> method is where the logic for instantiating the section prefab and integrating it into the Properties panel is defined. This method allows for flexibility in the UI, permitting custom designs per section while adhering to the overall design guidelines.</p> <p>Example</p>"},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#example-windmill-property-section","title":"Example: Windmill Property Section","text":"<p>The Windmolen prefab, used for the Windmill implementation in the Object Library, includes a MonoBehaviour named <code>WindmillPropertySectionInstantiator</code> that demonstrates this system in action.</p> <ul> <li> <p>Functionality: The <code>WindmillPropertySectionInstantiator</code> responds to the addition of a Windmill object and   instantiates a dedicated section within the Properties panel. This section is specifically designed to bind and   display the properties of the windmill, such as axis height or rotor diameter.</p> </li> <li> <p>Binding: The script binds the windmill's data to the instantiated section, ensuring that any adjustments made     within the Properties panel are immediately reflected in the windmill's properties within the scene.</p> </li> </ul>"},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#implementation-steps","title":"Implementation Steps","text":"<p>Given an existing layer's prefab:</p> <p>Implement the IPropertySection interface: For each layer requiring a properties section, create a MonoBehaviour  that implements <code>IPropertySection</code> and defines how its section prefab should be instantiated and added to the  Properties panel.</p>"},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#design-adherence","title":"Design Adherence","text":"<p>While implementing sections, it's crucial to adhere to the established design rules to maintain consistency across the Properties panel. However, the flexibility of this system allows for the introduction of unique UI elements where necessary to better represent specific properties.</p>"},{"location":"docs/developers/ui/components/accordion/","title":"Accordion","text":""},{"location":"docs/developers/ui/components/accordion/#design","title":"Design","text":""},{"location":"docs/developers/ui/components/accordion/#usage","title":"Usage","text":"<p>The Accordion component in the Netherlands3D platform is a versatile UI element designed to efficiently manage and display hierarchical content in a compact form. Featuring a title, an optional label, and a toggle mechanism indicated by a chevron, the Accordion allows for an organized presentation of content sections, each with its dedicated header to signify its integration within the Accordion. This component is ideal for:</p> <ul> <li> <p>Settings Menus: Grouping related settings or options to streamline user navigation, such as layer property sections.</p> </li> <li> <p>Grouping Content: Grouping related content to focus on related information, such as quality indicator dossiers.</p> </li> <li> <p>Interactive FAQs: Presenting frequently asked questions in a concise, expandable format.</p> </li> </ul>"},{"location":"docs/developers/ui/components/accordion/#modes-of-operation","title":"Modes of Operation","text":"<ol> <li> <p>Fixed Mode: This mode locks the Accordion in an always-open state, without the option to collapse or expand. The    absence of a chevron signifies its static nature.</p> </li> <li> <p>Multiple Open Mode: Allows for multiple Accordions within a group to be opened or closed independently. The chevron    points up when opened, indicating a \"roll-up\" action, and down when closed, suggesting a \"roll-down\" action.</p> </li> <li> <p>Single Open Mode: In a group of Accordions, only one can be open at a time. Opening another Accordion automatically    closes the previously open one. This mode features a chevron pointing down when closed; and when open, the chevron is    hidden, supplemented by an additional outline to highlight the Accordion is considered to be an active -or selected-    Accordion.</p> </li> </ol>"},{"location":"docs/developers/ui/components/accordion/#anatomy","title":"Anatomy","text":"Anatomical breakdown of the Accordion component <ol> <li> <p>Title: A text representative of the Accordion's content.</p> </li> <li> <p>Icon (Optional): Provides additional context or classification.</p> </li> <li> <p>Expand/Contract Toggle (Optional): A chevron-based toggle mechanism indicating the Accordion's state and     possible actions.</p> </li> <li> <p>Content Section: The expandable area containing detailed content or components.</p> </li> <li> <p>Content Header: A header within the content section styled specifically to emphasize its connection to the     Accordion.</p> </li> </ol>"},{"location":"docs/developers/ui/components/accordion/#design-principles","title":"Design Principles","text":""},{"location":"docs/developers/ui/components/accordion/#title-and-icon","title":"Title and Icon","text":"<p>The title provides a succinct summary of the content contained within the Accordion, while the optional icon offers  additional context or categorization.</p> <p>Both elements are designed to be immediately visible to enhance usability and guide the user's navigation through the  content sections.</p>"},{"location":"docs/developers/ui/components/accordion/#expandcontract-toggle","title":"Expand/Contract Toggle","text":"<p>The Expand/Contract Toggle includes a chevron symbol that visually communicates the Accordion's state and possible  actions to the user. The direction of the chevron indicates the effect of the interaction (down for roll-down, up for  roll-up).</p> <p>The toggle may be absent when there is no action available, as can be the case for the fixed mode of operation or when no roll-up is provided because one element always needs to be open.</p>"},{"location":"docs/developers/ui/components/accordion/#content-section","title":"Content Section","text":"<p>The content section beneath each Accordion title is designed for expandability, housing detailed information or  additional UI components.</p> <p>Optionally, a specific header within the content section further emphasizes its association with the Accordion.</p>"},{"location":"docs/developers/ui/components/accordion/#best-practices","title":"Best Practices","text":"<ul> <li> <p>Clarity: Ensure the title and label (if used) are clear and informative, guiding the user's understanding of the   content within.</p> </li> <li> <p>Intuitive Interaction: Design the Expand Toggle for easy recognition and interaction, with chevron icons that   intuitively indicate the possible actions.</p> </li> <li> <p>Consistency: Maintain visual and functional consistency across all Accordion components, especially within groups   operating in multiple or single open modes.</p> </li> </ul>"},{"location":"docs/developers/ui/components/accordion/#implementation","title":"Implementation","text":"<p>Info</p> <p>As of writing, there is no component in Unity available to provide the Accordion component. This part of the  documentation should be updated as soon as one is available.</p>"},{"location":"docs/developers/ui/components/cards/","title":"Cards","text":""},{"location":"docs/developers/ui/components/cards/#usage","title":"Usage","text":"<p>Cards are surfaces that display content and actions on a single topic.</p> <p>They should be easy to scan for relevant and actionable information. Elements, like text and images, should be placed on them in a way that clearly indicates hierarchy.</p>"},{"location":"docs/developers/ui/components/cards/#anatomy","title":"Anatomy","text":"<p>Info</p> <p>The contents of this chapter need to be written </p>"},{"location":"docs/developers/ui/components/double-sliders/","title":"Double Slider","text":""},{"location":"docs/developers/ui/components/double-sliders/#design","title":"Design","text":""},{"location":"docs/developers/ui/components/double-sliders/#usage","title":"Usage","text":"<p>Similar to the slider component, the double slider component in the Netherlands3D platform provides  a graphical interface element enabling users to select a range between two values from a predefined scale.  Accompanied by two Text Fields, this component allows for both graphical adjustment and direct numerical input, ensuring a versatile and user-friendly experience. The main difference between the double slider and the regular slider is that the double slider has two handles and input fields, defining the minimum and maximum value of the range.</p>"},{"location":"docs/developers/ui/components/double-sliders/#immediate-effects","title":"Immediate effects","text":"<p>Changes made with double sliders are immediate, allowing the user to make slider adjustments while determining a selection. Sliders shouldn\u2019t be used to adjust settings with any delay in providing user feedback.</p>"},{"location":"docs/developers/ui/components/double-sliders/#current-state","title":"Current state","text":"<p>Sliders reflect the current state of the settings they control.</p>"},{"location":"docs/developers/ui/components/double-sliders/#anatomy","title":"Anatomy","text":"Anatomical breakdown of the double slider component <ol> <li>Slider Track: The horizontal line along which the double slider thumb moves, representing the range of possible values.</li> <li>Minimum Slider Thumb: The circular control that users drag to select the minimum value on the slider track.</li> <li>Minimum Text Field (Optional): Adjacent to the double slider, this field displays the currently selected minimum value and allows for manual    entry. It can be configured as readonly or omitted based on specific requirements.</li> <li>Maximum Slider Thumb: The circular control that users drag to select the maximum value on the slider track.</li> <li>Maximum Text Field (Optional): Adjacent to the double slider, this field displays the currently selected maximum value and allows for manual    entry. It can be configured as readonly or omitted based on specific requirements.</li> </ol>"},{"location":"docs/developers/ui/components/double-sliders/#implementation","title":"Implementation","text":"<p>This chapter guides you through adding the double slider prefab to your scene, configuring its behavior, and responding to user input.</p>"},{"location":"docs/developers/ui/components/double-sliders/#adding-the-slider-to-your-scene","title":"Adding the Slider to Your Scene","text":"<ol> <li> <p>Prefab Placement: Locate the double slider prefab in the project's asset directory. Drag and drop the prefab into your    scene or hierarchy where you need the slider component to appear.</p> </li> <li> <p>Initial Setup: By default, the double slider comes with linked Text Fields for numerical input. Together, they provide    a cohesive component for value selection.</p> </li> </ol>"},{"location":"docs/developers/ui/components/double-sliders/#configuring-the-slider","title":"Configuring the Slider","text":""},{"location":"docs/developers/ui/components/double-sliders/#listening-to-value-changes","title":"Listening to Value Changes","text":"<p>Use the Unity Editor to attach a listener function to the slider's <code>onMinValueChanged</code> and <code>onMaxValueChanged</code> events. These functions will be called whenever the slider's minimum or maximum value changes, respectively, whether through direct manipulation of the double slider or numerical entry in the Text Fields.</p>"},{"location":"docs/developers/ui/components/double-sliders/#customizing-the-text-field","title":"Customizing the Text Field","text":"<ul> <li> <p>Readonly Option: The <code>DoubleSlider</code> MonoBehaviour includes a <code>readonly</code> boolean. When set to true, the Text   Fields becomes readonly, allowing users to see the value but preventing manual entry. This is useful in situations   where you want to restrict input to slider manipulation only.</p> </li> <li> <p>Omitting the Text Field: If your use case does not require numerical input, you can deactivate the Text Fields   entirely. Simply set the Text Field GameObjects to inactive, and the double slider will automatically expand to fill the   space, maintaining the UI's visual continuity.</p> </li> </ul>"},{"location":"docs/developers/ui/components/sliders/","title":"Slider","text":""},{"location":"docs/developers/ui/components/sliders/#design","title":"Design","text":""},{"location":"docs/developers/ui/components/sliders/#usage","title":"Usage","text":"<p>The slider component in the Netherlands3D platform provides a graphical interface element enabling users to select a value or range from a predefined scale. Accompanied by a Text Field, this component allows for both graphical adjustment and direct numerical input, ensuring a versatile and user-friendly experience.</p>"},{"location":"docs/developers/ui/components/sliders/#immediate-effects","title":"Immediate effects","text":"<p>Changes made with sliders are immediate, allowing the user to make slider adjustments while determining a selection. Sliders shouldn\u2019t be used to adjust settings with any delay in providing user feedback.</p>"},{"location":"docs/developers/ui/components/sliders/#current-state","title":"Current state","text":"<p>Sliders reflect the current state of the settings they control.</p>"},{"location":"docs/developers/ui/components/sliders/#anatomy","title":"Anatomy","text":"Anatomical breakdown of the slider component <ol> <li>Slider Track: The horizontal line along which the slider thumb moves, representing the range of possible values.</li> <li>Slider Thumb: The circular control that users drag to select a value on the slider track.</li> <li>Text Field (Optional): Adjacent to the slider, this field displays the currently selected value and allows for manual    entry. It can be configured as readonly or omitted based on specific requirements.</li> </ol>"},{"location":"docs/developers/ui/components/sliders/#implementation","title":"Implementation","text":"<p>This chapter guides you through adding the slider prefab to your scene, configuring its behavior, and responding to user input.</p>"},{"location":"docs/developers/ui/components/sliders/#adding-the-slider-to-your-scene","title":"Adding the Slider to Your Scene","text":"<ol> <li> <p>Prefab Placement: Locate the slider prefab in the project's asset directory. Drag and drop the prefab into your    scene or hierarchy where you need the slider component to appear.</p> </li> <li> <p>Initial Setup: By default, the slider comes with a linked Text Field for numerical input. Together, they provide    a cohesive component for value selection.</p> </li> </ol>"},{"location":"docs/developers/ui/components/sliders/#configuring-the-slider","title":"Configuring the Slider","text":""},{"location":"docs/developers/ui/components/sliders/#listening-to-value-changes","title":"Listening to Value Changes","text":"<p>Use the Unity Editor to attach a listener function to the slider's <code>onValueChanged</code> event. This function will be called whenever the slider's value changes, whether through direct manipulation of the slider or numerical entry in the Text Field.</p>"},{"location":"docs/developers/ui/components/sliders/#customizing-the-text-field","title":"Customizing the Text Field","text":"<ul> <li> <p>Readonly Option: The <code>PropertySlider</code> MonoBehaviour includes a <code>readonly</code> boolean. When set to true, the Text   Field becomes readonly, allowing users to see the value but preventing manual entry. This is useful in situations   where you want to restrict input to slider manipulation only.</p> </li> <li> <p>Omitting the Text Field: If your use case does not require numerical input, you can deactivate the Text Field   entirely. Simply set the Text Field GameObject to inactive, and the slider will automatically expand to fill the   space, maintaining the UI's visual continuity.</p> </li> </ul>"},{"location":"docs/developers/ui/components/text-fields/","title":"Text Field","text":""},{"location":"docs/developers/ui/components/text-fields/#design","title":"Design","text":""},{"location":"docs/developers/ui/components/text-fields/#usage","title":"Usage","text":"<p>\"Text Fields\" in the Netherlands3D platform allow users to input or modify text information. They can be used singularly or in combination with other components like a Slider or Form Label in the Properties block. They're an essential part of Netherlands3D's user interface, providing users with interactive fields to enter or manipulate various properties.</p>"},{"location":"docs/developers/ui/components/text-fields/#parts","title":"Parts","text":"<p>The Text Field component comprises two main parts:</p> <ol> <li> <p>Form Label: The descriptive text associated with the Text Field, explaining what value is being manipulated. This    is a reusable part and can be shared with other components like the Slider.</p> </li> <li> <p>Form Field: It serves as the component for user text input or changing text information. It is styled to account    for different states like Idle, Focus, Pressing, and Read-Only.</p> </li> </ol>"},{"location":"docs/developers/ui/components/text-fields/#anatomy","title":"Anatomy","text":"<p>Note</p> <p>Add an image to showcase the anatomy of a form field and elaborate some more on this in the text</p> <ol> <li> <p>Form Label: Positioned above or adjacent to the Form Field, providing a textual description of the information    required or displayed.</p> </li> <li> <p>Form Field: The interactive text input area where users can enter or modify data. It transitions between various    states (Idle, Focus, Pressed, Read-only) to visually communicate its current mode of interaction.</p> </li> </ol>"},{"location":"docs/developers/ui/components/text-fields/#design-principles","title":"Design Principles","text":"<ul> <li> <p>Clarity: Labels are clear and informative, ensuring users understand what information is required.</p> </li> <li> <p>Feedback: Built-in states (Idle, Focused, Pressed, and Read-Only) provide immediate visual feedback to users,   aiding an interactive experience.</p> </li> </ul>"},{"location":"docs/developers/ui/components/text-fields/#implementation","title":"Implementation","text":"<p>The Text Field is modeled using Unity prefabs and scripting, offering dynamic interaction within the user interface, allowing for adaptive properties adjustment based on user input.</p>"},{"location":"docs/developers/ui/components/text-fields/#adding-a-text-field-to-your-scene","title":"Adding a Text Field to Your Scene","text":"<ul> <li>Prefab Placement: Locate the Text Field prefab in the project's asset directory. Drag and drop the prefab into your   scene where you need the Text Field component to appear.</li> </ul>"},{"location":"docs/developers/ui/components/text-fields/#configuring-the-text-field","title":"Configuring the Text Field","text":"<p>You can utilize the Unity Editor to add listener functions that get triggered on text value change events, enabling you to manipulate and use the user-input text as per application needs.</p>"},{"location":"docs/functionaliteiten/functionaliteiten-overzicht/","title":"Overzicht functies","text":"<p>Deze pagina bevat het overzicht van alle functies van de 3D-Viewer van Netherlands3D. Door op de functies te klikken kom je bij de gedetailleerde beschrijving en handleiding.</p>"},{"location":"docs/functionaliteiten/functionaliteiten-overzicht/#algemeen","title":"Algemeen","text":"<p>Gebied downloaden Locatie bepalen Object informatie Ondergrond doorzicht  Project openen/opslaan  Schermafbeelding maken Transformatietool Zonnestand simuleren </p>"},{"location":"docs/functionaliteiten/functionaliteiten-overzicht/#navigeren","title":"Navigeren","text":"<p>Minimap Orthografisch/perspectief Positie Weergave naar noorden draaien First Person Viewer</p>"},{"location":"docs/functionaliteiten/functionaliteiten-overzicht/#toevoegen","title":"Toevoegen","text":"<p>3D Tiles Google foto-realistische wereld Importeren - bestand via URL Importeren - eigen bestand Objecten bibliotheek Tekengebied - Lijn  Tekengebied - Polygoon  UrbanReLeaf Sensor Data Verspreid objecten in tekengebied Polygoon  </p>"},{"location":"docs/functionaliteiten/functionaliteiten-overzicht/#instellingen","title":"Instellingen","text":"<p>Bomen en bospercelen Buurtnamen Gebouwen - 3D BAG Gebouwen kleuren Indicatoren Kwaliteit Limiteer scroll gevoeligheid Straatnamen Terrein - kadaster Wijknamen </p>"},{"location":"docs/functionaliteiten/wat-is-netherlands3d/","title":"Wat is Netherlands3D?","text":"<p>Netherlands3D is een interactieve 3D-omgeving waarmee je de fysieke wereld digitaal kunt verkennen. Of je nu een stad, een projectgebied of een specifiek object wilt bekijken, de viewer biedt een intu\u00eftieve manier om ruimtelijke gegevens te ontdekken en te combineren.</p> <p>Met Netherlands3D kun je:</p> <ul> <li>Gedetailleerde 3D-modellen bekijken van gebouwen, infrastructuur en landschap.</li> <li>Je eigen gegevens toevoegen, zoals kaarten, lagen of modellen.</li> <li>De uitslagen van metingen en analyses inladen en combineren met andere databronnen voor een compleet en   ge\u00efntegreerd beeld.</li> <li>Complexe informatie begrijpelijk presenteren, door verschillende databronnen visueel te combineren in een   toegankelijke 3D-weergave.</li> </ul> <p>Wat Netherlands3D uniek maakt, is dat jij als gebruiker bepaalt welke data je visualiseert en welke functionaliteiten je inzet. Geen vaste lijsten met vooraf gedefinieerde kaartlagen, maar flexibele koppelingen naar databronnen en applicaties die aansluiten op jouw project. Denk aan gegevens van je eigen organisatie, het landelijke dataloket PDOK of dataportalen van gemeenten en provincies.</p> <p>De viewer is ontworpen voor professionals \u00e9n nieuwsgierige gebruikers die meer willen weten over hun omgeving. Alles werkt direct in je browser, zonder dat je extra software hoeft te installeren.</p> <p>Wil je aan de slag? Bekijk de handleiding en ontdek de mogelijkheden van Netherlands3D!</p>"},{"location":"docs/handleiding/","title":"Overzicht van de functionaliteiten","text":"<p>Op de homepage is algemene informatie over het Netherlands 3D project te vinden. Naast de handleiding bieden we specifiek voor twee doelgroepen informatie aan: voor organisaties/gebruikers en ontwikkelaars. Op deze pagina vind je de belangrijkste functionaliteiten van de homepage en de gebruikersinterface.    </p>"},{"location":"docs/handleiding/#overzicht-van-functionaliteiten","title":"Overzicht van functionaliteiten","text":"<p>De homepage van Netherlands3d.eu biedt toegang tot de verschillende hoofdstukken en functionaliteiten. </p>"},{"location":"docs/handleiding/#gedetailleerde-beschrijving-van-de-functionaliteiten","title":"Gedetailleerde beschrijving van de functionaliteiten","text":""},{"location":"docs/handleiding/#hoofdmenubalk","title":"Hoofdmenubalk","text":"<p> (Afbeelding) Hoofdmenubalk</p>"},{"location":"docs/handleiding/#functionaliteiten","title":"Functionaliteiten","text":"<p> (Afbeelding) Dark/Light modus</p>"},{"location":"docs/handleiding/#voor-organisaties","title":"Voor organisaties","text":"<p>Dit hoofdstuk is onder ontwikkeling en bevat straks een uitgebreide bron van informatie. Het doel is om organisaties te ondersteunen met gidsen, best practices en antwoorden op veel gestelde vragen die essentieel zijn voor het gebruik van het Netherlands3D platform. </p>"},{"location":"docs/handleiding/#voor-ontwikkelaars","title":"Voor ontwikkelaars","text":"<p>Ben je een ontwikkelaar en wil je bijvoorbeeld eigen functionaliteiten binnen Netherlands 3D ontwikkelen? Dan vindt je in dit hoofdstuk de benodigde technische documentatie. Deze documentatie is bedoeld voor ontwikkelaars die willen begrijpen hoe het platform werkt, de architectuur willen verkennen en nieuwe modules of functionaliteiten willen bijdragen.</p>"},{"location":"docs/handleiding/#handleiding","title":"Handleiding","text":"<p>In het hoofdstuk Handleiding vind je een gedetailleerde beschrijving van alle functionaliteiten ondersteund met afbeeldingen en/of filmpjes. </p>"},{"location":"docs/handleiding/#schermmodus","title":"Schermmodus","text":"<p>Door op het <code>Schermmodus-icoon</code> te klikken kan de interface kan de modus veranderd worden in <code>Dark</code>; lichte tekst op een donkere achtergrond of <code>Light</code>; donkere tekst op een lichte achtergrond. In de Dark modus gebruikt het systeem minder energie en hoeft het systeem in het geval van een laptop minder snel te worden opgeladen.</p>"},{"location":"docs/handleiding/#zoeken","title":"Zoeken","text":"Deze zoekfunctie biedt de mogelijkheid om naar trefwoorden te zoeken binnen Netherlands3D.eu. Vul de zoekterm(en) in bij <code>Zoeken</code> en de lijst met klikbare resultaten wordt in de context (hoofdstuk en alinea) getoond."},{"location":"docs/handleiding/#headline","title":"Headline","text":"<p> (Afbeelding) Headline</p>"},{"location":"docs/handleiding/#bekijk-de-viewer","title":"Bekijk de viewer","text":"<p>Met de knop <code>Bekijk de viewer</code> in de headline wordt de 3D-viewer functionaliteit gestart. (Zie 3D-viewer functionaliteit  voor de beschrijving.)  </p>"},{"location":"docs/handleiding/#wat-is-het","title":"Wat is het","text":"<p>Met de knop <code>Wat is het?</code> wordt de tekst \u2019Wat is Netherlands3D?\u2019 onder het overlay scherm naar boven gehaald.</p>"},{"location":"docs/handleiding/#content","title":"Content","text":"<p> (Afbeelding) Content</p> <p>De content bevat een algemene beschrijving van Netherlands3D.eu.</p>"},{"location":"docs/handleiding/#footer","title":"Footer","text":"<p> (Afbeelding)  Footer</p> <p>Deze laag bevat de logo's van de bij Netherlds3D.eu betrokken provincies en de mogelijkheid om door de hoofdstukken van het hoofdmenu in de hoofdbalk te bladeren.</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/","title":"Functionaliteiten","text":"<p>Stel je eigen Netherlands3D.eu samen!  Met het submenu <code>Functionaliteiten</code> krijgt de gebruiker toegang tot het aan-/uitzetten van de standaard datalagen en (menu)functies die in de basis versie van Netherlands3d.eu wordt aangeboden.    </p> <p> (Afbeelding) Functionaliteiten - submenu   Klik in het <code>selectievakje</code> om de laag of functie aan of uit te zetten.   </p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#functies","title":"Functies","text":""},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#terrein","title":"Terrein","text":"<p>Met maaiveld, ofwel het 'oppervlak waarop we lopen' is weergegeven als 3D terrein.  Voor het tonen van dit terrein is gebruik gemaakt van de 3D Basisvoorziening van het Kadaster.  Visueel onderscheiden zijn gebouwen, terreinonderdelen (zoals wegen, groenvlakken en water) en bruggen, waarbij de  gebouwen niet als 3D objecten worden getoond in deze laag. Op enkele onderdelen is een geometrische versimpeling    toegepast om het maaiveld sneller in de viewer te tonen. Bron: 3D Basisvoorziening, datum: 2019</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#gebouwen","title":"Gebouwen","text":"<p>Alle objecten op de laag 'Gebouwen' komen uit de 3D BAG, een jaarlijks geactualiseerde dataset van alle gebouwen in     Nederland. De set is ontwikkeld door de de 3D geoinformatie onderzoeksgroep van de Technische Universiteit Delft. Aan   het gebruik van de 3D BAG zitten. Bron: 3DBAG, datum: 2024, actualisatie: Jaarlijks</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#bomen-en-bospercelen","title":"Bomen en bospercelen","text":"<p>Deze kaartlaag toont alle individuele bomen en bospercelen van Nederland voor zover ze in de Basiskaart Grootschalige   Topografie (BGT) zijn opgenomen. Binnen bospercelen wordt onderscheid gemaakt in loofbossen, naaldbossen en gemengde    bossen, welke met een willekeurige hoogte en locatie zijn geplaatst. Bomen worden als 2D objecten op 3 vlakken  geprojecteerd, waardoor het lijkt alsof ze 3D objecten zijn.  Bron: Basiskaart Grootschalige Topografie (BGT), datum: december 2023</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#straatnamen","title":"Straatnamen","text":"<p>Deze kaartlaag toont alle straatnamen van Nederland. Afhankelijk van het zoomniveau worden straatnamen weergegeven. Bron: Nationaal Wegen Bestand (NWB)</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#buurtnamen","title":"Buurtnamen","text":"<p>Deze kaartlaag toont alle buurtnamen van Nederland. Afhankelijk van het zoomniveau worden buurtnamen weergegeven. Bron: PDOK</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#wijknamen","title":"Wijknamen","text":"<p>Deze kaartlaag toont alle wijknamen van Nederland. Afhankelijk van het zoomniveau worden wijknamen weergegeven. Bron: PDOK</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#gebouw-informatie","title":"Gebouw informatie","text":"<p>Maakt een koppeling tussen pandobjecten in de 3D viewer en administratieve data uit de Basisadministratie Adressen en Gebouwen (BAG) waardoor het mogelijk is gedetailleerde informatie over het pand, enkele pandkenmerken en de adressen daarbinnen op te vragen. Bron: Kadaster</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#downloaden-3d-gebied-collada-en-dxf","title":"Downloaden 3D gebied (Collada en DXF)","text":"<p>Maakt het mogelijk alle 3D modellen uit de viewer te downloaden als een los 3D Collada (.dae) bestand of DXF (.dxf). Downloaden kan per tegel van 100x100m met een maximum van 16 tegels tegelijk.</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#maak-screenshots","title":"Maak screenshots","text":"<p>Maakt het mogelijk om van elke willekeurige camerapositie die actief is een schermafbeelding te maken, deze wordt opgeslagen als .png bestand.</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#objectenbibliotheek","title":"Objectenbibliotheek","text":"<p>Een aantal voorgedefinieerde objecten kunnen in de viewer worden geladen. Denk aan windmolens of verschillende type bomen. Objecten kunnen op willekeurige locaties geplaatst worden en bij sommige objecten zijn extra instellingen mogelijk.</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#minimap","title":"Minimap","text":"<p>Er wordt een minimap getoond waarin je als gebruiker snel naar een andere locatie kunt navigeren. Binnen de minimap geeft een selectiegebied of 'field of sight' aan welk deel van Nederland in het hoofdscherm in 3D wordt weergegeven.</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#3d-tiles","title":"3D tiles","text":"<p>Maakt het mogelijk om gebouwen en maaiveld 3D Tiles lagen toe te voegen. Bron: PDOK</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#google-realitymesh","title":"Google RealityMesh","text":"<p>Toont voor delen van Nederland een foto-realistisch beeld van de omgeving. Met de kaartlaag 'Google Reality Mesh' komt een fotorealistische laag beschikbaar in de 3D viewer. Voor grote delen van Nederland heeft Google een 3D model beschikbaar gesteld waar objecten in 3D herkenbaar worden weergegeven. Deze laag, die in 3D Tiles formaat wordt aangeboden, maakt het mogelijk om nog beter inzicht te krijgen in de werkelijke situatie.</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#zonnestand-simuleren","title":"Zonnestand simuleren","text":"<p>Hiermee kan je de Zonnestand simuleren door tijd en datum aan te passen, of de zon in de slider op te pakken en te bewegen. Daarnaast kan je een schaduwstudie maken die de dan actieve camerapositie en geladen lagen opneemt in 12 png bestanden.</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#urbanreleaf-sensor-data-beta-voor-stad-utrecht","title":"UrbanReLeaf Sensor Data (BETA voor stad Utrecht)","text":"<p>Deze kaartlaag toont alle UrbanReLeaf sensor temperatuur data. Bron: PDOK</p>"},{"location":"docs/handleiding/3D-viewer-instellingen-sub/","title":"Applicatie instellingen","text":"<p>(Afbeelding) Applicatie instellingen </p>"},{"location":"docs/handleiding/3D-viewer-instellingen-sub/#beeldkwaliteit","title":"(Beeld)kwaliteit","text":"<p>Als standaard wordt de ingesteld op basis van de gebruikte computer. Daarnaast kan je in dit menu  de performance van de 3D viewer handmatig afstemmen op je persoonlijke situatie (snelheid internet, etc.). Door te kiezen voor <code>Hoog</code>, <code>Middel</code> of <code>Laag</code>, kan de (beeld)kwaliteit worden aangepast van resp. hoge, middelmatige of lage kwaliteit. De optie <code>laag</code> biedt de snelste performance, maar geeft de minste grafische kwaliteit.</p>"},{"location":"docs/handleiding/3D-viewer-instellingen-sub/#limiteer-scroll-gevoeligheid","title":"Limiteer scroll gevoeligheid","text":"<p>In sommige gevallen reageert de 3D-viewer niet optimaal op de muisbewegingen van de gebruiker. Door de optie <code>Limiteer scroll gevoeligheid</code> aan te vinken kan dit worden verbeterd.</p>"},{"location":"docs/handleiding/3D-viewer-instellingen-sub/#frames-per-seconde","title":"Frames per seconde","text":"<p>Als je deze instelling aanvinkt dan zie je rechtsboven in je scherm het aantal frames per seconde van de viewer. Dit kan helpen te bepalen welke beeldkwaliteits instelling te kiezen</p> <p>Klik op <code>x</code> (rechtsboven) om het instellingenmenu af te sluiten. Hierna toont de 3D-viewer het [default] startpunt; het centrum van Amersfoort (kadastraal nulpunt van Nederland).</p>"},{"location":"docs/handleiding/3D-viewer-instellingen/","title":"3D viewer instellingen","text":"<p> (Afbeelding) 3D-Viewer startscherm</p> <p>Het instellingenmenu is onderverdeeld in de functies;  </p> <ul> <li>Locatie bepalen (Link) </li> <li>Functionaliteiten (Link) </li> <li>Instellingen-submenu (Link) </li> </ul>"},{"location":"docs/handleiding/3D-viewer-locatie-bepalen/","title":"Locatie bepalen","text":"<p> (Afbeelding) Locatie bepalen - submenu  Met deze functie kun je de locatie invoeren. Dit kan op drie manieren;</p> <ol> <li>Door met de muis op een locatie in de map te klikken</li> <li>Door het invoeren van een plaats-, straatnaam en/of postcode</li> <li>Door bij X, Y een co\u00f6rdinaat* in te voeren</li> </ol> <p>Waarom kan ik geen gps-co\u00f6rdinaten invoeren?</p> <p>(*) Het co\u00f6rdinatenstelsel van Netherlands3d.eu is gebaseerd op het RD-co\u00f6rdinatenstelsel. Lees hier (externe link) meer over het RD-co\u00f6rdinatenstelsel.</p>"},{"location":"docs/handleiding/3D-viewer/","title":"3D-viewer","text":"<p>De 3D-viewer is de hoofdfunctionaliteit van Netherlands3D. De interface biedt toegang tot de verschillende functies. De 3D-viewer wordt geactiveerd na het klikken op de knop Bekijk de viewer op de voorpagina.</p> <p>Dit hoofdstuk beschrijft de belangrijkste functies van de 3D-viewer en de instellingen.</p>"},{"location":"docs/handleiding/3D-viewer/#beschrijving-van-het-instellingenmenu","title":"Beschrijving van het instellingenmenu","text":""},{"location":"docs/handleiding/3D-viewer/#startscherm","title":"Startscherm","text":"<p> (Afbeelding) 3D-Viewer startscherm</p> <p>Na het opstarten van de 3D viewer is het instellingen menu actief. In het instellingenmenu zijn de volgende onderdelen beschikbaar;</p> <ul> <li>Locatie bepalen (Link)</li> <li>Functionaliteiten (Link)</li> <li>Instellingen-submenu (Link)</li> </ul>"},{"location":"docs/handleiding/3D-viewer/#werkruimte","title":"Werkruimte","text":"<p> (Afbeelding) 3D-Viewer interface</p> <p>De interface is opgedeeld in het 3D-scherm met daaromheen de knoppen van de interface gegroepeerd in vier menu's:</p> <ol> <li>Werkbalk \u2013 linksboven  </li> <li>Project openen/opslaan - linksonder  </li> <li>Applicatiebalk \u2013 rechtsboven  </li> <li>Camerahoogte slider - rechts</li> <li>Informatie - onder </li> </ol>"},{"location":"docs/handleiding/3D-viewer/#werkbalk","title":"Werkbalk","text":"<p>Het hoofdmenu (linksboven) bevat de volgende functies (van boven naar onder);</p> <ul> <li>Zoekfunctie (Link)</li> <li>Object informatie (Link)</li> <li>Ondergrond doorzicht (Link)</li> <li>Lagen (Link)</li> <li>Toevoegen (link)</li> <li>Zonnestand (Link)</li> <li>Downloaden (Link) </li> </ul>"},{"location":"docs/handleiding/3D-viewer/#project-openenopslaan","title":"Project openen/opslaan","text":"<p>Het Project opslaan/openen-menu bevindt zich in de linkeronderhoek en bevat de volgende functies;</p> <ul> <li>Project opslaan (Link)</li> <li>Project openen (Link)</li> </ul>"},{"location":"docs/handleiding/3D-viewer/#applicatiebalk","title":"Applicatiebalk","text":"<p>De Applicatiebalk rechtsbovenin bevat de volgende functies (van links naar rechts):</p> <p>Schermafbeelding maken, Instellingen en Informatie.</p>"},{"location":"docs/handleiding/3D-viewer/#schermafbeelding-maken","title":"Schermafbeelding maken","text":"<p>Klik op <code>Schermafbeelding</code> om automatisch een afdruk van de 3D viewer als .png-bestand te downloaden. Bekijk de afbeelding door naar de map <code>C:\\Users\\Gebruikersnaam\\Downloads</code> te gaan`.</p>"},{"location":"docs/handleiding/3D-viewer/#instellingen","title":"Instellingen","text":"<p>Zie Instellingen</p>"},{"location":"docs/handleiding/3D-viewer/#informatie","title":"Informatie","text":"<p>De knop <code>Informatie</code> opent de Homepage in een apart browser-venster.</p>"},{"location":"docs/handleiding/3D-viewer/#camerahoogteslider","title":"Camerahoogteslider","text":"<p>Met de camerahoogteslider kan (door het blauwe cameraatje te slepen) de hoogte van de camera ingesteld worden.</p>"},{"location":"docs/handleiding/3D-viewer/#informatie_1","title":"Informatie","text":"<p>Het menu bevat de volgende functies:</p> <p> </p>"},{"location":"docs/handleiding/3D-viewer/#weergave-naar-noorden-draaien","title":"Weergave naar noorden draaien","text":"<p>Klik op <code>Weergave naar noorden draaien</code> om de kijkrichting automatisch naar het noorden te richten.   </p> <p> </p>"},{"location":"docs/handleiding/3D-viewer/#orthografischperspectief","title":"Orthografisch/perspectief","text":"<p>Klik op <code>Wissel tussen Orthografisch/perspectief</code> om de kijkrichting automatisch in loodrecht naar beneden en zonder perspectief te wijziggen. Klik nogmaals om het beeld terug te brengen naar de oorspronkelijke toestand.</p> <p></p>"},{"location":"docs/handleiding/3D-viewer/#mini-map","title":"Mini-map","text":"<p>De minimap is de kleine versie van de map bij instellingen zie 2. Instellingen Beweeg met de muis over de minimap om deze te vergroten. Door op een locatie in de minimap te klikken wordt in de 3D viewer bijbehorende locatie weergegeven.</p> <p>Met de knoppen <code>+/-</code> of met je scroll-wiel kan worden in-/uitgezoomd.</p>"},{"location":"docs/handleiding/3D-viewer/#positie","title":"Positie","text":"<p>In de onderbalk van de viewer staan (rechts) de co\u00f6rdinaten van de positie van de viewer. </p> <p>Waarom zie ik x,y,z-co\u00f6rdinaten en geen gps-co\u00f6rdinaten?</p> <p>Het co\u00f6rdinatenstelsel van Netherlands3D is gebaseerd op het rijksdriehoeksstelsel. Lees hier meer over het rijksdriehoeksstelsel.</p>"},{"location":"docs/handleiding/3D-viewer/#navigeren","title":"Navigeren","text":"<p>Het scherm toont de locatie die in het instellingenmenu is ingevoerd of \u2013 als er geen invoer is gedaan - de default-locatie (het kadastrale nulpunt van Nederland in het centrum van Amersfoort). Het beeld is in perspectief, onder een lichte hoek en vanaf een hoogte van 300 meter.</p>"},{"location":"docs/handleiding/3D-viewer/#besturen-en-navigeren","title":"Besturen en navigeren","text":"<p><code>Verplaats de muis</code> al dan niet in <code>combinatie met muisknoppen en/of toetsenbordknoppen</code> om door de 3D wereld in de viewer te navigeren.</p> <p>Dit kan op verschillende manieren;</p>"},{"location":"docs/handleiding/3D-viewer/#scrollzoom","title":"[Scroll/Zoom]","text":"<p><code>Verdraai het muiswiel</code> om naar voren of naar achteren te bewegen in de kijkrichting.</p> <p>standaard of snel zoomen</p> <p>Standaard scrollen geeft een normale snelheid van in- uitzoomen. Met de SHIFT-knop ingedrukt kan je 2x zo snel in- uitzoomen. Wel zo handig!</p> <p>(Video) Scroll/Zoom</p>"},{"location":"docs/handleiding/3D-viewer/#panning","title":"[Panning]","text":"<p>Door met de <code>muis \u00e9n de ingedrukte linkermuisknop</code> over het scherm <code>omhoog of omlaag</code> of <code>naar links of naar rechts te bewegen</code>, kan de kijker zich resp. omhoog of omlaag of resp. naar links of naar rechts in de 3D wereld verplaatsen.</p> <p>(Video) Panning</p>"},{"location":"docs/handleiding/3D-viewer/#draaien-manier-a","title":"[Draaien manier A.]","text":"<p>Door met de <code>muis en de ingedrukte middelste muisknop</code> over het scherm te <code>bewegen</code>, kan de kijker <code>om het kijkpunt heen draaien</code>. Alternatief; Dit kan ook met de <code>linkermuisknop in combinatie met de alt-toets</code>.</p> <p>(Video) Draaien manier A.</p>"},{"location":"docs/handleiding/3D-viewer/#draaien-manier-b","title":"[Draaien manier B.]","text":"<p>Door met de <code>muis en de ingedrukte linkermuisknop</code> in <code>combinatie met de ctrl-toets</code> over het scherm te <code>bewegen</code>, kan de kijker het beeld <code>naar links of naar rechts en/of naar boven of naar beneden draaien</code>.</p> <p>(Video) Draaien manier B.</p>"},{"location":"docs/handleiding/bibliotheek-basis/","title":"3D Tiles","text":"<p>Functies, Lagen, submenu.  </p> <p> </p> <p>(Afbeelding) Toevoegen / 3D Tiles</p>"},{"location":"docs/handleiding/bibliotheek-basis/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":""},{"location":"docs/handleiding/bibliotheek-basis/#menu","title":"Menu","text":"<p>Met de functie Tiles kunnen 3D Tiles uit twee voorgedefinieerde lagen worden gekoppeld.  </p> <p></p> <p>(Afbeelding) Toevoegen / 3D Tiles</p>"},{"location":"docs/handleiding/bibliotheek-basis/#gebouwen-3d-tiles","title":"Gebouwen (3D tiles)","text":"<p>Met <code>Gebouwen (3D tiles)</code> worden gebouwen uit de  3D Basisvoorziening van het Kadaster gekoppeld.  </p> <p> </p> <p>(Afbeelding) Gebouwen (3D Tiles)</p>"},{"location":"docs/handleiding/bibliotheek-basis/#maaiveld-3d-tiles","title":"Maaiveld (3D tiles)","text":"<p>Met <code>Maaiveld (3D tiles)</code> wordt het maaiveld uit de  3D Basisvoorziening van het Kadaster gekoppeld.</p> <p> </p> <p>(Afbeelding) Maaiveld en Gebouwen (3D Tiles)</p>"},{"location":"docs/handleiding/bibliotheek-basis/#referentiehoogte-aanpassen","title":"Referentiehoogte aanpassen","text":"<p>3D-Tile lagen kunnen op een verkeerde hoogte liggen. We hebben daarvoor een instelling gemaakt die je bij het eigenschappenpaneel kan activeren. Als standaard staat deze ingesteld op Ellipso\u00efde. Heb je een laag die op een verkeerde hoogte ligt, klik dan op \u00e9\u00e9n van de 2 mogelijkheden. </p> <p> </p> <p>(Afbeelding) Referentiehoogte op Ellipso\u00efde</p> <p></p> <p> </p> <p>(Afbeelding) Referentiehoogte op Geo\u00efde</p> <p></p> <p>Uitleg Referentiehoogte</p> <p>De hoogte van een 3D-tiles laag kan op twee manieren gemeten worden, ten opzichte van de ellipso\u00efde of de geo\u00efde. De referentiehoogte van de geo\u00efde ligt (voor Nederland) tussen de 41 en 44 meter boven de ellipso\u00efde. Voor meer informatie, zie deze site Uitleg Geo\u00efde/ellipso\u00efde</p>"},{"location":"docs/handleiding/first-person-viewer/","title":"First Person Viewer","text":"<p>De First Person Viewer (FPV) is een work-in-progress functionaliteit van Netherlands3D.</p> <p>De First Person Viewer maakt het mogelijk voor gebruikers om zich op realistische ooghoogte door de 3D-wereld te bewegen. Zo kan de gebruiker ervaren hoe een aangepaste omgeving in het echt beleefd zou worden.</p>"},{"location":"docs/handleiding/first-person-viewer/#beginnen","title":"Beginnen","text":"<p>Om de First Person Viewer te starten, volg je de onderstaande stappen:</p> <ol> <li>Zet de functionaliteit aan via Instellingen \u2192 Functionaliteiten \u2192 First Person Viewer.</li> <li>Er verschijnt een First Person Viewer-knop rechtsonder in beeld, naast de noordpijl.</li> <li>Sleep het poppetje uit de knop naar de gewenste locatie in de wereld waar je wilt rondlopen. Vanaf hier opent de First Person Viewer.</li> </ol> <p></p> <p> </p>"},{"location":"docs/handleiding/first-person-viewer/#verlaten","title":"Verlaten","text":"<p>De first person viewer vergrendeld de muisaanwijzer vast in de first person viewer. Deze kun je weer ontgrendelen door \u00e9\u00e9n keer op Backspace te drukken. Het verlaten van de first person viewer kan op meerdere manieren;</p> <ul> <li>Houd de Backspace-toets 2 seconden ingedrukt. Linksboven in het scherm verschijnt een voortgangsbalk zien die aangeeft hoe lang je backspace nog moet indrukken voordat je de first person viewer verlaat.</li> <li>Druk \u00e9\u00e9n keer op Backspace om de muis vrij te geven, en klik vervolgens rechtsboven op de 'verlaten' knop om de First Person Viewer te verlaten. </li> </ul> <p> </p>"},{"location":"docs/handleiding/first-person-viewer/#besturing","title":"Besturing","text":"<p>Er zijn verschillende manieren van bewegen in de first person viewer.  In de beta-versie kan gelopen en gevlogen worden, in aparte bewegings modi.</p> <p>De algemene beweging kan op twee manieren worden gedaan;</p> <ul> <li>met de pijltjestoetsen, \u00f3f </li> <li>met de knoppen 'W, A, S, D'.</li> </ul> <p>Hieronder volgt uitleg per bedieningsmethode. Kies de methode die voor jou het prettigst werkt.</p> <p></p>"},{"location":"docs/handleiding/first-person-viewer/#pijltjestoetsen","title":"Pijltjestoetsen","text":"<p>Met de pijltjestoetsen kun je rondbewegen in de First Person Viewer. De muis gebruik je om rond te kijken in de virtuele wereld. Door de muis te bewegen, verander je je kijkrichting. De pijltjestoetsen bewegen je vervolgens in die richting. Op dit onderstaande kaartje is zichtbaar welke knoppen waarvoor dienen:</p> <p> </p> <p>Extra functies:</p> <ul> <li>Versnellen: houdt Shift ingedrukt.</li> </ul> <p>Loopmodus:</p> <ul> <li>Springen: druk op Spatiebalk.</li> </ul> <p>Vliegmodus:</p> <ul> <li>Omhoog vliegen: Spatiebalk of PageUp.</li> <li>Omlaag vliegen: PageDown.</li> </ul> <p></p>"},{"location":"docs/handleiding/first-person-viewer/#w-a-s-d","title":"W A S D","text":"<p>Je kunt rondbewegen door de knoppen 'W A S en D' te gebruiken. </p> <ul> <li>Vooruit: W.</li> <li>Achteruit: S.</li> <li>Links: A.</li> <li>Rechts: D.</li> </ul> <p>Deze knoppen zijn bepaald met respect tot hun positie op het toetsenbord, net als de pijltjestoetsen.  De muis gebruik je om rond te kijken in de virtuele wereld. Door de muis te bewegen, verander je je kijkrichting. De knoppen 'W A S en D' zullen bewegen in de gekozen kijkrichting.</p> <p>Onderstaand kaartje toont de knoppenindeling:</p> <p> </p> <p>Daarnaast zijn er verschillende manieren om te bewegen in de tool:</p> <ul> <li>Versnellen: houdt Shift ingedrukt.</li> </ul> <p>Loopmodus:</p> <ul> <li>Springen: druk op Spatiebalk.</li> </ul> <p>Vliegmodus:</p> <ul> <li>Omhoog vliegen: Spatiebalk of Q.</li> <li>Omlaag vliegen: E.</li> </ul> <p></p>"},{"location":"docs/handleiding/first-person-viewer/#algemene-besturing","title":"Algemene besturing:","text":"<p>Wisselen tussen bewegingsmodi: Tab. De camera te draaien zonder de muis: </p> <ul> <li>Omhoog draaien: I.</li> <li>Omlaag draaien: K.</li> <li>Naar links draaien: J.</li> <li>Naar rechts draaien: L.</li> </ul> <p>Handige sneltoetsen:</p> <ul> <li>Screenshot: C.</li> <li>\"Snap\" omhoog naar het hoogste niveau: R.</li> <li>Verberg alle UI (User Interfaces): H. Druk nogmaals H om de UI weer te tonen.</li> </ul>"},{"location":"docs/handleiding/first-person-viewer/#movement-modus","title":"Movement Modus","text":"<p>Op dit moment heeft de first person viewer twee bewegings-modi, lopen en vliegen. Je kunt van modus wisselen door:</p> <ul> <li>op de pijlen links of rechts in de button op het scherm te klikken.</li> <li>op de cirkel met de huidige bewegingsmodus te klikken om het menu te openen.</li> <li>De toetsen Tab en Enter te gebruiken.</li> </ul> <p> </p> <p>In het instellingenpaneel van de First Person Viewer kun je enkele variabelen aanpassen: - Snelheid. - Gezichtsveld (vergelijkbaar met de breedte van een lens). - Kijkhoogte.</p> <p>Typ zelf de gewenste waardes in en klik vervolgens uit het veld om de waardes vast te leggen.</p> <p>Bewegings modi in ontwikkeling</p> <p>Op het moment werken wij aan meerdere bewegings modi, waaronder autorijden en fietsen.</p>"},{"location":"docs/handleiding/first-person-viewer/#functionaliteiten","title":"Functionaliteiten","text":"<p>De first person viewer heeft enkele functionaliteiten die in de beta versie beschikbaar zijn voor gebruik:</p> <ul> <li>Ondergronds kijken: Bij het activeren van deze functie verschijnt een cirkel op het grondvlak, waarmee je ondergronds kunt kijken.</li> <li>Gebouwen informatie: In het midden van het scherm verschijnt een kleine stip. Richt deze stip op het gewenste gebouw en klik. In het veld rechts verschijnt gebouwinformatie, uit de Basisadministratie Adressen en Gebouwen (BAG). Let op, houd voor deze functionaliteit uw muis stil wanneer u klikt, bewegende selectie wordt meestal niet gedetecteerd.</li> <li>Zonnestand simuleren:  Hiermee kan je de Zonnestand simuleren door tijd en datum aan te passen, of de zon in de slider op te pakken en te bewegen.</li> <li>Reset to start: Deze button hersteld de beginpositie van de first person viewer. Let op: dit werkt nog niet goed bij grote afstanden.</li> </ul> <p>De First Person Viewer is een b\u00e8taversie in ontwikkeling door Netherlands3D.</p>"},{"location":"docs/handleiding/gebied-downloaden/","title":"Gebied downloaden","text":"<p>Functie, hoofdmenu.  </p> <p></p> <p>Met de functie Gebied Downloaden kunnen delen van een gebied als bestand worden gedownload (in de formaten .DAE en .DXF). Deze functie bevordert de aansluiting en uitwisseling met andere visualisatie- en CAD programma's.  Dit hoofdstuk beschrijft de belangrijkste functies van Gebied Downloaden en geeft uitleg over de interface en essenti\u00eble functies.  </p>"},{"location":"docs/handleiding/gebied-downloaden/#beschrijving","title":"Beschrijving","text":"<p>Met Gebied downloaden kunnen delen van een gebied worden opgeslagen en in andere software worden ingeladen. </p> <p>(Video) Gebied downloaden</p>"},{"location":"docs/handleiding/gebied-downloaden/#menu","title":"Menu","text":"<p>Door met de muis op het <code>Gebied downloaden-icoon</code> in het hoofdmenu te klikken wordt de tool actief. Het menu klapt open en de instellingen worden zichtbaar.</p> <p> (Afbeelding) Gebied downloaden-menu</p>"},{"location":"docs/handleiding/gebied-downloaden/#werking","title":"Werking","text":"<p> (Afbeelding) Gebied downloaden, 100x100 sectie</p> <p> (Afbeelding) Meerdere secties van 100x100 geselecteerd.</p> <p>Waarom kan ik het selectiegebied niet roteren?</p> <p>Het selectiegebied is altijd loodrecht op de horizontale-as/op het noorden geori\u00ebnteerd.</p>"},{"location":"docs/handleiding/gebied-downloaden/#gebied-downloaden_1","title":"Gebied downloaden","text":"Na het activeren van de functionaliteit wordt het menu actief en kun je met de muis meerdere secties van 100x100 meter selecteren."},{"location":"docs/handleiding/gebied-downloaden/#selecteer-gebied","title":"Selecteer gebied","text":"Door met de muis, in combinatie met de linkermuisknop en shift-toets te slepen kun je het selectiegebied vergroten."},{"location":"docs/handleiding/gebied-downloaden/#export-format-kiezen","title":"Export format kiezen","text":"(Afbeelding) Keuze voor export format."},{"location":"docs/handleiding/gebied-downloaden/#coordinaten-huidige-selectie","title":"Co\u00f6rdinaten huidige selectie","text":"<p>Met deze functie kun je de co\u00f6rdinaten van het hoekpunt zuidwest en het hoekpunt noordoost naar het klembord kopi\u00ebren.</p>"},{"location":"docs/handleiding/gebied-downloaden/#voorwaarden","title":"Voorwaarden","text":"<p>NB! Voordat je het geselecteerde gebied kunt downloaden, dien je akkoord te gaan met de voorwaarden door <code>Ik ga akkoord met de voorwaarden</code>. Je vindt de link onder; <code>Rechtenbeleid 3D basisvoorziening</code> &amp;  <code>Gebruiksvoorwaarden 3DBag</code>.</p>"},{"location":"docs/handleiding/gebied-downloaden/#downloaden","title":"Downloaden","text":"<p>Klik op <code>download</code> om een .DAE (Collada) of .DXF (CAD) bestand te downloaden. Het bestand kun je in een 3D modelleerprogramma zoals bijvoorbeeld Blender, Sketchup of CAD software importeren en bewerken.</p>"},{"location":"docs/handleiding/homepage/","title":"Homepage","text":"<p>Op de homepage is algemene informatie over het Netherlands3D project te vinden. Naast de functionaliteiten bieden we specifiek voor twee doelgroepen informatie aan: voor organisaties/gebruikers en Voor ontwikkelaars.</p>"},{"location":"docs/handleiding/homepage/#hoofdstukken","title":"Hoofdstukken","text":"<p>(Afbeelding) Hoofdmenubalk</p>"},{"location":"docs/handleiding/homepage/#functionaliteiten-en-functies","title":"Functionaliteiten en functies","text":"<p>In het hoofdstuk Handleiding vind je een gedetailleerde beschrijving van alle functionaliteiten en functies ondersteund met afbeeldingen en/of filmpjes.</p>"},{"location":"docs/handleiding/homepage/#voor-organisaties","title":"Voor organisaties","text":"<p>Dit hoofdstuk is onder ontwikkeling en bevat straks een uitgebreide bron van informatie. Het doel is om organisaties te ondersteunen met gidsen, best practices en antwoorden op veel gestelde vragen die essentieel zijn voor het gebruik van het Netherlands3D platform.</p>"},{"location":"docs/handleiding/homepage/#voor-ontwikkelaars","title":"Voor ontwikkelaars","text":"<p>Ben je een ontwikkelaar en wil je bijvoorbeeld eigen functie binnen Netherlands3D ontwikkelen? Dan vind je in dit hoofdstuk de benodigde technische documentatie. Deze documentatie is bedoeld voor ontwikkelaars die willen begrijpen hoe het platform werkt, de architectuur willen verkennen en nieuwe modules of functie willen bijdragen.</p>"},{"location":"docs/handleiding/homepage/#schermmodus","title":"Schermmodus","text":"<p>Door op het <code>Schermmodus-icoon</code> te klikken kan de interface kan de modus veranderd worden in <code>Dark</code>; lichte tekst op een donkere achtergrond of <code>Light</code>; donkere tekst op een lichte achtergrond. In de Dark modus gebruikt het systeem minder energie en hoeft het systeem in het geval van een laptop minder snel te worden opgeladen.</p> <p> (Afbeelding) Dark/Light modus</p>"},{"location":"docs/handleiding/homepage/#zoeken","title":"Zoeken","text":"<p>Deze zoekfunctie biedt de mogelijkheid om naar trefwoorden te zoeken binnen Netherlands3D. Vul de zoekterm(en) in bij <code>Zoeken</code> en de lijst met klikbare resultaten wordt in de context (hoofdstuk en alinea) getoond.</p>"},{"location":"docs/handleiding/homepage/#headline","title":"Headline","text":"<p>(Afbeelding) Headline</p>"},{"location":"docs/handleiding/homepage/#bekijk-de-viewer","title":"Bekijk de viewer","text":"<p>Klik op <code>Bekijk de viewer</code> in de headline om de 3D-viewer functionaliteit te starten. (Zie 3D-viewer functionaliteit  voor de beschrijving.)  </p>"},{"location":"docs/handleiding/homepage/#wat-is-het","title":"Wat is het","text":"<p>Met de knop <code>Wat is het?</code> wordt de tekst \u2019Wat is Netherlands3D?\u2019 onder het overlay scherm naar boven gehaald.</p>"},{"location":"docs/handleiding/homepage/#content","title":"Content","text":"<p>(Afbeelding) Content</p> <p>De content bevat een algemene beschrijving van Netherlands3D.</p>"},{"location":"docs/handleiding/homepage/#footer","title":"Footer","text":"<p>(Afbeelding) Footer</p> <p>Deze laag bevat de logo's van de bij Netherlands3D betrokken provincies en de mogelijkheid om door de hoofdstukken van het hoofdmenu in de hoofdbalk te bladeren.</p>"},{"location":"docs/handleiding/lagen-toevoegen/","title":"Lagen toevoegen","text":"<p>Basisfunctie, hoofdmenu.</p> <p></p> <p>Lagen is onderdeel van de basisfuncties van Netherlands3d.eu. Deze functie biedt de mogelijkheden om datalagen en objecten uit verschillende bronnen te (ont)koppelen en de zichtbaarheid hiervan aan te passen.   Dit hoofdstuk beschrijft de belangrijkste functies van Lagen en geeft uitleg over de gebruikersinterface en essenti\u00eble functies.  </p>"},{"location":"docs/handleiding/lagen-toevoegen/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":""},{"location":"docs/handleiding/lagen-toevoegen/#menu-linksonder","title":"Menu (linksonder)","text":"<p>Door met de muis op het <code>Lagen-icoon</code> in het hoofdmenu te klikken wordt de tool actief. en het <code>toevoegen-menu</code> klapt open en de functies worden zichtbaar.</p> <p></p> <p>(Afbeelding) toevoegen-menu</p>"},{"location":"docs/handleiding/lagen-toevoegen/#functies","title":"Functies","text":""},{"location":"docs/handleiding/lagen-toevoegen/#organiseren","title":"Organiseren","text":"<p>Met het <code>Map-icoon</code> wordt een folder aangemaakt waarvan de naam kan worden aangepast (dubbelklikken) en waarin de gekoppelde lagen of objecten kunnen worden gesleept. Dit helpt bij het organiseren en overzichtelijk houden van de gekoppelde lagen en/of objecten.</p> <p></p> <p>(Afbeelding) toevoegen folder-menu</p>"},{"location":"docs/handleiding/lagen-toevoegen/#verwijderen","title":"Verwijderen","text":"<p>Met het <code>Prullenbak-icoon</code> wordt de geselecteerde laag of object verwijderd. Dit kan ook met de <code>del/delete-toets</code> van het toetsenbord. NB! Sla voor het verwijderen alle instellingen op met <code>Project Opslaan</code>. </p> <p></p> <p>(Afbeelding) verwijderen-menu</p> <p>Waar is de undo-functie?</p> <p>Sla na toevoegingen en/of aanpassingen het project regelmatig op. Er is geen UNDO-functie in Netherlands3D.eu.</p>"},{"location":"docs/handleiding/lagen-toevoegen/#toevoegen","title":"Toevoegen","text":"<p>Het koppelen van datalagen al dan niet in combinatie met objecten is d\u00e9 kernfunctie van Netherlands3D. Met het <code>+ icoon</code> opent het Toevoegen menu en zijn de verschillende teken-, koppel- en importmogelijkheden (gedeeltelijk) zichtbaar. Door met de muis de blauwe bovenbalk omhoog te slepen opent het menu volledig.</p> <p>Het menu bevat de volgende zeven functies:</p> <ol> <li>Importeren (link)</li> <li>Selectiegebied (link)</li> <li>Urban ReLeaf (link)</li> <li>Basislagen (link)</li> <li>3D Tiles (link)</li> <li>Fotorealistische Wereld (link)</li> <li>Objecten bibliotheek (link)</li> </ol> <p></p> <p>(Afbeelding) Toevoegen menu, volledig zichtbaar</p>"},{"location":"docs/handleiding/lagen/","title":"Lagen","text":"<p>Basisfunctie, hoofdmenu.  </p> <p></p> <p>Lagen is onderdeel van de basisfuncties van Netherlands3d.eu. Deze functie biedt de mogelijkheden om datalagen en objecten uit verschillende bronnen te (ont)koppelen en de zichtbaarheid hiervan aan te passen.   Dit hoofdstuk beschrijft de belangrijkste functies van lagen en geeft uitleg over de gebruikersinterface en essenti\u00eble functies.  </p>"},{"location":"docs/handleiding/lagen/#overzicht-van-de-functies","title":"Overzicht van de functies","text":"<p>Door het uit-/aanvinken van datalagen worden deze verborgen of getoond.  Met behulp van links en/of het importeren van bestanden worden datalagen en objecten gekoppeld.</p> <p>(Video) gebruik van Lagen</p>"},{"location":"docs/handleiding/lagen/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":""},{"location":"docs/handleiding/lagen/#menu-linksboven","title":"Menu (linksboven)","text":"<p>Door met de muis op het <code>Lagen-icoon</code> in het hoofdmenu te klikken wordt de tool actief. Het menu klapt open en de basislagen worden zichtbaar.</p> <p> (Afbeelding) lagen-menu</p>"},{"location":"docs/handleiding/lagen/#functies","title":"functies","text":"<p> (Afbeelding) Rangschikken van lagen</p> <p>Waarom zie ik geen effect bij het verslepen van de lagen?</p> <p>Het verplaatsen van lagen heeft alleen een zichtbaar effect bij lagen waarin WMS-data gekoppeld is. zie Voorbeeld koppelen bestand met URL.</p> <p> (Afbeelding) Transformatie tool geactiveerd door selectie in Lagen </p> <p> (Afbeelding) Instellingen actief</p> <p>Bij het laden van .OBJ, .GLB, WFS en GeoJSON lagen is er de mogelijkheid om de kleuren van de geladen data te  wijzigen. Dat geldt ook de standaard terreinlaag. De gebouwenlaag volgt later en ook de mogelijkheid om kleuren te herstellen volgt later. Hoe je de kleuren wijzigt, lees je hieronder.</p> <p></p> <p>Door op het instellingen icoon te klikken open je het instellingenvenster waar, wanneer van toepassing, het kleurenpaneel zichtbaar wordt.</p> <p></p> <p>Met het kleurenpaneel kan je kleuren en transparantie van basis en toegevoegde lagen aanpassen (deze kunnen materiaal kleuren uit een .mtl bestand overrulen). Door op een kleur in de cirkel te klikken, of door op het rondje in de kleurenwaaier te klikken en te verslepen, kan je jouw gewenste kleur kiezen. De saturatie is dan nog aanpasbaar via de meest rechtse horizontale balk. Daarnaast kan de transparantie van de kleur worden aangepast (werkt voorlopig alleen voor WFS/GeoJSON). Ook kan je een Hexadecimale Kleurcode invullen in het onderste veld.</p> <p>De kleur van de geladen en geselecteerde laag zal nu wijzigen naar de gekozen kleur.</p>"},{"location":"docs/handleiding/lagen/#standaardlagen","title":"Standaardlagen","text":"<p>De lagen Bomen, Bossen, Gebouwen en Maaiveld zijn in de basisversie standaard gekoppeld.</p>"},{"location":"docs/handleiding/lagen/#laagvolgorde","title":"Laagvolgorde","text":"<p>Met de muis en linkermuisknop kan de volgorde van de lagen worden gewijzigd. <code>Klik</code> op een laag en <code>sleep</code> de laag naar de gewenste plek door de <code>linkermuisknop</code> ingedrukt te houden. Door de laag op een andere laag te slepen wordt deze onder die laag gekoppeld. Sleep je de laag tussen twee lagen, Dan wordt deze er tussen geplaatst na het <code>loslaten</code> van de <code>linkermuisknop</code>. Met deze functie kunnen lagen op- of juist onder elkaar worden gesorteerd.</p>"},{"location":"docs/handleiding/lagen/#tonenverbergen","title":"Tonen/verbergen","text":"<p>Klik op het <code>oog</code> voor het verbergen of tonen van de inhoud van de datalagen in de 3D-Viewer.</p>"},{"location":"docs/handleiding/lagen/#transformatie-tool","title":"Transformatie tool","text":"<p>De locatie, ori\u00ebntatie en schaal van toegevoegde objecten wordt met de transformatie tool aangepast.</p>"},{"location":"docs/handleiding/lagen/#eigenschappen","title":"Eigenschappen","text":"Van toegevoegde objecten en sommige lagen kunnen eigenschappen zoals b.v. de locatie, ori\u00ebntatie en schaal maar ook object/laag specifieke eigenschappen worden aangepast. Klik op het <code>Eigenschappen-icoon</code> om het eigenschappenmenu te openen."},{"location":"docs/handleiding/lagen/#kleurenpaneel","title":"Kleurenpaneel","text":""},{"location":"docs/handleiding/lagen/#afgeschermde-bronnen","title":"Afgeschermde bronnen","text":""},{"location":"docs/handleiding/lagen/#invullen-gebruikersnaam-en-wachtwoord","title":"Invullen gebruikersnaam en wachtwoord","text":"<p>Als er een laag van een afgeschermde bron wordt geladen (via het importeren menu), krijg je bovenstaande venster in beeld. Dit kunnen WMS/WFS/GeoJSON en 3D-Tiles lagen zijn, welke je via een bestand of url koppelt. In dit venster vul je gebruikersnaam en wachtwoord in.</p>"},{"location":"docs/handleiding/lagen/#switchen-tussen-gebruikersnaamwachtwoord-en-code","title":"Switchen tussen gebruikersnaam/wachtwoord en code","text":"<p>Wanneer je geen gebruikersnaam en wachtwoord hebt, maar alleen een code (bijvoorbeeld een API-key) dan kan je via bovenstaande knop switchen tussen gebruikersnaam/wachtwoord en code.</p>"},{"location":"docs/handleiding/lagen/#invullen-code","title":"Invullen Code","text":"<p>In dit venster vul je alleen de code in.</p> <p>Als je de gegevens hebt ingevuld, wordt de laag gemaakt en de gegevens uit bestand of bron geladen.</p>"},{"location":"docs/handleiding/object-informatie/","title":"Object Informatie","text":"<p>Functie, hoofdmenu.</p> <p></p> <p>Met de BAG Object Informatie tool kan de gebruiker schematische 3D modellen van alle objecten in Nederland bekijken en gedetailleerde object (gebouw) informatie opvragen. BAG Object Informatie is onderdeel van de basisfuncties in Netherlands3D.eu. Alle objecten op de laag 'Gebouwen' komen uit de 3DBAG. Dit is een up-to-date land dekkende dataset met 3D gebouwmodellen van Nederland. Dit hoofdstuk beschrijft de belangrijkste functies van BAG Object Informatie en geeft uitleg over de interface en essenti\u00eble functies.</p>"},{"location":"docs/handleiding/object-informatie/#overzicht-van-functies","title":"Overzicht van functies","text":"<p>Door een object te selecteren kan gedetailleerde object informatie worden opgevraagd.</p> <p>(Video) Object informatie</p>"},{"location":"docs/handleiding/object-informatie/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":""},{"location":"docs/handleiding/object-informatie/#menu","title":"Menu","text":"<p>Na het klikken op de het (bovenste) <code>BAG Informatie-icoon</code> van het hoofdmenu, klapt het Object informatie-menu open en verschijnt onderstaande tekst in beeld.</p> <p> </p> <p>(Afbeelding) Object informatie-toelichting</p>"},{"location":"docs/handleiding/object-informatie/#object-selectie","title":"Object selectie","text":"<p>Klik op een <code>gebouw in de 3D-Viewer</code> om de Basisregistratie Adressen en Gebouwen (BAG) informatie te bekijken. Het geselecteerde object wordt blauw en de offici\u00eble object informatie verschijnt.</p> <p></p> <p>(Afbeelding) Object informatie-paneel</p>"},{"location":"docs/handleiding/object-informatie/#object-informatie_1","title":"Object informatie","text":"<p>De Object informatie bevat de volgende data.</p> <p>Praktische informatie</p> <ul> <li>BAG ID    0000000000000000   </li> <li>Status   </li> <li>Bouwjaar  [Jaartal]  </li> </ul> <p>(Adress(en))</p> <ul> <li>Adres en Huisnummer  </li> </ul> <p>Kan ik meer BAG informatie krijgen?</p> <p>Ja dat kan zeker, door op het BAG ID te klikken van het pand wat is geselecteerd, wordt je doorgestuurd naar de BAG-viewer van het kadaster en ingezoomd op het geselecteerde pand in de 3D-Viewer. </p>"},{"location":"docs/handleiding/object-informatie/#aanvullende-technische-details","title":"Aanvullende technische details","text":"<p>De 3DBAG is een up-to-date landsdekkende dataset met 3D gebouwmodellen van Nederland. De 3DBAG is open data. Het bevat 3D modellen op verscheidene detailniveaus welke zijn gegenereerd door de combinatie van twee open datasets: de pand-gegevens uit de BAG en de hoogtegegevens uit de AHN. De 3DBAG wordt regelmatig ge\u00fcpdatet met de meest recente openlijk beschikbare pand- en hoogtegegevens.</p> <p>Via Netherlands3d.eu is het mogelijk vierkante tegels van 100x100 meter te downloaden.</p> <p>Ga hiervoor naar de optie Gebied downloaden in het hoofdmenu.</p>"},{"location":"docs/handleiding/object-informatie/#referenties","title":"Referenties","text":"<p>Link naar de API van het Kadaster</p>"},{"location":"docs/handleiding/ondergrond-doorzicht/","title":"Ondergrond doorzicht","text":"<p>Functie, hoofdmenu.  </p> <p></p> <p>Ondergrond doorzicht is onderdeel van de basisfuncties in Netherlands3D.eu. Ondergrond doorzicht is een functie die is ontworpen om gebruikers een uitgebreid beeld te geven van de ondergrondse omgeving. Door ondergrondse structuren te visualiseren, kunnen professionals op verschillende gebieden weloverwogen beslissingen nemen en hun operationele effici\u00ebntie verbeteren.  Dit hoofdstuk beschrijft de werking van ondergrond doorzicht en geeft uitleg over de interface en essenti\u00eble onderdelen. Daarnaast is er een overzicht van de mogelijkheden en toepassingen van de functie en laat zien hoe ondergrond doorzicht dient als een essenti\u00eble bron voor het verkennen van wat er onder de oppervlakte ligt.</p>"},{"location":"docs/handleiding/ondergrond-doorzicht/#overzicht","title":"Overzicht","text":"<p>Met het doorzicht koepelvenster worden delen van datalagen en/of objecten welke zich onder het maaiveld en binnen de straal van het venster bevinden zichtbaar gemaakt. Met de muis kan het venster verplaatst worden waardoor andere ondergrondse delen zichtbaar worden.</p> <p>(Video) Ondergrond doorzicht </p>"},{"location":"docs/handleiding/ondergrond-doorzicht/#gedetailleerde-beschrijving-van-de-functie","title":"Gedetailleerde beschrijving van de functie","text":""},{"location":"docs/handleiding/ondergrond-doorzicht/#menu","title":"Menu","text":"<p>Door met de muis op het <code>Ondergrond doorzicht-icoon</code> in het hoofdmenu te klikken wordt de tool actief. Het doorzicht koepelvenster is nu aan de locatie/beweging van de muis gekoppeld.</p> <p> (Afbeelding) Ondergrond doorzicht</p>"},{"location":"docs/handleiding/ondergrond-doorzicht/#werking","title":"Werking","text":"<p> (Afbeelding) Aanpassen diameter koepelvenster</p>"},{"location":"docs/handleiding/ondergrond-doorzicht/#gebruikverplaatsen","title":"Gebruik/verplaatsen","text":"<p>De koepel beweegt mee met de muis over het gebied waarvan de ondergrond zichtbaar moet worden gemaakt.</p>"},{"location":"docs/handleiding/ondergrond-doorzicht/#aanpassen-grootte-diameter","title":"Aanpassen grootte diameter","text":"<p>Door met de muis over het witte vierkant te bewegen verschijnt een hand waarmee na het <code>[klikken en vasthouden van de linkermuisknop]</code> en het slepen van de muis de grootte van het doorzicht koepelvenster kan worden aangepast. Hiermee wordt een groter c.q. kleiner gebied onder het maaiveld zichtbaar.</p>"},{"location":"docs/handleiding/project-openen-opslaan/","title":"Project openen/opslaan","text":"<p>Het Project opslaan/openen-menu bevindt zich in de linker onder hoek en bevat de volgende functies;</p> <ul> <li><code>Project openen</code> </li> <li><code>Project opslaan</code> </li> </ul>"},{"location":"docs/handleiding/project-openen-opslaan/#project-opslaan","title":"Project opslaan","text":"<p>Met <code>Project opslaan</code> worden alle nieuwe instellingen, locatie, lagen etc. van de viewer opgeslagen. Met de knop <code>Project opslaan</code> wordt een venster geopend met aanvullende uitleg en de knop Bestand opslaan.</p> <p></p> <p>Met de knop <code>Bestand opslaan</code> worden de instellingen automatisch in een .nl3d bestand gedownload in de map <code>C:\\Users\\Gebruikersnaam\\Downloads</code>. </p>"},{"location":"docs/handleiding/project-openen-opslaan/#project-openen","title":"Project openen","text":"<p>Met de knop <code>Project openen</code> wordt een venster geopend met aanvullende uitleg en de knop <code>Bestand openen</code>. Hiermee wordt de Verkenner (Windows) of Finder (MacOS) geopend en kan een eerder gemaakt .nl3d-bestand worden geopend. Hierna zijn de in-het-.nl3d-bestand-opgeslagen instellingen, datalagen, locatie etc. weer actief. </p> <p></p> <p>Klik en sleep</p> <p>Projecten openen kan ook door ze vanuit de Verkenner/Finder te klikken en slepen naar de 3D Viewer. Best handig!</p> <p> </p>"},{"location":"docs/handleiding/toevoegen-3d-tiles/","title":"3D Tiles","text":"<p>Functies, Lagen, submenu.  </p> <p> </p> <p>(Afbeelding) Toevoegen / 3D Tiles</p>"},{"location":"docs/handleiding/toevoegen-3d-tiles/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":""},{"location":"docs/handleiding/toevoegen-3d-tiles/#menu","title":"Menu","text":"<p>Met de functie Tiles kunnen 3D Tiles uit twee voorgedefinieerde lagen worden gekoppeld.  </p> <p></p> <p>(Afbeelding) Toevoegen / 3D Tiles</p>"},{"location":"docs/handleiding/toevoegen-3d-tiles/#gebouwen-3d-tiles","title":"Gebouwen (3D tiles)","text":"<p>Met <code>Gebouwen (3D tiles)</code> worden gebouwen uit de  3D Basisvoorziening van het Kadaster gekoppeld.  </p> <p> </p> <p>(Afbeelding) Gebouwen (3D Tiles)</p>"},{"location":"docs/handleiding/toevoegen-3d-tiles/#maaiveld-3d-tiles","title":"Maaiveld (3D tiles)","text":"<p>Met <code>Maaiveld (3D tiles)</code> wordt het maaiveld uit de  3D Basisvoorziening van het Kadaster gekoppeld.</p> <p> </p> <p>(Afbeelding) Maaiveld en Gebouwen (3D Tiles)</p>"},{"location":"docs/handleiding/toevoegen-3d-tiles/#referentiehoogte-aanpassen","title":"Referentiehoogte aanpassen","text":"<p>3D-Tile lagen kunnen op een verkeerde hoogte liggen. We hebben daarvoor een instelling gemaakt die je bij het eigenschappenpaneel kan activeren. Als standaard staat deze ingesteld op Ellipso\u00efde. Heb je een laag die op een verkeerde hoogte ligt, klik dan op \u00e9\u00e9n van de 2 mogelijkheden. </p> <p> </p> <p>(Afbeelding) Referentiehoogte op Ellipso\u00efde</p> <p></p> <p> </p> <p>(Afbeelding) Referentiehoogte op Geo\u00efde</p> <p></p> <p>Uitleg Referentiehoogte</p> <p>De hoogte van een 3D-tiles laag kan op twee manieren gemeten worden, ten opzichte van de ellipso\u00efde of de geo\u00efde. De referentiehoogte van de geo\u00efde ligt (voor Nederland) tussen de 41 en 44 meter boven de ellipso\u00efde. Voor meer informatie, zie deze site Uitleg Geo\u00efde/ellipso\u00efde</p>"},{"location":"docs/handleiding/toevoegen-basislagen/","title":"Basislagen","text":"<p>Functies, Lagen, submenu.  </p> <p> (Afbeelding) Toevoegen / Basislagen</p>"},{"location":"docs/handleiding/toevoegen-basislagen/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":""},{"location":"docs/handleiding/toevoegen-basislagen/#basislagen_1","title":"Basislagen","text":"<p>Met de functie Basislagen kunnen de vier basislagen welke in de standaard/basisversie zijn gekoppeld worden verwijderd of toegevoegd. (Afbeelding) De vier basislagen  Na het aanklikken van \u00e9\u00e9n van de lagen; <code>Maaiveld, Gebouwen, Bomen en/of Bossen</code> wordt deze laag verwijderd uit de viewer het bijbehorende icoon wordt lichtgrijs. Na het opnieuw aanklikken wordt de laag weer toegevoegd en het icoon donkerblauw. </p>"},{"location":"docs/handleiding/toevoegen-fotorealistische-wereld/","title":"Fotorealistische Wereld","text":"<p>Functies, Lagen, submenu.  </p> <p> (Afbeelding) Toevoegen / Fotorealistische Wereld</p>"},{"location":"docs/handleiding/toevoegen-fotorealistische-wereld/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":"<p>Met de functie Fotorealistische Wereld kunnen de 3D tiles van Google Earth worden gekoppeld en gevisualiseerd in Netherlands3D.eu.</p>"},{"location":"docs/handleiding/toevoegen-fotorealistische-wereld/#toevoegen","title":"Toevoegen","text":"<p>Klik op <code>Fotorealistische Wereld</code> en het de laag RealityMesh (3D Tiles) wordt toegevoegd en het Eigenschappenmenu wordt rechtsboven in het scherm geopend. (Afbeelding) Utrecht CS in 3DBAG </p> <p>Waarom is de deze functie beschermd?</p> <p>NB! Aangezien de 3D Google Earth Tiles een betaalde service van Google is, kan deze functie niet zonder inlogcode of sleutel worden vrijgegeven.  </p> <p>  Klik op <code>Update</code> om verder te gaan.  </p>"},{"location":"docs/handleiding/toevoegen-fotorealistische-wereld/#met-gebruikersnaam-en-wachtwoord","title":"Met Gebruikersnaam en Wachtwoord","text":"<p>Toegangsscherm met Gebruikersnaam en Wachtwoord:  (Afbeelding) Toegangsscherm met gebruikersnaam en wachtwoord  Voer bij de <code>Gebruikersnaam</code> en <code>Wachtwoord</code> en klik op <code>Bevestigen</code>. De 3D Tiles worden direct geladen. </p> <p>Ik heb geen toegangscode of sleutel. Wat kan ik doen?</p> <p>Indien er geen gebruikersnaam/wachtwoord beschikbaar is; Ga naar Google en maak via het Google-account een 'sleutel\u2019 aan. Hoe je dat doet lees je hier (externe link); Aanmaken Google-sleutel.</p>"},{"location":"docs/handleiding/toevoegen-fotorealistische-wereld/#met-google-sleutel","title":"Met Google sleutel","text":"<p>Klik op het vinkje in het <code>pull-down-menu</code> met het slotje naast Toegang bescherm... en het volgende menu verschijnt;  (Afbeelding) Toegangsscherm met Google-sleutel  Plak de sleutel in het veld <code>Typen</code> en klik op <code>Bevestigen</code>. De 3D Tiles worden direct geladen. </p> <p> (Afbeelding) Utrecht CS in Google Earth 3D Tiles </p> <p>Ik zie na het inloggen geen 3D Tiles in de viewer?</p> <p>NB! De Google Earth Tiles zijn (nog) niet voor heel Nederland zichtbaar/beschikbaar. Voor grote delen van NL geldt dat er alleen een topdown satellietfoto beschikbaar is.  </p> <p></p>"},{"location":"docs/handleiding/toevoegen-importeren/","title":"Importeren","text":"<p>Functies, Lagen, submenu.  </p> <p> (Afbeelding) Toevoegen / Importeren</p>"},{"location":"docs/handleiding/toevoegen-importeren/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":""},{"location":"docs/handleiding/toevoegen-importeren/#importeren-eigen-bestand","title":"Importeren Eigen bestand","text":"<p>De functie <code>Importeren</code> biedt de mogelijkheid om lagen en Objecten via het importeren van bestanden of via weblinks te koppelen.  (Afbeelding) Importeren Eigen bestand </p> <p>Met <code>Eigen bestand</code> kunnen .OBJ, .CSV, .JSON, .GEOJSON en .GLB bestanden worden gekoppeld. Na klikken op <code>Eigen bestand</code> opent de Verkenner (Windows)/Finder (MacOs) en kan het bestand worden geladen.  </p> <p>Drag and Drop</p> <p>Met klik en slepen van een bestand vanuit verkenner of Finder in het    viewervenster, worden bovenstaande formaten ook ingeladen. LET OP: Dit kan niet met meerdere bestanden tegelijk.</p>"},{"location":"docs/handleiding/toevoegen-importeren/#importeren-bestand-via-url","title":"Importeren bestand via URL","text":"<p> (Afbeelding) Importeren bestand via URL </p> <p>Met Importeren bestand via URL kan je databronnen (WFS, WMS, GeoJSON, 3D-Tiles) via een weblink koppelen. Klik op <code>Bestand via URL</code>. Het menu; Laag toevoegen via URL wordt geopend.   Kopie\u00ebr en plak de link van het bestand in het vakje [URL link].  In de nabije toekomst is hier een link naar veelgebruikte WFS/WMS-lagen te vinden.</p> <p>Na <code>Toevoegen</code> is de link gekoppeld en de data zichtbaar in de 3D-Viewer.  </p>"},{"location":"docs/handleiding/toevoegen-importeren/#voorbeelden","title":"Voorbeelden","text":""},{"location":"docs/handleiding/toevoegen-importeren/#bestand-importeren-met-obj","title":"Bestand Importeren met .OBJ","text":"<p>Stap1. Klik op <code>Eigen bestand</code> en importeer het .OBJ-bestand.  (Afbeelding) Gedetailleerde Domtoren middels .OBJ ge\u00efmporteerd. </p> <p>Na het importeren wordt het Object in de 3D omgeving en in de lijst onder Lagen zichtbaar.  </p> <p>Waarom heeft het geimporteerde Object niet de juiste afmetingen?</p> <p>De viewer neemt automatisch de ori\u00ebntatie en schaal van het Object (3D-model) zoals het is gemaakt over. Met de transformatie-tools kunnen de schaal en/of ori\u00ebntatie van het Object worden aangepast. Het is ook mogelijk om de schaal van het Object en/of ori\u00ebntatie in een extern 3D-programma zoals Blender aan te passen en opnieuw te importeren.   </p> <p>Stap 2a. Het geselecteerde Object kan met de transformatie-tools op de juiste locatie of aangepaste ori\u00ebntatie en schaal worden gebracht. Klik op het gekoppelde <code>Object</code> in Lagen en de transformatie-tool is geactiveerd.  (Afbeelding) Verplaatsen, roteren en verschalen met de transformatie-tool</p> <p>Stap 2b. Met de <code>Eigenschappen</code> -functie kan de locatie, ori\u00ebntatie en schaal van het geimporteerde Object handmatig worden ingevoerd.  </p> <p> (Afbeelding) Handmatig invoeren van locatie, ori\u00ebntatie en schaal. </p> <p>Stap 3. Met Bestand toevoegen kan het .mtl-bestand dat bij het .OBJ-bestand behoord aan het 3D-model gekoppeld. Hiermee wordt kleur- en textuur-informatie meegeladen met het 3D-model. Klik op <code>Bestand toevoegen</code> in het Eigenschappen-menu en selecteer het .mtl-bestand in de Verkenner/Finder.</p>"},{"location":"docs/handleiding/toevoegen-importeren/#bestand-bestand-via-url","title":"Bestand bestand via URL","text":"<p>Klik op Bestand via URL en koppel de link.  (Afbeelding) Voorbeeld 1;  Luchtfoto's van Nederland gekoppeld met WMS-link </p> <p> (Afbeelding) Voorbeeld 2;  Landelijke BRT kaart gekoppeld met WMS-link</p>"},{"location":"docs/handleiding/toevoegen-objecten-biep/","title":"Objecten bibliotheek","text":"<p>Functies, Lagen, submenu.  </p> <p></p> <p>(Afbeelding) Toevoegen / Objecten bibliotheek</p>"},{"location":"docs/handleiding/toevoegen-objecten-biep/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":"<p>Met de functie Objecten bibliotheek kunnen verschillende standaard objecten worden toegevoegd.</p> <p>Je kunt kiezen uit:</p> <ul> <li>Annotatie</li> <li>Camera Positie</li> <li>Kubus</li> <li>NAP Vlak</li> <li>Windmolen</li> <li>Reuzenrad</li> <li>Amerikaanse linde</li> <li>Berk</li> <li>Beuk</li> <li>Canadapopulier</li> <li>Ontwikkeling Zuidoost</li> </ul> <p> </p> <p>(Afbeelding) Toevoegen objecten uit de Objecten bibliotheek</p>"},{"location":"docs/handleiding/toevoegen-objecten-biep/#annotatie","title":"Annotatie","text":"<p>Klik op <code>Annotatie</code> om een opmerking in de viewer te plaatsen. De annotatie start blanco. Door er op te klikken kan je deze met tekst vullen. Je kan er ook meerdere maken, zodat je notities of opmerkingen bij kan houden.</p> <p> </p> <p>(Afbeelding) Annotatie ObjectenBibliotheek </p>"},{"location":"docs/handleiding/toevoegen-objecten-biep/#camera-positie","title":"Camera Positie","text":"<p>Klik op <code>Camera Positie</code> om een camera in de viewer te plaatsen. Je plaatst de  camera met de op dat moment ingestelde hoogte en kijkhoek. Op deze manier kan je verschillende camera standpunten maken en bewaren in een project, om zo makkelijk een \"view-path\" naar keuze te kunnen maken. </p> <p> </p> <p>(Afbeelding) Camera Positie </p>"},{"location":"docs/handleiding/toevoegen-objecten-biep/#kubus","title":"Kubus","text":"<p>Klik op <code>Kubus</code> om een kubus in de viewer zichtbaar te maken. De kubus heeft een standaardafmeting van 10x10x10 meter.</p> <p> </p> <p>(Afbeelding) Kubus ObjectenBibliotheek </p>"},{"location":"docs/handleiding/toevoegen-objecten-biep/#nap-vlak","title":"NAP Vlak","text":"<p>Klik op <code>NAP Vlak</code> om een (horizontaal)vlak in de viewer zichtbaar te maken. Met dit vlak kun je de NAP hoogte van een terrein of gebouw bepalen of eenvoudig laten zien welke gebieden in Nederland kunnen overstromen als de dijken doorbreken.</p> <p> </p> <p>(Afbeelding) NAP Vlak </p>"},{"location":"docs/handleiding/toevoegen-objecten-biep/#windmolen","title":"Windmolen","text":"<p>Klik op <code>Windmolen</code> om een Windmolen met draaiende rotor in de viewer zichtbaar te maken. De Windmolen heeft een standaardhoogte van 70 meter met een Rotordiameter van 54.50 meter. De afmetingen zijn aanpasbaar in het Instellingen menu van de Windmolen.</p> <p> </p> <p>(Afbeelding) Windmolen ObjectenBibliotheek</p>"},{"location":"docs/handleiding/toevoegen-objecten-biep/#reuzenrad","title":"Reuzenrad","text":"<p>Klik op <code>Reuzenrad</code> om een draaiend Reuzenrad in de viewer zichtbaar te maken.  </p> <p> </p> <p>(Afbeelding) Reuzenrad ObjectenBibliotheek</p>"},{"location":"docs/handleiding/toevoegen-objecten-biep/#bomen","title":"Bomen","text":"<p>Klik op <code>Amerikaanse Linde</code>, <code>Berk</code>, <code>Beuk</code> of <code>Canadapopulier</code> om de verschillende bomen uit de ObjectenBibliotheek in de viewer zichtbaar te maken.</p> <p> </p> <p>(Afbeelding) Bomen; vlnr Linde, Berk, Beuk of Canadapopulier ObjectenBibliotheek</p>"},{"location":"docs/handleiding/toevoegen-objecten-biep/#ontwikkeling-zuidoost","title":"Ontwikkeling Zuidoost","text":"<p>De functie Ontwikkeling Zuidoost is een bijzonder onderdeel van de Objecten Bibliotheek. Met deze functie worden de Nieuwbouwontwikkelingen in het gebied Amsterdam-Zuidoost in de viewer gekoppeld. Klik op <code>Ontwikkeling Zuidoost</code> om deze te activeren.</p> <p></p> <p>(Afbeelding) Ontwikkeling Amsterdam-Zuidoost</p>"},{"location":"docs/handleiding/toevoegen-selectiegebied/","title":"Selectiegebied","text":"<p>Functies, Lagen, submenu.  </p> <p> (Afbeelding) Toevoegen / Selectiegebied</p>"},{"location":"docs/handleiding/toevoegen-selectiegebied/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":"<p>Met deze functie is het mogelijk om \u00e9\u00e9n of meerdere Polygonen (gebieden),  lijnen of grids in te tekenen.  (Afbeelding) Toevoegen / Tekengebied</p> <p>Na klikken op <code>Selectiegebied</code> kan er gekozen worden uit het tekenen van een Polygoon, lijn of grid in de 3D-Viewer.  </p>"},{"location":"docs/handleiding/toevoegen-selectiegebied/#polygoon","title":"Polygoon","text":"<p>Klik op <code>Polygoon</code> en een kleine witte bol verschijnt bij de muisaanwijzer in het 3D scherm. Klik en teken hiermee het volledige veelvlak of polygoon. Sluit het vlak door na het aanbrengen van meerdere punten op de laatste punt te klikken. Hierdoor wordt het vlak ingekleurd. Door op een van de punten te klikken kan het vlak worden aangepast. (Afbeelding) Intekenen polygoon  Er kunnen meerdere selectiegebieden worden ingetekend. </p>"},{"location":"docs/handleiding/toevoegen-selectiegebied/#verspreid-objecten-in-gebied","title":"Verspreid objecten in gebied","text":"<p>Door een object zoals bijvoorbeeld een boom uit de Objectenbibliotheek toe te voegen aan de laag Polygon, kan de functie Verspreid objecten in gebied geactiveerd. (Afbeelding) Activeren functie Verspreid objecten in gebied.  Doorloop de volgende stappen;  </p> <ul> <li>Voeg een object (boom) toe uit de Objectenbibliotheek,  </li> <li>Sleep het object in Lagen op het Polygon,  </li> <li>klik op <code>eigenschappen</code> van het object,  </li> <li>vink <code>Verspreid objecten in gebied</code> aan,  </li> <li>pas eventueel de Eigenschappen van Verspreiden object aan. </li> </ul>"},{"location":"docs/handleiding/toevoegen-selectiegebied/#lijn","title":"Lijn","text":"<p>Klik op <code>Lijn</code> en een kleine witte bol verschijnt bij de muisaanwijzer in het 3D scherm. Klik in het scherm en teken hiermee de lijn door het eindpunt op de gewenste plek te plaatsen. [Kleuren aanpassen?] Door op \u00e9\u00e9n van de eindpunten te klikken kan de lijn worden aangepast. (Afbeelding) Intekenen lijn  De lijndikte kan worden aangepast door op het <code>instellingen-icoon</code> te klikken. Het Eigenschappenmenu verschijnt waarmee de lijndikte van 1.00 tot 200.00 meter kan worden aangepast. Standaard is de dikte 10.00 meter. (Afbeelding) Eigenschappen  Er kunnen meerdere lijnen worden ingetekend.  </p>"},{"location":"docs/handleiding/toevoegen-selectiegebied/#grid","title":"Grid","text":"<p>Klik op <code>Grid</code> en je kan met de muis, in combinatie met de linkermuisknop en shift-toets een selectiegebied selecteren.  </p> <p> (Afbeelding) Meerdere secties van 100x100 geselecteerd. </p> <p> (Afbeelding) Gridlaag toegevoegd. </p> <p> (Afbeelding) Eigenschappen gridlaag. </p> <p> (Afbeelding) Gebied uitsnijden in gridlaag. </p> <p> (Afbeelding) Uitgesneden gebied omdraaien. </p> <p>Er kunnen meerdere grids worden ingetekend. </p> <p>Masking and Clipping</p> <p>Bovenstaande handelingen kan je met alle selectiemogelijkheden uitvoeren. Dus ook met een polygoon en een lijn. Zo kan je meerdere gebieden uitsnijden of highlighten. </p> <p>Achteraf kan je de geselecteerde lijn(en), gebied(en) en grid(s) ook aanpassen. Bij lijnen en gebieden kan je de laag selecteren en de zichtbare punten oppakken en verplaatsen en bij een grid kan je een nieuwe selectie maken.</p> <p> (Afbeelding) Mogelijkheden uitgesneden gebieden. </p>"},{"location":"docs/handleiding/toevoegen-urban-releaf/","title":"Urban ReLeaf","text":"<p>Functies, Lagen, submenu.  </p> <p> (Afbeelding) Toevoegen / Urban ReLeaf</p>"},{"location":"docs/handleiding/toevoegen-urban-releaf/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":"<p>Met de functie Urban ReLeaf kunnen de resultaten van het Klimaatonderzoek dat van 1 juli tot en met 31 augustus 2024 is uitgevoerd in de Provincie Utrecht worden gekoppeld en gevisualiseerd.  Het klimaat is op drie factoren gemeten in de zones die als hexagoon worden weergegeven;</p> <ul> <li>Temperatuur  </li> <li>Vochtigheid  </li> <li>Thermisch ongemak  </li> </ul> <p>De kleur van de hexagoon vertegenwoordigd een gemiddelde van de gemeten waarden het gebied.  </p>"},{"location":"docs/handleiding/toevoegen-urban-releaf/#toevoegen","title":"Toevoegen","text":"<p>Door op <code>Temperatuur</code>, <code>Vochtigheid</code> en/of <code>Thermisch ongemak</code> te klikken wordt de bijbehorende laag toegevoegd en worden de hexagonen geladen. (Afbeelding) Toevoegen / Urban ReLeaf</p>"},{"location":"docs/handleiding/toevoegen-urban-releaf/#instellingen","title":"Instellingen","text":"<p>Door in Lagen op het <code>instellingen-icoon</code> te klikken kunnen de eigenschappen van de (temperatuur) weergave worden aangepast. (Afbeelding) Eigenschappen van de hexagoon-weergave </p> <p>Datum Met het aanpassen van de <code>Start datum</code> en/of de <code>Eind datum</code> kunnen de uitkomsten van een in \u2013te-stellen periode worden weergegeven. Standaard zijn de uitkomsten van de start tot het eind van het onderzoek weergegeven. </p> <p>Waarden Met het aanpassen van <code>Minimum waarde</code> en/of <code>Maximum waarde</code> \u2013 door de schuif naar links of naar rechts te verplaatsen - worden de gebieden die binnen de in-te-stellen bandbreedte vallen weergegeven. Met de <code>kleuren-tool</code> kan het kleurenverloop van minimum- naar maximumwaarde worden aangepast. (Afbeelding) Weergave uitkomsten Temperatuurmeting Urban ReLeaf   Kijk op https://urbanreleaf.eu/ voor meer informatie.  </p>"},{"location":"docs/handleiding/zoeken/","title":"Zoekfunctie","text":"<p>Functie, hoofdmenu.</p> <p></p> <p>     Met de zoekfunctie kan je, naast de zoekfunctie in het instellingenmenu,      ook binnen de 3D Viewer direct zoeken naar een adres of locatie.   </p>"},{"location":"docs/handleiding/zoeken/#gedetailleerde-beschrijving-van-de-functie","title":"Gedetailleerde beschrijving van de functie","text":""},{"location":"docs/handleiding/zoeken/#zoekbalk","title":"Zoekbalk","text":"<p>Na het klikken op het vergrootglas opent de zoekbalk.</p> <p></p> <p>(Afbeelding) Zoekbalk geopend </p>"},{"location":"docs/handleiding/zoeken/#zoekresultaat","title":"Zoekresultaat","text":"<p>Tijdens het invullen van een plaats of adres, vindt het systeem al de eerste resultaten. Staat de gewenste plaats of adres er al tussen, dan kan je direct op het resultaat klikken om deze te activeren. De camera springt dan direct naar de gekozen locatie.</p> <p></p> <p>(Afbeelding) Zoekbalk resultaat </p>"},{"location":"docs/handleiding/zonnestand/","title":"Zonnestand","text":"<p>Functies, hoofdmenu. </p> <p></p> <p>Zonnestand is een zon- en schaduw-simulatie tool die is ontwikkeld om gebruikers te helpen de impact van zonlicht en schaduwen in datalagen en ontwerpen op een specifieke locatie eenvoudig te visualiseren. Door gebruikers in staat te stellen basisparameters in te voeren, zoals tijd en datum, genereert Zonnestand real-time schaduwprojecties, waardoor het toegankelijk is voor data-specialisten, ontwerpers, docenten en hobbyisten.  Dit hoofdstuk beschrijft de belangrijkste functies van Zonnestand geeft uitleg over de interface en essenti\u00eble functies. Daarnaast is het mogelijk om een schaduwstudie te maken met de functie Schaduwstudie. Hiermee is het mogelijk om van de standaard 12 momenten in het jaar een schermafbeelding te maken en deze te downloaden via een .zip bestand. Deze afbeelding zijn bijvoorbeeld te gebruiken in stedenbouwkundige rapporten.</p>"},{"location":"docs/handleiding/zonnestand/#overzicht-van-functies","title":"Overzicht van functies","text":"<p>Door het aanpassen van datum en tijd wordt de zonnestand realistisch weergegeven voor de gekozen locatie en het gekozen moment. Met animatie tijdverloop wordt het verloop van de schaduw gedurende de dag en nacht realistisch weergegeven. De snelheid van het verloop is instelbaar. </p> <p>(Video) functie Zonnestand</p>"},{"location":"docs/handleiding/zonnestand/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":""},{"location":"docs/handleiding/zonnestand/#menu","title":"Menu","text":"<p>Door met de muis op het <code>Zonnestand-icoon</code> in het hoofdmenu te klikken wordt de tool actief. Het menu klapt open en de instellingen worden zichtbaar.</p> <p> (Afbeelding) Zonnestand-menu</p>"},{"location":"docs/handleiding/zonnestand/#werking","title":"Werking","text":"<ul> <li>Pull down    Door op de <code>pijl</code> te klikken wordt het menu <code>Tijd en datum aanpassen</code> ingeklapt. Door vervolgens weer op de <code>pijl</code> te klikken klapt het menu <code>Tijd en datum aanpassen</code> uit.</li> </ul> <ul> <li>Tijd en Datum 1    Vul het gewenste tijdstip bij <code>Tijd</code>    in <code>uur:minuut</code> en de gewenste datum bij <code>Datum</code> in <code>dag:maand;jaaren</code> en druk op <code>enter</code>.</li> </ul> <p>Het effect van de nieuwe zonnestand en bijbehorende schaduwval zijn direct zichtbaar.</p> <ul> <li>Tijd en Datum 2    Door het <code>Zon-icoon</code> handmatig over de gestippelde boog te verslepen wordt de zonnestand en bijbehorend tijdstip aangepast. Zonnestand houdt hierbij automatisch rekening met zonsopgang en \u2013ondergang. Zodra het tijdstip zich tussen zonsondergang en \u2013opgang bevindt, verandert het icoon in een maan. </li> </ul> <p></p> <p>In het geval het tijdstip zich tussen zonsondergang en \u2013opgang bevindt, is er geen schaduw zichtbaar.</p> <ul> <li>Tijd en Datum (herstel)   Door op het icoon <code>Herstel tijd en datum</code> te klikken wordt de actuele datum en tijd van het computersysteem van de gebruiker overgenomen.</li> </ul> <p></p> <ul> <li>Animatie tijdverloop realtime    Standaard staat de Snelheid animatie ingesteld op <code>realtime</code>. De <code>pauze- en afspeelknop</code> hebben geen functie.</li> </ul> <p></p> <ul> <li>Animatie tijdverloop uur per seconde    Door in het pull down menu te kiezen voor <code>uur per seconde</code> kan de animatie van het verloop van de zon vanaf de ingestelde datum en tijdstip worden gestart met de <code>afspeelknop</code>. De andere knoppen van de interface worden dan ook actief.   Met de <code>pauze knop</code> kan de animatie worden gestopt. Met de <code>forward</code> resp. <code>backward</code> knop kan de snelheid van de animatie met hele stappen van 1 uur per seconde worden versneld resp. vertraagd.</li> </ul> <p></p> <p>Opslaan instellingen De instellingen van de functie Zonnestand zijn onderdeel van het Netherlands 3D bestand en worden opgeslagen met de functie <code>Project Opslaan</code>.</p>"},{"location":"docs/handleiding/zonnestand/#schaduwstudie","title":"Schaduwstudie","text":"<p>Pull down  Door op de <code>pijl</code> te klikken wordt het menu <code>schaduwstudie</code> ingeklapt. Door vervolgens weer op de <code>pijl</code> te klikken klapt het menu <code>schaduwstudie</code> uit.</p> <p></p> <p>Download  Door op de knop <code>download</code> te klikken wordt een serie van 12 afbeeldingen gegenereerd volgens onderstaande normen en vervolgens verzameld in een <code>.zip</code> bestand met als naam <code>2025-03-05-T15-00-Schaduwstudie.zip</code> </p> <p></p> <p>De functie maakt afbeeldingen van de actuele camerastandpunt, dus houd er rekening mee dat de resultaten afhankelijk zijn van de keuze van het camerastandpunt.</p>"},{"location":"docs/handleiding/zonnestand/#verantwoording","title":"Verantwoording","text":"<p>Data en tijdstippen</p> <p>Hoewel voor de bezonningsuren overal de TNO-norm wordt aangehouden, is er voor de schaduwstudie geen offici\u00eble standaard. Wel wordt deze set data en tijden gebruikt door de meeste gemeenten en online tools: 21 maart en 23 september (halverwege tussen kortste en langste dag) 21 juni (dag met de meeste zonuren) 22 december (dag met de minste zonuren)</p> <ul> <li>21-03 (en/of 23-09) om 09:00u</li> <li>21-03 (en/of 23-09) om 12:00u</li> <li>21-03 (en/of 23-09) om 15:00u</li> <li>21-03 (en/of 23-09) om 18:00u</li> <li>21-06 om 09:00u</li> <li>21-06 om 12:00u</li> <li>21-06 om 15:00u</li> <li>21-06 om 18:00u</li> <li>21-06 om 20:00u</li> <li>22-12 om 09:00u</li> <li>22-12 om 12:00u</li> <li>22-12 om 15:00u</li> </ul> <p>Meer informatie over schaduwstudies en bezonning, staat op deze website https://iplo.nl/thema/licht/bezonning/</p> <p>Bepaling Zonnestand</p> <p>Algemeen Voor het bepalen van de zonnestand maken we gebruik van het NOAA Solar Position Algorithm (SPA). Voor meer informatie kijk op https://gml.noaa.gov/grad/solcalc/index.html</p> <p>Beheer van tijdzones en zonnestand berekening</p> <p>We maken gebruik van een eigen oplossing, omdat deze standaard niet in Unity beschikbaar is: voor meer informatie kijk op de tab voor organisaties https://netherlands3d.eu/docs/organisations/netherlands3d-platform/</p>"},{"location":"docs/organisations/cors/","title":"Mijn URL wil niet importeren door CORS, en nu?","text":"<p>Wat is CORS? Cross-Origin Resource Sharing (CORS) is een beveiligingsmechanisme dat webapplicaties beschermt door te controleren of ze verbinding mogen maken met een server op een ander domein dan het domein van de webapplicatie zelf. Zonder CORS zou een website toegang kunnen krijgen tot data van andere servers zonder toestemming, wat veiligheidsrisico\u2019s met zich meebrengt. In de praktijk betekent dit dat u, als beheerder van een webservice, uw server moet configureren om expliciet toestemming te geven aan externe toepassingen die uw data willen gebruiken.</p> <p>Waarom is CORS Configuratie Uw Verantwoordelijkheid Omdat CORS een beveiligingsmaatregel is van en voor de  data-aanbieder, kan de configuratie niet vanuit een Netherlands3D viewer worden ingesteld. Webapplicaties, zoals een  Netherlands3D viewer, moeten toegang tot data krijgen via de server die deze data aanbiedt. Zonder CORS-headers  blokkeert de browser toegang om de privacy en veiligheid van de server te waarborgen.</p> <p>Waarom hebben desktopapplicaties zoals QGIS geen last van CORS?</p> <p>CORS-beperkingen gelden alleen voor webbrowsers die webapplicaties beschermen tegen ongeautoriseerde toegang tot  data. Desktopapplicaties zoals QGIS communiceren rechtstreeks met servers zonder de CORS-beperkingen van  webbrowsers en kunnen daardoor zonder beperkingen externe data ophalen.</p>"},{"location":"docs/organisations/cors/#configureer-cors-in-uw-applicatie-of-webserver","title":"Configureer CORS in uw Applicatie of Webserver","text":"<p>Wat moet u doen? Om CORS toe te staan, moet u specifieke HTTP-headers configureren in de webserver of  applicatieserver. De belangrijkste header is: <code>Access-Control-Allow-Origin: *</code> (of in plaats van <code>*</code> een specifieke  domeinnaam, zoals https://netherlands3d.eu). </p> <p>Afhankelijk van de technologie, zoals MapServer of ArcGIS Server, kunt u deze headers toevoegen in de  serverinstellingen of in configuratiebestanden.</p> <p>Voorbeeldinstellingen in MapServer en ArcGIS:</p> <ul> <li> <p>MapServer: Voeg de CORS-headers toe in de configuratie door de mapfile aan te passen of via de    webserverconfiguratie (bijv. Apache).</p> </li> <li> <p>ArcGIS Server: Open de service-instellingen in ArcGIS Manager en configureer de CORS-headers onder    \"Allowed Origins\".</p> </li> </ul>"},{"location":"docs/organisations/cors/#verificatie-van-de-cors-configuratie","title":"Verificatie van de CORS Configuratie","text":"<ol> <li>Open Google Chrome en ga naar de Inspect-tool (rechterklik op de pagina &gt; Inspecteren).</li> <li>Ga naar het Network-tabblad en laad de pagina van uw webservice.</li> <li>Zoek naar de aanvraag die uw webservice adresseert, klik erop en kijk onder Headers.</li> <li>Onder \"Response Headers\" zou u <code>Access-Control-Allow-Origin</code> moeten zien staan. Als de header correct geconfigureerd     is, staat hier het domein dat u heeft toegestaan of een <code>*</code> voor alle domeinen.</li> </ol> <p>Met deze stappen zorgt u ervoor dat uw data veilig toegankelijk is voor webapplicaties die de juiste toegang nodig  hebben.</p>"},{"location":"docs/organisations/netherlands3d-platform/","title":"Netherlands3D Platform","text":"<p>De visie van Netherlands3D is 3D Data Visualisatie van Nederland voor Iedereen.</p> <p>Hoe bereiken we dit?</p> <ul> <li>Open Web Platform: Een open omgeving waar 3D-data eenvoudig kan worden samengebracht door eindgebruikers en   organisaties.</li> <li>Beheerde Web Omgeving: Ontzorging voor organisaties die hun 3D-data willen tonen in een beheerde omgeving.</li> <li>Integraties: Ontzorging voor Unity ontwikkelaars om eigen integraties te ontwikkelen voor hun eigen data.</li> </ul> <p>Dit maken we mogelijk door het platform in drie edities aan te bieden:</p> <ul> <li>Netherlands3D Community: een gedeelde omgeving, direct beschikbaar voor iedereen.</li> <li>Netherlands3D Cloud: een eigen omgeving, door ons beheerd of binnen de eigen organisatie.</li> <li>Netherlands3D Developer: Een opensource platform op Github waar je integraties kunt ontwikkelen of een volledig   aangepaste viewer kunt maken.</li> </ul> <p>Middels deze drie edities kunnen organisaties 3D-data visualiseren in een gedeelde of eigen Netherlands3D viewer, of integraties ontwikkelen om hun eigen 3D-data te tonen.</p>"},{"location":"docs/organisations/netherlands3d-platform/#keuzehulp","title":"Keuzehulp","text":"<p>Om een indruk te geven welke editie van Netherlands3D past voor jouw organisatie, is hier een overzicht van  eigenschappen:</p> Community CloudEigen Beheer CloudBeheerd door ons Developer Direct gebruiksklaar Installatie wordt door ons verzorgd Eigen domeinnaam mogelijk Volledig in eigen beheer Geen ontwikkelaars nodig Geen cloud platform expertise nodig Personalisering mogelijk <sup>1</sup> Eigen lagen bij openen beschikbaar Maatwerk mogelijk Ondersteuning <sup>2</sup> <sup>3</sup> Kosten Gratis Gratis<sup>4</sup> Variabel Gratis / Open Source Updates Automatisch Handmatig Automatisch Handmatig <p>*<sup>1</sup> Beperkte personalisering opties zijn in ontwikkeling. *<sup>2</sup> Community editie heeft ondersteuning voor het beschikbaar zijn van de applicatie. *<sup>3</sup> Developer editie heeft community ondersteuning. *<sup>4</sup> Kosten voor gebruik van het platform zijn gratis, bij eigen beheer komen kosten van de eigen hosting    daar wel bij </p> <p>Elk van deze edities bevat dezelfde functionaliteiten in de viewer. Welke functionaliteiten beschikbaar zijn is te vinden op ons overzicht.</p>"},{"location":"docs/organisations/netherlands3d-platform/#welke-editie-past-bij-jouw-behoefte","title":"Welke editie past bij jouw behoefte?","text":"<ul> <li>Netherlands3D Community: Voor als je wil uitproberen, even snel een toegestuurd project wil bekijken of een    makkelijke instap zoekt.</li> <li>Netherlands3D Cloud: Voor als je een eigen omgeving wilt met extra beheermogelijkheden.</li> <li>Netherlands3D Developer: Voor als je volledige controle wilt over je 3D-visualisaties en maatwerkoplossingen    nodig hebt.</li> </ul>"},{"location":"docs/organisations/solarstudy-calculation/","title":"Verantwoording zonnestudie berekening","text":""},{"location":"docs/organisations/solarstudy-calculation/#beheer-van-tijdzones-en-zonnestand-berekening-in-unity","title":"Beheer van tijdzones en zonnestand berekening in Unity","text":"<p>Om tijdzones correct te beheren en de zonnestand nauwkeurig te berekenen, is een aangepaste oplossing ge\u00efmplementeerd in Unity. Deze oplossing maakt gebruik van een externe package voor tijdzonebepaling op basis van geografische co\u00f6rdinaten en twee aanvullende datasets met historische en toekomstige tijdzone-offsets.</p>"},{"location":"docs/organisations/solarstudy-calculation/#tijdzonebepaling-op-basis-van-coordinaten","title":"Tijdzonebepaling op basis van co\u00f6rdinaten","text":"<ul> <li>Er is een aangepaste versie van de GeoTimeZone-package gebruikt (oorspronkelijk van GitHub: mattjohnsonpint/GeoTimeZone).</li> <li>Deze package converteert latitude/longitude-co\u00f6rdinaten naar een IANA time zone identifier (bijv. Europe/Amsterdam).</li> <li>Dit maakt de implementatie OS-onafhankelijk, waardoor er geen verschillen meer zijn tussen Windows (bijv. W. Europe Standard Time) en andere systemen.</li> <li>De tijdzonegegevens worden uit een bestand in de Resources map uitgelezen en in Unity geladen. Dit bestand bevat een vast aantal gegevens en moet handmatig worden ge\u00fcpdatet om veranderingen in de tijdzones en de zomer/wintertijd te bevatten die sinds 2019 mogelijkerwijs plaats hebben gevonden.</li> </ul>"},{"location":"docs/organisations/solarstudy-calculation/#tijdzone-offsets-en-historische-data","title":"Tijdzone-offsets en historische data","text":"<ul> <li>De aanvullende datasets bevat IANA time zones en hun UTC-offsets voor verschillende tijdsperiodes.</li> <li>Voor Nederland omvat deze dataset de periode \"1916 tot 2037.\"</li> <li>Ook deze datasets zijn op de Unity-manier ingeladen en verwerkt.</li> </ul>"},{"location":"docs/organisations/solarstudy-calculation/#verbeterde-zonnestand-berekening","title":"Verbeterde zonnestand berekening","text":"<ul> <li>Voorheen zat er een bug in omdat de tijdzone conversie niet werkte in WebGL, waardoor de zonnestand een afwijking had van 1 of 2 uur (afhankelijk van de zomer/wintertijd) omdat de tijd altijd als UTC tijd werd ge\u00efnterpreteerd, in plaats van de tijd die voor Amsterdam geldt (Central European Time, CET).</li> <li>Nu is ook de tijdzone van de floating origin meegenomen in de berekening.</li> <li>Dit zorgt ervoor dat de tijd correct is omgerekend naar UTC, wat resulteert in een nauwkeurigere zonnestand in de simulatie.</li> </ul> <p>Conclusie</p> <p>Door deze aanpak is tijdzonebeheer verbeterd en is de zonnestandberekening betrouwbaarder en consistenter over verschillende platforms en tijdzones.</p>"},{"location":"docs/voorbeelden/","title":"Onboarding","text":"<p>Het hoofdstuk Onboarding van Netherlands3D.eu is speciaal opgezet voor gebruikers om stap voor stap te helpen bij het inrichten van de viewer voor specifieke cases.</p> <p>Het proces van inrichten wordt in heldere stappen uitgelegd en ondersteund door filmpjes.</p>"},{"location":"docs/voorbeelden/#onder-ontwikkeling","title":"Onder ontwikkeling","text":"<p>We werken momenteel aan de ontwikkeling van deze sectie om een uitgebreide lijst van  cases te beschrijven. Het doel is om gebruikers en organisaties te ondersteunen met deze onboarding documentatie bij het gebruik van het Netherlands3D platform.</p> <p>Blijf op de hoogte voor updates en verbeteringen aan deze sectie. We kijken ernaar uit om te voorzien in de informatie en hulpmiddelen die nodig zijn om goed gebruik te maken van Netherlands3D.</p>"},{"location":"docs/voorbeelden/3d-tiles-importeren/","title":"Importeren van een 3D Tiles-link","text":"<p>Deze documentatie helpt je stap voor stap bij het importeren van 3D Tiles in Netherlands3D. Houdt de link - dit is vaak een url - bij de hand.</p>"},{"location":"docs/voorbeelden/3d-tiles-importeren/#stap-1-open-de-3d-viewer","title":"Stap 1. Open de 3D-Viewer","text":"<p>Ga naar https://netherlands3d.eu, klik op de knop <code>Bekijk de viewer</code> en de 3D-viewer wordt geopend.</p> <p></p> <p>(Afbeelding) Homepage  </p> <p></p> <p>(Afbeelding) 3D-Viewer startscherm; instellingen-menu</p>"},{"location":"docs/voorbeelden/3d-tiles-importeren/#stap-2-klik-op-de-plus","title":"Stap 2. Klik op de plus","text":"<p>(Afbeelding) Basislagen &amp; functionaliteiten</p> <ul> <li>Het lagen paneel klapt open en de basislagen (links boven) en de functies (links onder) worden zichtbaar.</li> <li>Het Toevoegen-menu en de verschillende teken-, koppel- en importmogelijkheden worden (gedeeltelijk) zichtbaar.</li> </ul>"},{"location":"docs/voorbeelden/3d-tiles-importeren/#stap-3-bestand-toevoegen-met-url","title":"Stap 3. Bestand toevoegen met url","text":"<p>(Afbeelding) Toevoegen / Importeren</p> <p>Klik op <code>Importeren</code>. Het menu; Toevoegen Importeren wordt geopend.  </p> <p></p> <p>(Afbeelding) Bestand via URL</p> <p>Klik op <code>Bestand via URL</code>. Het menu Laag toevoegen via URL wordt geopend.  </p> <p> </p> <p>(Afbeelding) Kopi\u00ebren en plakken van URL</p> <p>Kopie\u00ebr en plak de link van het bestand in het vakje [URL link] en klik op <code>Toevoegen</code>.</p>"},{"location":"docs/voorbeelden/3d-tiles-importeren/#stap-4-navigeer-naar-de-3d-tiles-data","title":"Stap 4. Navigeer naar de 3D Tiles-data","text":"<p>Na <code>Toevoegen</code> is de link gekoppeld en is de laag zichtbaar in het <code>Lagen</code> paneel.</p> <p>Ga naar de locatie waar de 3D Tiles-link betrekking op heeft om de 3D Tiles laag in de 3D-Viewer te bekijken.</p> <p>Sla het project op met <code>Project Opslaan</code> (links onder) om de koppeling te bewaren.</p> <p>Snel naar locatie van de data</p> <p>Bij datasets die alleen data op een bepaalde locatie omvatten kan je ook dubbelklikken op de nieuwe laag. De camera verplaatst dan naar de locatie waar de data zich bevind.</p>"},{"location":"docs/voorbeelden/wms-wfs/","title":"Importeren van een WMS/WFS-link","text":"<p>Deze documentatie helpt je stap voor stap bij het koppelen van een WMS/WFS-link in Netherlands3D. Houdt de link - dit is vaak een url - bij de hand.</p> <p>Info</p> <p>De link bevat meestal de term <code>?service=WFS&amp;request=GetCapabilities</code> of <code>?service=WMS&amp;request=GetCapabilities</code>. Is  dat niet het geval en je ontvangt een foutmelding bij het importeren? Probeer een van deze twee toe te voegen aan  je link.  </p>"},{"location":"docs/voorbeelden/wms-wfs/#instructie-video","title":"Instructie-video","text":"<p>In onderstaande video wordt stap voor stap het toevoegen van een WMS/WFS-link uitgelegd.</p> <p>(Video) toevoegen WMS/WFS-link</p>"},{"location":"docs/voorbeelden/wms-wfs/#stap-1-open-de-3d-viewer","title":"Stap 1. Open de 3D-Viewer","text":"<p>Ga naar https://netherlands3d.eu, klik op de knop <code>Bekijk de viewer</code> en de  3D-viewer wordt geopend.</p> <p></p> <p>(Afbeelding) Homepage  </p> <p></p> <p>(Afbeelding) 3D-Viewer startscherm; instellingen-menu</p>"},{"location":"docs/voorbeelden/wms-wfs/#stap-2-klik-op-de-plus","title":"Stap 2. Klik op de plus","text":"<p>(Afbeelding) Basislagen &amp; functies</p> <ul> <li>Het lagen paneel klapt open en de basislagen (links boven) en de functies (links onder) worden zichtbaar.</li> <li>Het Toevoegen-menu en de verschillende teken-, koppel- en importmogelijkheden worden (gedeeltelijk) zichtbaar.</li> </ul>"},{"location":"docs/voorbeelden/wms-wfs/#stap-3-bestand-toevoegen-met-url","title":"Stap 3. Bestand toevoegen met url","text":"<p>(Afbeelding) Toevoegen / Importeren</p> <p>Klik op <code>Importeren</code>. Het menu; Toevoegen Importeren wordt geopend.  </p> <p></p> <p>(Afbeelding) Bestand via URL</p> <p>Klik op <code>Bestand via URL</code>. Het menu Laag toevoegen via URL wordt geopend.  </p> <p> </p> <p>(Afbeelding) Kopi\u00ebren en plakken van URL</p> <p>Kopie\u00ebr en plak de link van het bestand in het vakje [URL link] en klik op <code>Toevoegen</code>.</p>"},{"location":"docs/voorbeelden/wms-wfs/#stap-4-navigeer-naar-de-wmswfs-data","title":"Stap 4. Navigeer naar de WMS/WFS-data","text":"<p>Na <code>Toevoegen</code> is de link gekoppeld en zijn de sublagen (in het geval van een WFS) in Lagen zichtbaar. Ga naar de locatie waar de WMS/WFS-link betrekking op heeft om de WMS/WFS-Laag in de 3D-Viewer te bekijken.</p> <p>Sla het project op met <code>Project Opslaan</code> (links onder) om de koppeling te bewaren.</p> <p>Snel naar locatie van de data</p> <p>Bij datasets die alleen data op een bepaalde locatie omvatten kan je ook dubbelklikken op de nieuwe laag. De camera verplaatst dan naar de locatie waar de data zich bevind.</p>"},{"location":"articles/archive/2024/","title":"2024","text":""},{"location":"articles/nieuws/","title":"Nieuws","text":""}]}