{"config":{"lang":["nl"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"","text":""},{"location":"#netherlands3d","title":"Netherlands3D","text":"<p>Netherlands3D, het open-source Digital Twin-framework ontworpen voor Nederland. </p> <p>Door middel van datavisualisatie stelt Netherlands3D u in staat om gedetailleerde, op data gebaseerde modellen weer te  geven.</p> <p>Bekijk de viewer Wat is het?</p>"},{"location":"#wat-is-netherlands3d","title":"Wat is Netherlands3D?","text":""},{"location":"#visualiseren-van-data","title":"Visualiseren van data","text":"<p>Zoek je een mogelijkheid om data aantrekkelijk en in samenhang in  beeld te brengen in een 3D omgeving? Dat kan in Netherlands 3D!</p> <p>Netherlands3D maakt het mogelijk datasets vanaf verschillende bronnen en in verschillende bestandsformaten te koppelen en in samenhang te  visualiseren. Heb je een interessante dataset of link in GeoJSON of WFS  formaat? Ontdek dan hoe deze er in Netherlands 3D uit ziet.  Gecombineerd met andere datasets en in 3D context geeft dit vaak n\u00e8t  dat beetje extra informatie dat je nodig hebt.</p> <p>Naast het visualiseren van data, zijn er ook een aantal functionaliteiten  beschikbaar die je kunt inzetten om jouw project tot een succes te  maken. Kies de relevante tools simpelweg bij het opstarten van  Netherlands 3D.</p>"},{"location":"#wat-onderscheid-netherlands3d-van-andere-viewers","title":"Wat onderscheid Netherlands3D van andere viewers?","text":"<p>Netherlands 3D richt zich op data-visualisatie. Het aantrekkelijk,  integraal en begrijpelijk verbeelden van data staat centraal. </p> <p>Wat Netherlands 3D verder onderscheid is dat jij als gebruiker zelf kiest  welke data er gevisualiseerd wordt en welke functionaliteiten je daarbij  wilt gebruiken. Dus geen lijsten met vooraf gedefinieerde kaartlagen  maar slechts koppelmogelijkheden naar databronnen en externe  applicaties waar jij op dat moment in jouw project behoefte aan hebt.  Denk aan bronnen van jouw lokale server, het landelijke dataloket PDOK  of diverse dataportalen van gemeentelijke en provinciale organisaties.</p>"},{"location":"#heel-nederland-uniform-en-consistent-beschikbaar","title":"Heel Nederland uniform en consistent beschikbaar","text":"<p>Netherlands 3D combineert voor heel Nederland een aantal basis  datasets waardoor een eenduidig 3D beeld van Nederland ontstaat.</p> <p>Op dit moment zijn dat de 3D BAG, de 3D Basisvoorziening en boomlocaties  uit de BGT. Het gezamenlijke 3D beeld dat ontstaat kun je gebruiken als  input voor jouw project. Groot voordeel is dat deze brondata voor heel  Nederland uniform en consistent beschikbaar wordt gemaakt. Dus altijd  gemakkelijk en vanaf \u00e9\u00e9n plek te gebruiken. Het kan ook input zijn als  basis voor rekenmodellen en simulatiesoftware of juist de output  daarvan zijn zodat uitkomsten aan een breed publiek getoond kunnen  worden. Voor het realiseren van koppelingen tussen Netherlands 3D en  reken- simulatie- en analysetools, nodigen we iedereen actief uit om  mee te ontwikkelen.</p>"},{"location":"#3d-omgeving-op-maat","title":"3D omgeving op maat","text":"<p>Wil iets specifieks dat meer aansluit bij jouw project of organisatie?</p> <p>Netherlands 3D biedt een oplossing om een eigen 3D omgeving op maat  in te richten. Bijvoorbeeld een aangepaste startlocatie of vooraf  ingestelde functionaliteiten en datasets. Meldt je dan als organisatie aan. Tot slot is er voor ontwikkelaars de mogelijkheid om actief mee te  bouwen aan het platform. </p> <p>We nodigen iedereen dan ook actief uit om  met ons mee te denken en te bouwen. En wil je dat allemaal niet?  Gebruik dan gewoon de basisviewer van Netherlands 3D hier!</p>"},{"location":"#in-samenwerking-met","title":"In samenwerking met","text":""},{"location":"_nieuws/","title":"nieuws","text":""},{"location":"_nieuws/#nieuws","title":"Nieuws","text":"<ul> <li> <p>Beginnen in 5 minuten</p> <p>Ontdek de mogelijkheden van Netherlands3D.</p> <p>Lees verder </p> </li> <li> <p></p> <p>Je eigen cloud, of niet?</p> <p>Beheer je Netherlands3D zelf of laat je je ontzorgen?</p> <p>Vind het uit </p> </li> <li> <p></p> <p>Toon de kaart die jij wil</p> <p>Wil je jouw project, stad, gemeente of provincie laten zien? Dat kan.</p> <p>Ontdek de opties </p> </li> </ul>"},{"location":"_uitgelicht/","title":"uitgelicht","text":""},{"location":"_uitgelicht/#uitgelicht","title":"Uitgelicht","text":"<ul> <li> <p> Beginnen in 5 minuten</p> <p>Ontdek de mogelijkheden van Netherlands3D.</p> <p>Lees verder </p> </li> <li> <p> Je eigen cloud, of niet?</p> <p>Beheer je Netherlands3D zelf of laat je je ontzorgen?</p> <p>Vind het uit </p> </li> <li> <p> Toon de kaart die jij wil</p> <p>Wil je jouw project, stad, gemeente of provincie laten zien? Dat kan.</p> <p>Ontdek de opties </p> </li> </ul>"},{"location":"_wat-is-netherlands3d/","title":"wat is netherlands3d","text":""},{"location":"_wat-is-netherlands3d/#wat-is-netherlands3d","title":"Wat is Netherlands3D?","text":""},{"location":"_wat-is-netherlands3d/#visualiseren-van-data","title":"Visualiseren van data","text":"<p>Zoek je een mogelijkheid om data aantrekkelijk en in samenhang in  beeld te brengen in een 3D omgeving? Dat kan in Netherlands 3D!</p> <p>Netherlands3D maakt het mogelijk datasets vanaf verschillende bronnen en in verschillende bestandsformaten te koppelen en in samenhang te  visualiseren. Heb je een interessante dataset of link in GeoJSON of WFS  formaat? Ontdek dan hoe deze er in Netherlands 3D uit ziet.  Gecombineerd met andere datasets en in 3D context geeft dit vaak n\u00e8t  dat beetje extra informatie dat je nodig hebt.</p> <p>Naast het visualiseren van data, zijn er ook een aantal functionaliteiten  beschikbaar die je kunt inzetten om jouw project tot een succes te  maken. Kies de relevante tools simpelweg bij het opstarten van  Netherlands 3D.</p>"},{"location":"_wat-is-netherlands3d/#wat-onderscheid-netherlands3d-van-andere-viewers","title":"Wat onderscheid Netherlands3D van andere viewers?","text":"<p>Netherlands 3D richt zich op data-visualisatie. Het aantrekkelijk,  integraal en begrijpelijk verbeelden van data staat centraal. </p> <p>Wat Netherlands 3D verder onderscheid is dat jij als gebruiker zelf kiest  welke data er gevisualiseerd wordt en welke functionaliteiten je daarbij  wilt gebruiken. Dus geen lijsten met vooraf gedefinieerde kaartlagen  maar slechts koppelmogelijkheden naar databronnen en externe  applicaties waar jij op dat moment in jouw project behoefte aan hebt.  Denk aan bronnen van jouw lokale server, het landelijke dataloket PDOK  of diverse dataportalen van gemeentelijke en provinciale organisaties.</p>"},{"location":"_wat-is-netherlands3d/#heel-nederland-uniform-en-consistent-beschikbaar","title":"Heel Nederland uniform en consistent beschikbaar","text":"<p>Netherlands 3D combineert voor heel Nederland een aantal basis  datasets waardoor een eenduidig 3D beeld van Nederland ontstaat.</p> <p>Op dit moment zijn dat de 3D BAG, de 3D Basisvoorziening en boomlocaties  uit de BGT. Het gezamenlijke 3D beeld dat ontstaat kun je gebruiken als  input voor jouw project. Groot voordeel is dat deze brondata voor heel  Nederland uniform en consistent beschikbaar wordt gemaakt. Dus altijd  gemakkelijk en vanaf \u00e9\u00e9n plek te gebruiken. Het kan ook input zijn als  basis voor rekenmodellen en simulatiesoftware of juist de output  daarvan zijn zodat uitkomsten aan een breed publiek getoond kunnen  worden. Voor het realiseren van koppelingen tussen Netherlands 3D en  reken- simulatie- en analysetools, nodigen we iedereen actief uit om  mee te ontwikkelen.</p>"},{"location":"_wat-is-netherlands3d/#3d-omgeving-op-maat","title":"3D omgeving op maat","text":"<p>Wil iets specifieks dat meer aansluit bij jouw project of organisatie?</p> <p>Netherlands 3D biedt een oplossing om een eigen 3D omgeving op maat  in te richten. Bijvoorbeeld een aangepaste startlocatie of vooraf  ingestelde functionaliteiten en datasets. Meldt je dan als organisatie aan. Tot slot is er voor ontwikkelaars de mogelijkheid om actief mee te  bouwen aan het platform. </p> <p>We nodigen iedereen dan ook actief uit om  met ons mee te denken en te bouwen. En wil je dat allemaal niet?  Gebruik dan gewoon de basisviewer van Netherlands 3D hier!</p>"},{"location":"articles/","title":"Artikelen","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam sodales est nec dolor luctus cursus. Sed tincidunt orci fermentum varius mattis. Quisque ut molestie augue, sit amet ornare sem. Praesent sit amet auctor nisi. Vivamus ornare tincidunt arcu in euismod. Proin ipsum ante, semper et sollicitudin eget, venenatis maximus nulla. Suspendisse potenti. Nulla facilisi.</p>"},{"location":"articles/2024/04/25/nieuwe-website/","title":"Nieuwe website","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam sodales est nec dolor luctus cursus. Sed tincidunt orci fermentum varius mattis. Quisque ut molestie augue, sit amet ornare sem. Praesent sit amet auctor nisi. Vivamus ornare tincidunt arcu in euismod. Proin ipsum ante, semper et sollicitudin eget, venenatis maximus nulla. Suspendisse potenti. Nulla facilisi.</p> <p>Fusce rutrum mi vel purus interdum imperdiet. Curabitur tempus fermentum odio et venenatis. In hac habitasse platea dictumst. Praesent pellentesque odio vel suscipit malesuada. Nulla facilisis mauris euismod pulvinar ullamcorper. Ut tincidunt lacus vitae nibh faucibus iaculis. Phasellus vitae risus ex.</p> <p>Donec at orci urna. Ut ac turpis nec quam luctus cursus. Nunc lobortis quam vitae iaculis dignissim. Vestibulum pretium, nulla id volutpat luctus, mauris leo rhoncus tortor, ut fringilla massa purus in erat. Donec blandit id sem et accumsan. Pellentesque at eleifend urna. Mauris quis odio odio. Interdum et malesuada fames ac ante ipsum primis in faucibus. Vivamus sollicitudin magna libero, eget congue odio mollis gravida. Praesent arcu tellus, ultrices id porttitor vitae, tincidunt quis dolor. Vivamus aliquet nulla non augue molestie, sed elementum nisl maximus. Curabitur ut augue eu urna ornare hendrerit sed at dolor. Duis vulputate ullamcorper viverra. Proin id urna sed turpis euismod blandit. Etiam gravida ipsum eu ligula lacinia, ut ultricies magna porta. Cras sem metus, commodo tincidunt ultricies fringilla, facilisis sit amet enim.</p> <p>Pellentesque nibh dui, iaculis at vehicula in, iaculis ut dui. Donec ac nisl eget massa pellentesque vehicula. Morbi interdum magna ac leo malesuada commodo. Nulla ac risus ut lectus eleifend semper. Nullam placerat sem quis lectus aliquam tristique. Nullam ante nisl, laoreet ut elit eu, laoreet gravida ex. Aenean eget sagittis magna. Donec non faucibus leo. Nullam rutrum euismod nisl, sed consequat arcu imperdiet et. Vivamus sit amet mi placerat, luctus sem a, posuere sem. Aliquam feugiat est eget risus dapibus efficitur.</p> <p>Nam vehicula sollicitudin nibh, at efficitur ligula tincidunt in. Pellentesque turpis nibh, tempor vitae consequat non, molestie ac turpis. Duis tempor vulputate urna, non iaculis velit faucibus vel. Aliquam erat volutpat. Donec eu porttitor lacus, in dignissim odio. Nam at laoreet sapien, pharetra scelerisque sapien. Nulla sed quam pretium, pellentesque dolor pharetra, aliquam nulla.</p>"},{"location":"docs/developers/adding-a-simple-type-of-layer/","title":"Adding a simple type of layer","text":"<p>In this step-by-step guide, you\u2019ll learn to add a new layer type, ideal for developers ready to start building within the platform.</p> <p>Note: Steps 6 and 7 may change as functionalities become more independent, reducing the need for adjustments in the  Twin application.</p>"},{"location":"docs/developers/adding-a-simple-type-of-layer/#step-1-pick-a-functionality-or-create-a-new-one","title":"Step 1: Pick a Functionality, or Create a New One","text":"<p> Layers are part of a Functionality and to maintain the necessary structure it is recommended to pick the functionality to which the layer should belong or, if this is the first time adding your own material,it is recommended to create  your own.</p> <p>To create a Functionality, create a subfolder in <code>Assets/_Functionalities</code> and name it after the functionality that will  manage this new layer, and add a new subfolder <code>Prefabs</code> to it; here we will place our new layer prefab.</p>"},{"location":"docs/developers/adding-a-simple-type-of-layer/#step-2-create-a-prefab-to-visualize-the-layer","title":"Step 2: Create a Prefab to Visualize the Layer","text":"<p>Create a new prefab to represent your layer. This can include 3D objects as needed for the layer's visual appearance. This prefab serves as the visual representation of your data in the 3D viewer.</p> <p>An example of this could be a Prefab that we call '2 Cubes', where we add two Cubes from Unity's '3D Object' creation  menu.</p>"},{"location":"docs/developers/adding-a-simple-type-of-layer/#step-3-attach-the-hierarchicalobjectlayergameobject-component","title":"Step 3: Attach the <code>HierarchicalObjectLayerGameObject</code> Component","text":"<p>Add the <code>HierarchicalObjectLayerGameObject</code> MonoBehaviour to your prefab. Leave the <code>Prefab Identifier</code> field empty or assign a unique identifier to make sure this layer is globally unique. This identifier will allow the prefab to register as a new layer within the layer system upon instantiation.</p> <p>This component will automatically add a Layer -to the project and in the UI- when an instance of this prefab is  added to the scene. </p> <p>Leaving the <code>Prefab Identifier</code> empty will allow for the <code>PrefabLibrary</code> (see Step 6) to assign a unique identifier, thus populating it when the prefab is added to the library.</p>"},{"location":"docs/developers/adding-a-simple-type-of-layer/#step-4-add-the-worldtransform-component","title":"Step 4: Add the WorldTransform Component","text":"<p>To ensure the object holds real-world coordinates and remains anchored in place as the user navigates, add the WorldTransform MonoBehaviour to your prefab. This enables the object to maintain accurate positioning in the 3D environment.</p> <p>The World Transform is similar to, and extends, Unity's own Transform, it provides the means for an object to be  located in a real world position and to track that. </p> <p>When you want to move a GameObject with a WorldTransform, it is highly recommended to do that by changing the Coordinates on the WorldTransform instead of the <code>transform.position</code>.</p>"},{"location":"docs/developers/adding-a-simple-type-of-layer/#step-5-optional-add-transform-properties-to-your-layer","title":"Step 5: (Optional) Add Transform properties to your layer","text":"<p>If you want users to reposition, rotate, or scale this layer in the viewer, add the <code>HierarchicalObjectPropertySectionInstantiator</code> component. Set its Property Section Reference to  <code>TransformPropertySection</code>, enabling these manipulations within the project and allowing them to persist in the  <code>.nl3d</code> project file.</p> <p>You can learn more about properties and property sections in the explanation section of the documentation.</p>"},{"location":"docs/developers/adding-a-simple-type-of-layer/#step-6-register-the-prefab-in-the-prefablibrary","title":"Step 6: Register the Prefab in the PrefabLibrary","text":"<p>To ensure the layer system recognizes and loads this layer, add your prefab to the <code>PrefabLibrary</code> ScriptableObject. In  it, you can either create a new prefab group or add it to an existing one for organization.</p>"},{"location":"docs/developers/adding-a-simple-type-of-layer/#step-7-if-needed-create-ui-elements-to-add-your-layer","title":"Step 7: (If Needed) Create UI Elements to Add Your Layer","text":"<p>If you created a new prefab group, or added your prefab to a group without the <code>auto-populate UI</code> toggle enabled, add  UI elements to allow users to instantiate this layer. The default location is within the <code>AddLayerPanel</code> prefab, which  serves as the UI hub for adding layers.</p>"},{"location":"docs/developers/adding-behaviour-to-a-layer-with-data/","title":"Adding behaviour to a layer with data","text":"<p>This guide will focus on adding functional behavior to a layer using persisted data. It will provide the structure for a headless approach to layer properties, enabling custom layer behavior without exposing settings to the end user.</p> <p>Properties in this platform are modular, making it possible to attach reusable \u201cproperty sections\u201d to a layer rather  than defining specific fields. This modular approach allows data persistence when saving and reloading projects, with  Netherlands3D managing persistence automatically.</p> <p>This guide builds on the previous steps for creating a simple layer type. Here, we'll add properties that are stored  within the layer\u2019s data but without displaying them in the properties panel UI.</p> <p>About the examples</p> <p>The code examples are meant to show a simple scenario where you have a layer with 2 cubes and where we add behaviour for users to change the colour randomly by clicking on a cube, and where that colour is persisted between sessions. It is expected that for your own use-case you can adapt these examples to suit your situation.</p>"},{"location":"docs/developers/adding-behaviour-to-a-layer-with-data/#step-1-create-a-controller-script-with-ilayerwithpropertydata","title":"Step 1: Create a Controller Script with <code>ILayerWithPropertyData</code>","text":"<p>Begin by creating a <code>MonoBehaviour</code> script to encapsulate behaviour for your layer. This behaviour script will handle  the interactions with your property data. To start, implement the <code>ILayerWithPropertyData</code> interface in the script.  This interface includes a <code>LoadProperties</code> method, which we\u2019ll define in a later step. For now, leave the  <code>LoadProperties</code> method empty, focusing on setting up the controller structure.</p> <p>The code:</p> <pre><code>using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Netherlands3D.Twin.Layers;\nusing Netherlands3D.Twin.Layers.Properties;\nusing UnityEngine;\n\n[RequireComponent(typeof(LayerGameObject))]\npublic class TwoCubesColorChangingBehaviour : MonoBehaviour, ILayerWithPropertyData\n{\n    private LayerPropertyData propertyData;\n    public LayerPropertyData PropertyData =&gt; propertyData;\n\n    public void LoadProperties(List&lt;LayerPropertyData&gt; properties)\n    {\n    }\n\n    // implement the on click behaviour that will randomly change the \n    // color on one of the cubes; this is omitted for brevity\n}\n</code></pre> <p>In subsequent code samples some parts will be omitted for brevity -such as the import statements-.</p>"},{"location":"docs/developers/adding-behaviour-to-a-layer-with-data/#step-2-define-a-property-data-class","title":"Step 2: Define a Property Data Class","text":"<p>Next, create a dedicated class to represent the data fields you want to persist. This class should extend the <code>LayerPropertyData</code> superclass, which provides a foundation for layer properties. By extending <code>LayerPropertyData</code>, this class becomes capable of being serialized and deserialized by JSON.net, which  Netherlands3D uses to store and retrieve data within <code>.nl3d</code> project files. </p> <p>The data fields in this class should only represent state, with no embedded business logic, ensuring data integrity and  predictability.</p> <p>The code:</p> <pre><code>using System.Runtime.Serialization;\nusing Newtonsoft.Json;\nusing UnityEngine.Events;\n\npublic class TwoCubesColorPropertyData : LayerPropertyData\n{\n    // We will be adding fields in the next step\n}\n</code></pre>"},{"location":"docs/developers/adding-behaviour-to-a-layer-with-data/#step-3-add-fields-to-the-property-data-class","title":"Step 3: Add Fields to the Property Data Class","text":"<p>Now, add the fields to the property data class that you want to persist. For serialization and future compatibility, use a <code>DataContract</code> annotation on the class. This annotation should include a <code>Namespace</code> attribute, typically a URI  associated with your organization, to uniquely identify the origin of the class. In addition, a <code>Name</code> attribute provides  a clear, recognizable identifier for this data type.</p> <p>When defining fields, it is encouraged to use a <code>UnityEvent</code> alongside a C# property to trigger an event whenever a  property changes. This approach will allow the behaviour script to detect changes in state through events, making the  class versatile and responsive.</p> <p>The code:</p> <pre><code>...\n\n[DataContract(Namespace = \"https://example.org/schemas/my-nl3d-project\", Name = \"TwoCubesColor\")]\npublic class TwoCubesColorPropertyData : LayerPropertyData\n{\n    [DataMember] private Color cube1Color = Color.white;\n    [DataMember] private Color cube2Color = Color.red;\n\n    [JsonIgnore] public readonly UnityEvent&lt;Color&gt; Cube1ColorChanged = new();\n    [JsonIgnore] public readonly UnityEvent&lt;Color&gt; Cube2ColorChanged = new();\n\n    [JsonIgnore]\n    public Color Cube1Color\n    {\n        get =&gt; cube1Color;\n        set\n        {\n            cube1Color = value;\n            Cube1ColorChanged.Invoke(cube1Color);\n        }\n    }\n\n    [JsonIgnore]\n    public Color Cube2Color\n    {\n        get =&gt; cube2Color;\n        set\n        {\n            cube2Color = value;\n            Cube2ColorChanged.Invoke(cube2Color);\n        }\n    }\n}\n</code></pre>"},{"location":"docs/developers/adding-behaviour-to-a-layer-with-data/#step-4-wiring-the-controller-script-to-the-property-data","title":"Step 4: Wiring the Controller Script to the Property Data","text":"<p>With your property data class in place, return to the controller script and establish the connection between it and your properties. Start by creating a private field in the controller script, using the property data class you defined in Step 2. Next, set the controller's <code>PropertyData</code> getter to retrieve data from this field. Finally, implement the <code>LoadProperties</code> method by populating it with the necessary code to retrieve the correct <code>LayerPropertyData</code> object from  the layer at load time.</p> <p>Each controller can contain only one LayerPropertyData instance.</p> <p>This ensures the controller is dedicated to a single cohesive set of properties and promotes modularity, allowing  the controller to be reused across different layers without modification. For more information, see the explanation section on layers and properties.</p> <p>The code:</p> <pre><code>[RequireComponent(typeof(LayerGameObject))]\npublic class TwoCubesColorChangingBehaviour : MonoBehaviour, ILayerWithPropertyData\n{\n    // Note this change -&gt; We have replaced the generic LayerPropertyData with TwoCubesColorPropertyData\n    private TwoCubesColorPropertyData  propertyData;\n    public LayerPropertyData PropertyData =&gt; propertyData;\n\n    private void Start()\n    {\n        // Initialise the behaviour with properties from the propertyData - this will trigger upon loading a new project\n        OnCube1ColorChanged(propertyData.Cube1Color);\n        OnCube2ColorChanged(propertyData.Cube2Color);\n    }\n\n    public void LoadProperties(List&lt;LayerPropertyData&gt; properties)\n    {\n        // Find the property data for this behaviour in the list of properties belonging to its parent layer\n        properties = properties.OfType&lt;TwoCubesColorPropertyData&gt;().FirstOrDefault();\n\n        // if we found something, use that\n        if (properties != null)\n        {\n            propertyData = properties;\n        }\n\n        // if nothing is provided, or propertyData is otherwise null; make sure we have a default \n        propertyData ??= new();\n\n        // Add the listeners to allow this behaviour to respond to change in its state\n        propertyData.Cube1ColorChanged.AddListener(OnCube1ColorChanged);\n        propertyData.Cube2ColorChanged.AddListener(OnCube2ColorChanged);\n    }\n\n    private void OnCube1ColorChanged(Color colour)\n    {\n        // Implement the logic to apply this color to cube 1\n    }\n\n    private void OnCube2ColorChanged(Color colour)\n    {\n        // Implement the logic to apply this color to cube 2\n    }\n\n    private void OnDestroy()\n    {\n        propertyData.Cube1ColorChanged.RemoveListener(OnCube1ColorChanged);\n        propertyData.Cube2ColorChanged.RemoveListener(OnCube2ColorChanged);\n    }\n}\n</code></pre>"},{"location":"docs/developers/adding-behaviour-to-a-layer-with-data/#step-5-add-the-new-behavior-to-the-layer-prefab","title":"Step 5: Add the New Behavior to the Layer Prefab","text":"<p>To integrate your new persistent behavior with the layer, attach the behaviour script to the prefab for your layer. By adding the behaviour script, you enable the layer to utilize the persisted properties, allowing it to execute  specific behaviours based on saved data.</p>"},{"location":"docs/developers/architecture/","title":"Architecture","text":""},{"location":"docs/developers/architecture/#overview","title":"Overview","text":"<p>The Netherlands3D platform is built on a hybrid conceptual model that unites principles from MVVM  (Model\u2013View\u2013ViewModel) and MVP (Model\u2013View\u2013Presenter). This model was created to address a  fundamental challenge: in Netherlands3D, Project Data\u2014and by extension, Layer Data\u2014always has two views.</p> <ul> <li>a UI view for interaction and configuration, and </li> <li>a Scene view for spatial visualization.</li> </ul> <p>Traditional MVP or MVVM structures assume a single dominant view, but the Netherlands3D model treats both as equal interpreters of the same data. By placing data (the model) at the centre, the architecture ensures that both worlds  remain synchronized through a single, persisted source of truth.</p>"},{"location":"docs/developers/architecture/#historical-context","title":"Historical Context","text":"<p>Modern software architecture has progressively evolved toward a deeper separation of data and behaviour. The earliest two-tier architectures coupled presentation logic directly to the data store. This evolved into three-tier architecture, which introduced a dedicated application layer to mediate between presentation and data. Patterns such as Model\u2013View\u2013Presenter (MVP) and Model\u2013View\u2013Controller (MVC) refined this further  for interactive applications, and later Model\u2013View\u2013ViewModel (MVVM) formalized declarative, data-bound user  interfaces.</p> <p>Netherlands3D continues this lineage. It extends these ideas into a five-tier hybrid model (V\u2013VM\u2013M\u2013P\u2013V) that  combines both patterns: MVVM for UI-driven configuration and MVP for in-world visualization. Both tiers communicate through a shared data model that represents the persistent state of the system.</p>"},{"location":"docs/developers/architecture/#figure-evolution-of-software-architecture-toward-the-netherlands3d-model","title":"Figure \u2013 Evolution of Software Architecture Toward the Netherlands3D Model","text":"<p>(Insert the lineage-to-hybrid diagram here.)</p> <p>This diagram illustrates the evolution from classical two- and three-tier architectures toward presentation patterns like MVP and MVVM. Each generation increases the separation between data and behaviour, culminating in the five-tier hybrid used in Netherlands3D. In this model, the user interface (MVVM) and spatial visualization (MVP) both rely on the same persisted data model \u2014 the single source of truth.</p>"},{"location":"docs/developers/architecture/#the-hybrid-conceptual-model","title":"The Hybrid Conceptual Model","text":"<p>The Netherlands3D Hybrid Conceptual Model unites the principles of MVVM and MVP around the central idea that  data is the truth of the system. This truth is shared across two complementary pathways:</p> <ul> <li> <p>The UI Path \u2014 users interact with the application through panels, inspectors, and configuration interfaces built   with MVVM principles. Changes made in the UI update the shared data model.</p> </li> <li> <p>The Visualization Path \u2014 the same data is interpreted by scene presenters (MVP) that manage spatial objects,   geometry, and other 3D representations. Visualizers read from the same data model and reflect its current state.</p> </li> </ul> <p>This creates a dual-view architecture\u2014one for interaction, one for visualization\u2014both synchronized through the same data.</p>"},{"location":"docs/developers/architecture/#figure-hybrid-conceptual-model-vvmmpv","title":"Figure \u2013 Hybrid Conceptual Model (V\u2013VM\u2013M\u2013P\u2013V)","text":"<p>(Insert the \u201ctiers and truth\u201d diagram here.)</p> <p>Each flow represents a different interpretation of the same data. The left side (\u201cwant to change stuff\u201d) corresponds to the UI; the right side (\u201cwant to show stuff\u201d) corresponds to visualization in the 3D scene. Both converge on the Model (Data), the persisted truth at the centre of the system.</p>"},{"location":"docs/developers/architecture/#data-as-the-truth","title":"Data as the Truth","text":"<p>At the centre of Netherlands3D lies the data model\u2014objects such as <code>ProjectData</code>, <code>LayerData</code>, and <code>LayerPropertyData</code>. These objects are serializable, human-readable, and form the persisted state of the  application. Everything else\u2014the UI, behaviours, and scene objects\u2014either observes, modifies, or  renders this data.</p> <p>This approach draws from data-driven programming (not to be confused with data-oriented design). In data-driven systems, data describes behaviour; systems interpret that data rather than hard-coding logic. Netherlands3D applies this principle throughout, ensuring that what users configure in the editor is exactly what appears in the 3D world and what is saved to disk.</p>"},{"location":"docs/developers/architecture/#layers-and-separation-of-concerns","title":"Layers and Separation of Concerns","text":"<p>While tiers describe how data and behaviour are separated horizontally, Netherlands3D achieves  separation of concerns vertically through layered composition\u2014a concept inspired by data-oriented design  and Entity\u2013Component\u2013System (ECS) principles.</p> <p>Each Layer in Netherlands3D acts like an entity that can aggregate multiple components, known as <code>LayerPropertyData</code> blocks. These components define specific aspects of the layer\u2019s configuration or  behaviour\u2014such as styling, elevation sampling, animation, or metadata.</p> <p>At runtime, each layer also has corresponding presenters and visualizers that operate across all tiers:</p> Concern Data Tier Behaviour Tier Presentation Tier Layer <code>LayerData</code> <code>LayerGameObject</code> Scene objects Property Block <code>LayerPropertyData</code> Property presenter UI &amp; world behaviour Styling <code>LayerStyle</code> Style visualizer Visual appearance <p>This structure allows every layer to touch every tier\u2014from serialized data to runtime visualization\u2014without breaking encapsulation. Each concern remains modular and composable: adding a new capability simply means defining a  new data block and its associated presenters.</p>"},{"location":"docs/developers/architecture/#rationale-and-benefits","title":"Rationale and Benefits","text":"<p>This architectural approach offers several advantages:</p> <ol> <li>Unified data flow \u2013 both UI and scene rely on the same data model, eliminating duplication and desynchronization.</li> <li>Clear separation of data and behaviour \u2013 tiers isolate persistence, logic, and visualization.</li> <li>Clear separation of concerns \u2013 layering allows each functional area (e.g., styling, animation, sampling) to    evolve independently.</li> <li>Extensibility \u2013 new functionality can be introduced by adding new property types and corresponding presenters.</li> <li>Consistency \u2013 every layer behaves predictably because all tiers reference the same persisted truth.</li> <li>Transparency \u2013 the entire application state is inspectable and serializable, improving reproducibility and    debugging.</li> </ol>"},{"location":"docs/developers/architecture/#summary","title":"Summary","text":"<p>The Hybrid Conceptual Model provides the backbone of Netherlands3D\u2019s architecture. It combines the structured  clarity of tiered design with the modular flexibility of ECS-inspired layering. By placing  data at the centre, both UI and world visualization remain in sync, enabling reproducible, data-driven workflows across the entire application.</p> <p>Each layer in the system therefore operates as a small, self-contained world:</p> <ul> <li>its data defines what it is,</li> <li>its presenters define how it behaves, and</li> <li>its views define how it appears.</li> </ul> <p>Together, these patterns allow Netherlands3D to scale from small experiments to full city-scale digital twins without compromising architectural clarity or maintainability.</p> <p>Would you like me to follow this with a short \u201cArchitectural Summary Diagram\u201d caption and layout suggestion (a final overview figure that visually combines tiers + concerns in one nested illustration)? It would make this the perfect end section for your architecture chapter.</p>"},{"location":"docs/developers/build-pipeline/","title":"Our Build Pipeline (Github)","text":""},{"location":"docs/developers/build-pipeline/#what-is-a-build-or-ci-pipeline","title":"What is a Build, or CI, Pipeline?","text":"<p>Already know this?</p> <p>If you are familiar with the concept of Continuous Integration or Build Pipelines, feel free to skip ahead to the chapter \"Overview of the Build Pipeline\".</p> <p>A build pipeline, sometimes called a Continuous Integration (https://en.wikipedia.org/wiki/Continuous_integration) Pipeline, is a sequence of automated processes that converts source code into a deployable application. It enables developers to:</p> <ol> <li>Compile and build the application.</li> <li>Run automated tests to ensure code quality.</li> <li>Package the application for deployment.</li> <li>Deploy the application to the target environment.</li> </ol> <p>A critical aspect of a build pipeline is its ability to identify issues with the source code as early as possible in an automated way before deployment. The primary goal of a build pipeline is to \"fail fast.\" This means identifying issues early in the process to reduce wasted effort and allow developers to address problems as soon as they arise. Jobs and steps are generally constructed in such a way to aid in this process, ensuring that critical checks occur early and provide immediate feedback. </p>"},{"location":"docs/developers/build-pipeline/#jobs-in-a-build-pipeline","title":"Jobs in a Build Pipeline","text":"<p>Build pipelines are generally organized into jobs, each representing a major step in the development lifecycle. Note that in other CI systems, jobs may be referred to as stages.</p> <p>For example:</p> <ol> <li>Checkout: Retrieves the latest source code from version control.</li> <li>Build: Compiles the code and resolves dependencies.</li> <li>Test: Executes automated tests.</li> <li>Deploy: Publishes the built artifacts to a production or staging environment.</li> </ol> <p>Please see the next chapter how our build pipeline is set up.</p>"},{"location":"docs/developers/build-pipeline/#build-steps-in-a-job","title":"Build Steps in a Job","text":"<p>Each job consists of smaller units called steps, which represent discrete tasks. For instance, a step might involve running a specific script, configuring an environment, or uploading an artifact.</p>"},{"location":"docs/developers/build-pipeline/#overview-of-the-build-pipeline","title":"Overview of the Build Pipeline","text":"<p>Tip</p> <p>You can find the definition of our pipeline here.</p> <p>Netherlands3D uses GitHub Actions as its Continuous Integration (CI) solution to execute pipelines. </p> <p>The platform employs the principle of Continuous Deployment to automatically build and deploy changes as soon as they are pushed to the main branch. This ensures that the latest updates are always available  in production, reducing manual intervention and speeding up the release cycle.</p> <p>The build pipeline defined in the GitHub Actions workflow  consists of two primary flows:</p> <ol> <li> <p>Pull Request Flow: When a branch is created or updated, a development build of the viewer is triggered. The    resulting artifact, named <code>viewer-development</code>, is stored and can be downloaded from the build page in the     GitHub Actions interface. Developers can use this build for     debugging or profiling locally.</p> </li> <li> <p>Main Branch Flow: When a commit is pushed to the <code>main</code> branch,     both development and production builds are triggered:</p> <ul> <li>The development build produces an artifact (<code>viewer-development</code>) for debugging purposes.</li> <li> <p>The production build generates a production-ready artifact (<code>viewer</code>) at the same time, and then concurrently</p> <ul> <li>Deploys the viewer to GitHub Pages.</li> <li>Builds and publishes a Docker image containing the production viewer.</li> </ul> </li> </ul> </li> </ol> <p>Below is a visual representation of the pipeline:</p> <pre><code>graph TD\n    Start([Commit is Pushed])\n    MainOrPR{Pushed to *Main*&lt;br&gt;or&lt;br&gt;a Feature Branch}\n    End([Build Complete])\n\n    Start --&gt; MainOrPR\n    MainOrPR --&gt; DevBuild\n    MainOrPR --&gt; MainBuild\n    DevBuild --&gt; End\n    B--&gt; End\n\n    subgraph Push to Feature Branch\n        DevBuild[Build Development Viewer]\n        DevBuild\n    end\n    subgraph Push to Main\n        DevArtifact[Build Development Viewer]\n        ProdArtifact[Build Production Viewer]\n        MainBuild@{ shape: fork, label: \"Fork or Join\" }\n        A@{ shape: fork, label: \"Fork or Join\" }\n        B@{ shape: fork, label: \"Fork or Join\" }\n        Deploy[Deploy to GitHub Pages]\n        Docker[Build and Publish Docker Image]\n\n        MainBuild --&gt; DevArtifact --&gt; B\n        MainBuild --&gt; ProdArtifact\n        ProdArtifact --&gt; A\n        A --&gt; Deploy --&gt; B\n        A --&gt; Docker --&gt; B\n    end</code></pre>"},{"location":"docs/developers/build-pipeline/#jobs-and-steps","title":"Jobs and Steps","text":""},{"location":"docs/developers/build-pipeline/#pull-request-flow","title":"Pull Request Flow","text":""},{"location":"docs/developers/build-pipeline/#build-development-viewer","title":"Build Development Viewer","text":"<p>The goal of this job is to create a development build of the Netherlands3D viewer that includes debugging options. This build allows developers to test, debug, and profile the application locally. The resulting artifact, named <code>viewer-development</code>, is stored and available for download.</p> <ol> <li>Free Disk Space: Frees up runner storage for the build.</li> <li>Checkout Repository: Retrieves the repository's code.</li> <li>Cache Dependencies: Speeds up builds by caching the Unity <code>Library</code> folder.</li> <li>Build Unity Project: Builds a development version of the viewer with    debugging options enabled.</li> <li>Upload Development Artifact: Stores the development build as    <code>viewer-development</code>.</li> </ol>"},{"location":"docs/developers/build-pipeline/#main-branch-flow","title":"Main Branch Flow","text":""},{"location":"docs/developers/build-pipeline/#build-development-viewer_1","title":"Build Development Viewer","text":"<p>This is the exact same job as used in the Build Development Viewer job of the Pull Request Flow, see that chapter for more information.</p>"},{"location":"docs/developers/build-pipeline/#build-production-viewer","title":"Build Production Viewer","text":"<p>The goal of this job is to create a production-ready build of the Netherlands3D viewer. This build is optimized for deployment and does not include debugging options. The resulting artifact, named <code>viewer</code>, is used in subsequent deployment and Dockerization steps.</p> <ol> <li>Free Disk Space: Frees up runner storage for the build.</li> <li>Checkout Repository: Retrieves the repository's code.</li> <li>Cache Dependencies: Speeds up builds by caching the Unity <code>Library</code> folder.</li> <li>Build Unity Project: Builds a production version of the viewer.</li> <li>Upload Production Artifact: Stores the production build as <code>viewer</code>.</li> </ol>"},{"location":"docs/developers/build-pipeline/#deploy-to-github-pages","title":"Deploy to GitHub Pages","text":"<p>The goal of this job is to deploy the production build of the Netherlands3D viewer to GitHub Pages. This ensures that the latest version of the viewer is accessible via https://netherlands3d.eu/twin.</p> <ol> <li>Download Production Artifact: Retrieves the production build    artifact.</li> <li>Prepare Artifact for Deployment: Prepares the artifact    for GitHub Pages.</li> <li>Deploy to GitHub Pages: Publishes the production viewer.</li> </ol>"},{"location":"docs/developers/build-pipeline/#build-and-publish-docker-image","title":"Build and Publish Docker Image","text":"<p>The goal of this job is to create a Docker image containing the production build of the Netherlands3D viewer. The image is then pushed to the GitHub Container Registry, enabling easy deployment to containerized environments.</p> <ol> <li>Download Production Artifact: Retrieves the production build artifact.</li> <li>Login to Docker: Authenticates with Docker to push the image.</li> <li>Build and Push Docker Image: Creates and uploads the Docker image.</li> </ol>"},{"location":"docs/developers/build-pipeline/#reference-environment-variables","title":"Reference: Environment Variables","text":"<p>The following environment variables are defined in the build pipeline to standardize and simplify configurations:</p> <ul> <li><code>BUILD_OUTPUT_FOLDER</code>: Specifies the folder where the build output for the WebGL viewer is stored (   <code>build/WebGL/WebGL</code>). This path is used across jobs to locate the built artifacts.</li> <li><code>PRODUCTION_BUILD_ARTEFACT_NAME</code>: Defines the name of the artifact created for production builds (<code>viewer</code>). This is   used for identifying the production-ready build in artifact storage and subsequent deployment jobs.</li> <li><code>DEVELOPMENT_BUILD_ARTEFACT_NAME</code>: Defines the name of the artifact created for development builds (   <code>viewer-development</code>). This is used for storing builds meant for debugging and testing.</li> </ul> <p>These environment variables ensure consistency and reduce hardcoding of values across multiple steps in the workflow.</p>"},{"location":"docs/developers/build-pipeline/#reference-actions-in-depth","title":"Reference: Actions in Depth","text":""},{"location":"docs/developers/build-pipeline/#free-disk-space-jlumbrosofree-disk-space","title":"Free Disk Space (jlumbroso/free-disk-space)","text":"<p>This step ensures sufficient storage on the GitHub Actions runner by removing unnecessary tools and files. It's critical for resource-intensive builds like Unity.</p> <p>Inputs</p> <ul> <li><code>tool-cache</code>: Determines if the tool cache should be cleared. Default is <code>false</code>.</li> <li><code>android</code>, <code>dotnet</code>, <code>haskell</code>, <code>docker-images</code>, <code>swap-storage</code>: Specify which resources to clean up. All default to   <code>true</code> except <code>large-packages</code>.</li> </ul>"},{"location":"docs/developers/build-pipeline/#checkout-repository-actionscheckout","title":"Checkout Repository (actions/checkout)","text":"<p>This step retrieves the source code from the repository, including support for large files managed by Git LFS.</p> <p>Inputs</p> <ul> <li><code>lfs</code>: Fetches Git LFS objects if set to <code>true</code>.</li> </ul>"},{"location":"docs/developers/build-pipeline/#cache-dependencies-actionscache","title":"Cache Dependencies (actions/cache)","text":"<p>Caches the Unity <code>Library</code> folder to avoid redundant imports and expedite builds.</p> <p>Inputs</p> <ul> <li><code>path</code>: Folder to cache, such as <code>Library</code>.</li> <li><code>key</code>: Unique cache key, typically derived from file hashes.</li> <li><code>restore-keys</code>: Fallback keys if the primary cache key is not found.</li> </ul>"},{"location":"docs/developers/build-pipeline/#build-unity-project-game-ciunity-builder","title":"Build Unity Project (game-ci/unity-builder)","text":"<p>Compiles the Unity project for WebGL. For pull requests, development builds are configured with debugging options.</p> <p>Inputs</p> <ul> <li><code>targetPlatform</code>: Specifies <code>WebGL</code> as the build target.</li> <li><code>unityVersion</code>: Detects the Unity version automatically.</li> <li><code>customParameters</code>: Adds parameters like <code>-Development</code> and <code>-AllowDebugging</code> for development builds.</li> </ul>"},{"location":"docs/developers/build-pipeline/#upload-artifact-actionsupload-artifact","title":"Upload Artifact (actions/upload-artifact)","text":"<p>Saves the build outputs as downloadable artifacts for later use.</p> <p>Inputs</p> <ul> <li><code>name</code>: Name of the artifact (<code>viewer</code> or <code>viewer-development</code>).</li> <li><code>path</code>: Path to the files to upload (<code>build/WebGL/WebGL</code>).</li> </ul>"},{"location":"docs/developers/build-pipeline/#download-artifact-actionsdownload-artifact","title":"Download Artifact (actions/download-artifact)","text":"<p>Retrieves previously uploaded artifacts, enabling other jobs to access the build outputs.</p> <p>Inputs</p> <ul> <li><code>name</code>: Name of the artifact to download.</li> <li><code>path</code>: Path to store the downloaded artifact.</li> </ul>"},{"location":"docs/developers/build-pipeline/#prepare-artifact-for-deployment-actionsupload-pages-artifact","title":"Prepare Artifact for Deployment (actions/upload-pages-artifact)","text":"<p>This step prepares the production build artifact for deployment to GitHub Pages.</p> <p>Inputs</p> <ul> <li><code>path</code>: Specifies the location of the artifact to be uploaded for deployment.</li> </ul>"},{"location":"docs/developers/build-pipeline/#deploy-to-github-pages-actionsdeploy-pages","title":"Deploy to GitHub Pages (actions/deploy-pages)","text":"<p>Publishes the production viewer to GitHub Pages, making it accessible at https://netherlands3d.eu/twin.</p>"},{"location":"docs/developers/build-pipeline/#login-to-docker-dockerlogin-action","title":"Login to Docker (docker/login-action)","text":"<p>This step logs into Docker using credentials provided via GitHub Actions, enabling the push of Docker images to the GitHub Container Registry for the twin repository.</p> <p>Inputs</p> <ul> <li><code>registry</code>: Specifies the Docker registry (e.g., <code>ghcr.io</code>).</li> <li><code>username</code>: Username for the registry, typically the GitHub actor.</li> <li><code>password</code>: Access token or password used for authentication.</li> </ul>"},{"location":"docs/developers/build-pipeline/#build-and-push-docker-image-dockerbuild-push-action","title":"Build and Push Docker Image (docker/build-push-action)","text":"<p>Creates and publishes a Docker image containing the production viewer at the GitHub Container Registry for the twin repository.</p> <p>Inputs</p> <ul> <li><code>context</code>: Build context, usually the repository root.</li> <li><code>file</code>: Path to the Dockerfile.</li> <li><code>tags</code>: Tags for the Docker image (e.g., <code>latest</code>).</li> <li><code>build-args</code>: Build arguments, such as the artifact path.</li> </ul>"},{"location":"docs/developers/core-concepts/","title":"Core Concepts","text":"<p>Whether you are plotting sensor telemetry, planning new building projects, or mapping underground utilities like cables and pipes, Netherlands3D offers a versatile environment to bring your spatial data to life. This page introduces the key concepts behind the platform, providing a foundation for understanding how the application is structured and how you can leverage it for your projects.</p>"},{"location":"docs/developers/core-concepts/#projects-the-canvas-of-your-work","title":"Projects: The Canvas of Your Work","text":"<p>In Netherlands3D, everything you interact with on the screen is part of a Project. A project encompasses all the data layers, styles, and configurations that define your current view and can be saved or loaded as needed. Think of a project as a snapshot of your work, capturing everything from the base map to the overlaid datasets, and allowing you to revisit or share your work with others seamlessly.</p>"},{"location":"docs/developers/core-concepts/#layers-the-foundation-of-visualization","title":"Layers: The Foundation of Visualization","text":"<p>In Netherlands3D, Layers are the fundamental components that bring spatial data to life on the map. Each layer represents a specific dataset, determining not only what data is visualized but also how it appears. </p> <p>While Rasterlayers and Vectorlayers are the primary types, there are also additional supporting layers like folders and  scenarios that help organize your project. However, the focus of this chapter will be on understanding the two main  types of layers and the nature of the datasets they contain.</p>"},{"location":"docs/developers/core-concepts/#understanding-datasets-tiled-vs-fixed","title":"Understanding Datasets: Tiled vs. Fixed","text":"<p>Before diving into the specifics of Raster and Vector layers, it's important to understand the concept of how datasets are handled: Tiled versus Fixed.</p> <ul> <li> <p>Tiled Datasets: Tiling is a method used to optimize the performance of large datasets by breaking them down into smaller, more manageable pieces called tiles. These tiles are loaded dynamically as needed, which is especially useful when working with high-resolution data or when users need to navigate large geographical areas. Tiled datasets ensure that only the necessary portions of data are loaded at any given time, reducing memory usage and enhancing performance.</p> </li> <li> <p>Fixed Datasets: In contrast, fixed datasets are loaded in their entirety at once. This approach can be beneficial    when working with smaller datasets or when it's crucial to have immediate access to all the data without waiting for    it to stream. However, this method can be more demanding on system resources, particularly for large or complex    datasets.</p> </li> </ul> <p>The choice between tiled and fixed datasets affects how the data is visualized and interacted with in Netherlands3D. Whether a dataset is continuous (like elevation data) or discrete (like building footprints), it can be managed using either a tiled or fixed approach.</p>"},{"location":"docs/developers/core-concepts/#rasterlayers-visualizing-continuous-data","title":"Rasterlayers: Visualizing Continuous Data","text":"<p>Rasterlayers are used to display continuous data across a geographic area, such as heatmaps, terrain models, or aerial images. These layers are ideal for visualizing information that smoothly varies over space, like temperature changes across a city or elevation in a landscape.</p> <p>In Netherlands3D, Rasterlayers are powerful for showing broad, sweeping patterns in your data. For example, if you want to understand how pollution levels vary across a region, a Rasterlayer can provide a clear, visual representation of these gradients.</p>"},{"location":"docs/developers/core-concepts/#vectorlayers-representing-discrete-data","title":"Vectorlayers: Representing Discrete Data","text":"<p>Vectorlayers are used to map specific features like buildings, roads, utilities, or zones. Each feature is represented by points, lines, or polygons, and comes with attributes that describe it \u2014such as the height of a building or the type of road.</p> <p>Vectorlayers are essential for projects that require precise and detailed mapping. For instance, when planning new infrastructure, you can use Vectorlayers to map out exactly where new roads or pipelines will go. Each feature can be styled differently based on its attributes, making it easy to distinguish between different types of data.</p>"},{"location":"docs/developers/core-concepts/#features-the-building-blocks-of-layers","title":"Features: The Building Blocks of Layers","text":"<p>In Netherlands3D, Features are the individual elements that make up a Vectorlayer and can also be present in certain modern Rasterlayers. A feature represents a distinct geographical entity, such as a building, road, or zone, and can be styled and visualized according to your project\u2019s needs.</p> <p>Understanding features is crucial because they are the entities you interact with and analyze within a layer.  Whether you are drawing a map of utilities, defining zoning regulations, or visualizing sensor data, you are  essentially working with features. </p> <p>The ability to style and categorize these features, especially within the context of both vector and hybrid raster layers, provides the flexibility to create detailed, informative, and visually compelling maps.</p>"},{"location":"docs/developers/core-concepts/#features-in-vectorlayers","title":"Features in Vectorlayers","text":"<p>For Vectorlayers, features are the fundamental units. Each feature within a Vectorlayer has a specific geometry (point, line, or polygon) and is tied to a set of attributes that describe its properties. For example, a Vectorlayer representing buildings might have features corresponding to individual buildings, with attributes detailing their height, function, or construction material. These features can be styled in various ways using the platform's styling options, allowing you to differentiate between types of buildings, emphasize certain zones, or highlight critical infrastructure.</p>"},{"location":"docs/developers/core-concepts/#features-in-rasterlayers-the-hybrid-approach","title":"Features in Rasterlayers: The Hybrid Approach","text":"<p>Traditionally, Rasterlayers \u2014such as overlay images or heatmaps\u2014 do not contain discrete features. They represent continuous data spread across a grid, where each cell or pixel has a value but is not individually distinguished as a feature. However, with advances in 3D mapping technology, a new hybrid approach has emerged.</p> <p>In this modern method, certain Rasterlayers, especially those involving 3D meshes, may incorporate features. For example, a 3D terrain mesh (which is typically raster data) can have specific parts of the mesh categorized as features. These features within a Rasterlayer might represent distinct geographical areas, such as regions of interest or zones within a city, and can be individually styled and interacted with, similar to features in Vectorlayers. This blending of raster and vector data allows for a more nuanced and detailed representation of the environment, offering new possibilities for visualizing and analyzing spatial data.</p>"},{"location":"docs/developers/core-concepts/#styles-bringing-data-to-life","title":"Styles: Bringing Data to Life","text":"<p>While layers define what data is displayed and where, Styles (or Symbology) determine how that data is visualized. Styles control the visual appearance of layers, including colors, line thickness, transparency, and more. </p> <p>Similar to how CSS styles HTML in web development, styles in Netherlands3D customize the visual representation of your  spatial data. Whether you want to highlight certain areas, differentiate between types of infrastructure, or simply  make your map more visually appealing, styles give you the flexibility to achieve your desired look and feel.</p> <p>You can read more about styling in its dedicated chapter \"Layer Styles\". </p>"},{"location":"docs/developers/core-concepts/#conclusion","title":"Conclusion","text":"<p>Understanding these core concepts \u2014Projects, Layers, Rasterlayers, Vectorlayers, Features, Styles, and the distinction between Tiled and Fixed datasets\u2014 is crucial for effectively using Netherlands3D. These elements form the backbone of the platform, allowing you to create, visualize, and interact with spatial data in a way that meets your project needs. As you dive deeper into the application, these concepts will guide you in organizing your work and optimizing your use of the platform\u2019s powerful features.</p>"},{"location":"docs/developers/feature-build-pipeline/","title":"Our Feature Build Pipeline (Azure DevOps)","text":"<p>Introduction to CI/CD and pipelines</p> <p>In the explainer on our build pipeline is a short introduction  on builds, pipelines and CI/CD.</p> <p>This page explains how feature builds work in the Netherlands3D CI/CD workflow, why they exist, and how they are automatically deployed as isolated preview environments. It also describes the Azure DevOps pipeline that handles the deployment of feature builds based on GitHub\u2019s webhook events.</p> <p>The intended audience is developers who may not yet be familiar with CI/CD, Azure Pipelines, or automated deployments. This page provides both a simple overview and a deeper technical explanation.</p>"},{"location":"docs/developers/feature-build-pipeline/#1-what-are-feature-builds","title":"1. What Are Feature Builds?","text":"<p>Netherlands3D uses a Feature Branch Workflow,  where:</p> <ul> <li>All production-ready code lands on <code>main</code>.</li> <li>Developers implement new work in short-lived feature branches with a specific prefix, either<code>feature/*</code>,    <code>fix/*</code> or <code>bugfix/*</code>.</li> <li>Feature branches map closely to individual work items in the product backlog.</li> </ul> <p>Every work item\u2014bug, fix, enhancement, or new feature \u2014 should have its own branch, and each branch gets its  own deployment.</p> <p>Feature builds act as a per-work-item acceptance environment, which can also be called a Preview environment:</p> <ul> <li>Multiple features can be reviewed in parallel without conflicting with each other.</li> <li>Developers can share a direct preview link without needing a local build.</li> <li>Product owners and stakeholders can review a feature before it is merged.</li> <li>QA can validate work in isolation.</li> </ul> <p>Each build results in a unique Preview URL. This URL can be found in a channel dedicated to CI/CDI in our team's  communication app, or it can be found in a Pull Request's check section named \"Netherlands3D Preview\".  </p> <p>These paths for these branches follow this format:</p> <pre><code>/autobuild/&lt;branch-prefix&gt;/&lt;branch-name&gt;/&lt;commit-hash&gt;/feature/\n</code></pre> <p>This enables complete traceability and instant previewing of every commit. When a branch is deleted, the Preview builds are also removed.</p>"},{"location":"docs/developers/feature-build-pipeline/#2-end-to-end-flow-high-level-overview","title":"2. End-to-End Flow (High-Level Overview)","text":"<p>At a high level, feature build deployment works like this:</p> <pre><code>graph TD\n    A[Developer commits to feature/fix/bugfix branch] --&gt; B[GitHub Actions builds Unity WebGL]\n    B --&gt; C[GitHub workflow_run completes]\n    C --&gt; D[Webhook sent to Azure DevOps via Netherlands3DFeatureBranches]\n\n    D --&gt; E[Pipeline parses webhook&lt;br/&gt;artifact URL, commit info, branch]\n    E --&gt; F{Is workflow successful?}\n    F --&gt;|No| X[Set SkipRemainingTasks=true and thus &lt;br/&gt;stop deployment tasks]\n    F --&gt;|Yes| G{Is branch feature-like?}\n    G --&gt;|No| X\n    G --&gt;|Yes| H[Set GitHub Check status = pending]\n\n    H --&gt; I[Locate viewer ZIP on GitHub]\n    I --&gt; J[Download viewer ZIP]\n    J --&gt; K[Extract ZIP to working folder]\n\n    K --&gt; L[Upload content to Azure Storage]\n    L --&gt; M[Purge CDN for preview path]\n\n    M --&gt; N[Send Slack success message]\n    N --&gt; O[Set GitHub check status = success&lt;br/&gt;with preview URL]\n\n    %% Failure paths\n    I --&gt;|Error| Y[Send Slack failure message]\n    J --&gt;|Error| Y\n    K --&gt;|Error| Y\n    L --&gt;|Error| Y\n    M --&gt;|Error| Y\n\n    Y --&gt; Z[Set GitHub check status = failed]\n\n    X:::stop\n    Z:::stop</code></pre>"},{"location":"docs/developers/feature-build-pipeline/#4-technical-explanation-of-the-pipeline-simple-detailed","title":"4. Technical Explanation of the Pipeline (Simple \u2192 Detailed)","text":"<p>Below is a step-by-step explanation of the pipeline.</p>"},{"location":"docs/developers/feature-build-pipeline/#41-pipeline-triggering","title":"4.1 Pipeline Triggering","text":"<p>The pipeline is triggered by:  GitHub workflow_run  webhooks via the service connection:</p> <pre><code>Netherlands3DFeatureBranches\n</code></pre> <p>This webhook fires when any GitHub Action workflow in the <code>Netherlands3D/twin</code> Github repository completes.</p>"},{"location":"docs/developers/feature-build-pipeline/#42-parsing-the-webhook-branch-validation","title":"4.2 Parsing the Webhook &amp; Branch Validation","text":"<p>The pipeline reads:</p> <ul> <li><code>artifacts_url</code></li> <li><code>head_branch</code></li> <li><code>author</code></li> <li><code>commit hash</code></li> <li>Commit message</li> <li>Workflow <code>conclusion</code></li> </ul> <p>Validation rules:</p> <ul> <li>If GitHub did not succeed \u2192 skip deployment by setting <code>SkipRemainingTasks</code> to true.</li> <li>If branch is not one of <code>feature/*</code>, <code>fix/*</code>, <code>bugfix/*</code> \u2192 skip deployment by setting <code>SkipRemainingTasks</code> to true.</li> </ul> <p>If valid, the script extracts:</p> <ul> <li><code>ContainerName</code> \u2014 branch prefix before the first slash</li> <li><code>FeatureName</code> \u2014 everything after the last slash</li> <li>A cleaned commit title (max 55 characters)</li> </ul>"},{"location":"docs/developers/feature-build-pipeline/#43-setting-github-commit-status-to-pending","title":"4.3 Setting GitHub Commit Status to \u201cPending\u201d","text":"<p>If <code>SkipRemainingTasks == false</code>, GitHub commit status is set to:</p> <pre><code>state = pending\ndescription = \"Preview is building\"\n</code></pre> <p>This gives immediate PR feedback in the checks section of a PR with a direct link to the Azure Pipeline run.</p>"},{"location":"docs/developers/feature-build-pipeline/#44-locating-and-downloading-the-viewer","title":"4.4 Locating and Downloading the Viewer","text":"<p>The Azure Pipeline does not build its own viewer but relies on the viewer that is built on Github. This ensures that there is no uncertainty that the version you are previewing identical to what is built.</p> <p>Azure DevOps:</p> <ol> <li>Retrieves artifact metadata from GitHub.</li> <li>Selects the artifact named <code>viewer-development</code> that contains the development build.</li> <li>Downloads the ZIP file using GitHub API.</li> </ol> <p>If download fails, the error message is saved for reporting.</p>"},{"location":"docs/developers/feature-build-pipeline/#45-extracting-the-artifact","title":"4.5 Extracting the Artifact","text":"<p>The ZIP archive is extracted into:</p> <pre><code>$(System.DefaultWorkingDirectory)/feature/\n</code></pre> <p>This becomes the build that will be published.</p>"},{"location":"docs/developers/feature-build-pipeline/#46-uploading-to-azure-storage","title":"4.6 Uploading to Azure Storage","text":"<p>The extracted WebGL build is uploaded to:</p> <pre><code>$web/autobuild/&lt;Container&gt;/&lt;Feature&gt;/&lt;CommitHash&gt;/\n</code></pre> <p>Where:</p> <ul> <li>Container = first part of the branch name (<code>feature</code>, <code>fix</code>, <code>bugfix</code>)</li> <li>Feature = last part of the branch name</li> <li>CommitHash = SHA of the commit that triggered the build</li> </ul> <p>This ensures fully isolated preview environments.</p>"},{"location":"docs/developers/feature-build-pipeline/#47-cdn-purge","title":"4.7 CDN Purge","text":"<p>To ensure instant cache refresh for new builds and to show the latest version, the pipeline purges only the relevant  folder:</p> <pre><code>/autobuild/&lt;Container&gt;/&lt;Feature&gt;/*\n</code></pre>"},{"location":"docs/developers/feature-build-pipeline/#48-slack-success-notification","title":"4.8 Slack Success Notification","text":"<p>On success, Slack receives:</p> <ul> <li>A green checkmark</li> <li>The author\u2019s name</li> <li>The preview URL</li> <li>The commit title</li> </ul> <p>This gives product and team members immediate visibility.</p>"},{"location":"docs/developers/feature-build-pipeline/#49-github-status-updated-to-success","title":"4.9 GitHub Status Updated to Success","text":"<p>The commit status is updated to:</p> <pre><code>state = success\ndescription = \"Preview available\"\ntarget_url = &lt;preview URL&gt;\n</code></pre> <p>GitHub PRs now show a checkmark that links directly to the preview environment for easy access.</p>"},{"location":"docs/developers/feature-build-pipeline/#410-failure-notifications","title":"4.10 Failure Notifications","text":"<p>If the pipeline itself fails:</p> <ul> <li>A Slack message with a red square is sent.</li> <li>It includes a link to the Azure DevOps build logs.</li> <li>GitHub status is set to <code>failure</code> or <code>error</code>.</li> </ul> <p>This helps developers quickly debug issues.</p>"},{"location":"docs/developers/functionalities/","title":"Functionalities","text":"<p>At the core of Netherlands3D, various functionalities serve as building blocks. Each functionality represents a distinct element or feature of the platform, designed to perform specific tasks. These functionalities are modular, meaning they can be enabled or disabled individually based on user requirements or the needs of a particular project.</p> <p>This ability to toggle functionalities on and off ensures that you have control over the features you want to deploy in your project.</p>"},{"location":"docs/developers/functionalities/#how-does-it-work","title":"How does it work","text":"<p>In Unity's context for the Netherlands3D platform, each functionality is encapsulated in a ScriptableObject. Exploring further, you'll discover that each ScriptableObject is highly configurable, granting you the ability to tailor it to satisfy specific demands.</p>"},{"location":"docs/developers/functionalities/#key-components","title":"Key Components","text":""},{"location":"docs/developers/functionalities/#scriptableobjects","title":"ScriptableObjects","text":"<p>The ScriptableObjects for the functionalities can be located in the <code>Scriptables/Functionalities</code> folder. Each ScriptableObject represents a distinct functionality in the application, and can be configured to define its behavior and properties within the application.</p>"},{"location":"docs/developers/functionalities/#functionality-system","title":"Functionality System","text":"<p>The code powering the functionality system is hosted within the embedded package named <code>eu.netherlands3d.eu.twin-functionalities</code>. Digging into this package reveals the design and implementation of the system that manages and orchestrates the functionalities.</p>"},{"location":"docs/developers/functionalities/#the-functionality-script","title":"The Functionality Script","text":"<p>At the core, the Functionality script exists as a foundational unit for the ScriptableObject. Here is where you define key attributes such as its title, description, ID, and any additional configuration. This script performs the following roles:</p> <ol> <li> <p>Title and Description: The title and description fields of the ScriptableObject are primarily designed for your reference in the settings screen of the application.</p> </li> <li> <p>Functionality ID: The ID (or code) is used to refer to the functionality from the configuration file. This ID attribute is instrumental in organizing and managing configurations of functionalities within the system robustly.</p> </li> <li> <p>Enabled State: The enabled state of the functionality indicates whether it's active or inactive. The system can query this status to determine the functionality's availability and act accordingly in any part of the application.</p> </li> <li> <p>Additional Configuration: The ScriptableObject also includes an additional configuration section where you can define supplementary settings and properties that control its behavior within your application.</p> </li> </ol>"},{"location":"docs/developers/introduction/","title":"Introduction","text":"<p>Welcome to the technical documentation for Netherlands3D, an advanced Digital Twin platform designed to visualize and analyze geospatial data in a 3D environment. This documentation is intended for developers who want to understand how the platform works, explore its architecture, and contribute new modules or functionalities.</p> <p>Why English?</p> <p>While the rest of this website and the user-facing documentation is provided in Dutch, in accordance with  government guidelines, the technical documentation is written in English. </p> <p>This decision has been made to ensure a broad range of developers can contribute to Netherlands3D and to maintain  consistency with the platform's codebase, which uses English terms and concepts. By using English in the technical  documentation, we aim to make it easier for developers to map concepts between the documentation and the code  itself, facilitating a smoother development and contribution process.</p>"},{"location":"docs/developers/introduction/#overview","title":"Overview","text":"<p>Netherlands3D is built on a modular architecture, allowing for extensibility. Developers can add, modify, or replace individual modules without affecting the entire system. The platform integrates data from various sources, such as 3D Tiles, the national georegister, and sensor information, to create an interactive and dynamic 3D environment for spatial analysis and visualization.</p> <p>This documentation will provide you with a detailed understanding of how the system operates under the hood, including its component-based architecture, event-driven communication, and handling of secure data layers.</p>"},{"location":"docs/developers/introduction/#key-technologies","title":"Key Technologies","text":"<ul> <li>Unity3D: The platform is developed using Unity, leveraging its robust rendering capabilities to display   high-performance 3D models and large-scale datasets.</li> <li>Scriptable Objects: Used extensively to manage data, configuration, and communication between different modules   and functionalities.</li> <li>Event-Driven System: Internal communication within modules is handled via UnityEvents, while inter-module   interactions are driven by Scriptable Object Events, which allow asynchronous communication and keep the   system decoupled.</li> </ul> <p>This documentation will guide you through the internal workings of the platform, including detailed API references, examples of module creation, and best practices for integrating new functionality.</p>"},{"location":"docs/developers/layers-with-authentication/","title":"Managing Layers with Authentication","text":"<p>In Netherlands3D, certain data layers require user authentication to be accessed and displayed. This guide explains how the system manages authentication for these layers, handles different types of credentials, and ensures sensitive information remains protected while maintaining layer visibility settings.</p>"},{"location":"docs/developers/layers-with-authentication/#1-layer-authentication-process","title":"1. Layer Authentication Process","text":"<p>When a user adds a layer that requires authentication, they are prompted to provide credentials in one of the following forms:</p> <ul> <li>Username and Password</li> <li>Access Key</li> </ul> <p>Regardless of the credential type, the system records that the source associated with the layer (typically the layer's URL) requires authentication. This information is stored in a KeyVault.</p>"},{"location":"docs/developers/layers-with-authentication/#2-credential-storage-and-security","title":"2. Credential Storage and Security","text":"<p>To ensure that sensitive information is never compromised:</p> <ul> <li>Credentials are not stored in the project file. Instead, the KeyVault retains only the metadata necessary to    recognize that the layer is protected and requires credentials.</li> <li>The KeyVault is saved alongside the project, but it does not contain the actual credentials, only the    authentication type and associated layer source.</li> <li>This design prevents sensitive credentials from being shared when the project file is distributed to third parties,   ensuring privacy and security.</li> </ul>"},{"location":"docs/developers/layers-with-authentication/#3-handling-credentials-http-basic-authentication-vs-access-key","title":"3. Handling Credentials: HTTP Basic Authentication vs. Access Key","text":"<p>The system supports two main methods of authentication, depending on the type of credentials provided by the user:</p> <ul> <li> <p>HTTP Basic Authentication (Username and Password): If the user provides a username and password, the system    queries the protected endpoint using HTTP Basic Authentication. This involves sending the credentials in the request    header in accordance with the Basic Authentication protocol.</p> </li> <li> <p>Access Key: If an access key is provided, the system attempts to use the key within the query string of the    endpoint's URL. The application performs auto-detection to determine the appropriate query parameter name by testing    common parameters like:</p> </li> <li> <p><code>code</code></p> </li> <li><code>key</code></li> <li><code>token</code></li> </ul> <p>The system will make repeated requests to the endpoint using each query parameter name and observe the HTTP response.    If the server returns an HTTP status code 401 (Unauthorized) or 403 (Forbidden) for each attempt, the    application concludes that the provided credential is incorrect. If a valid credential is found, the system records    the correct query parameter name in the KeyVault for future use.</p>"},{"location":"docs/developers/layers-with-authentication/#4-handling-layers-without-credentials","title":"4. Handling Layers Without Credentials","text":"<p>If a layer requiring authentication is added (either manually by the user or through reloading a project), and no valid credentials are provided, the following behavior occurs:</p> <ul> <li>The layer enters a non-visible state, as it cannot be displayed without valid credentials.</li> <li>The system issues a warning prompting the user to enter (or re-enter) credentials for the layer.</li> </ul> <p>Note: The user must resolve this issue by supplying valid credentials before the layer can be displayed.</p>"},{"location":"docs/developers/layers-with-authentication/#5-maintaining-layer-visibility-settings","title":"5. Maintaining Layer Visibility Settings","text":"<p>One critical aspect of this system is that the visibility of the layer is preserved, even if it cannot be displayed due to authentication issues:</p> <ul> <li>If the layer was hidden (via the eye icon) when the project was saved, it will remain hidden after authentication    is provided.</li> <li>Similarly, if the layer was visible, it will become visible once valid credentials are entered and the authentication   issue is resolved.</li> </ul> <p>This approach ensures that the visibility state is consistent and independent of the authentication status.</p>"},{"location":"docs/developers/layers-with-authentication/#6-temporary-state-of-authentication","title":"6. Temporary State of Authentication","text":"<p>The system does not store the authentication status (whether credentials have been verified or not) in the project file. This is because authentication status is a temporary state that should not persist across sessions. Each time  a project is loaded, the authentication process must be reinitiated for protected layers, ensuring that credentials are entered securely and as needed.</p>"},{"location":"docs/developers/layers-with-authentication/#7-need-to-re-authenticate-reopening-the-application","title":"7. Need to re-authenticate reopening the application","text":"<p>A key implication of this design is that users will need to re-authenticate any protected layers every time they reopen the application or load a saved project file. Since credentials are never stored in the project file for security reasons, the system requires users to provide valid credentials again when the project is reloaded.</p> <p>This approach ensures that sensitive credentials are handled securely, but it also means that re-authentication is necessary whenever a protected layer is accessed in a new session. Users should be aware that any protected layers will initially be in a non-visible state until the required credentials are provided.</p>"},{"location":"docs/developers/layers-with-authentication/#8-warnings-and-user-flow","title":"8. Warnings and User Flow","text":"<p>The current user flow for managing layer authentication includes:</p> <ul> <li>A warning message indicating that the layer cannot be displayed due to missing or invalid credentials.</li> <li>A prompt that allows the user to supply new credentials for the layer.</li> <li>Once the credentials are provided and validated, the layer\u2019s display status is updated accordingly, without altering    its pre-existing visibility state.</li> </ul> <p>By following this process, Netherlands3D ensures that users can securely manage layers requiring authentication while maintaining proper visibility states and safeguarding sensitive data.</p>"},{"location":"docs/developers/layers/","title":"Layers","text":"<p>Imagine walking into a digital workshop. At the entrance sits a Project, a sturdy cabinet filled with blueprints, reference notes, and the settings needed to reassemble an entire 3D world. Each drawer in that cabinet holds a Layer \u2014 a focused blueprint describing a single part of that world: the terrain, the buildings, the trees, the imagery above them.</p> <p>When you open a drawer (load a layer), a craftsman \u2014 the <code>LayerGameObject</code> \u2014 takes the blueprint and builds its physical form on the workbench: a GameObject hierarchy, meshes, textures, and whatever else is needed to make it visible. Beside the bench sits a control panel \u2014 the Layer Panel \u2014 letting you switch layers on or off, reorder them, and tweak their properties while watching the world change.</p> <p>This is the Layer System of Netherlands3D: a clean separation between data (the blueprint), runtime behaviour  (the craftsman), and presentation (the instruments).</p>"},{"location":"docs/developers/layers/#quick-cheat-sheet","title":"Quick cheat sheet","text":"<ul> <li>Purpose: Provide a bridge between serialized project data and live, interactive scene content.</li> <li>Audience: Developers and designers extending or integrating new layer types.</li> <li>Mental shortcut: Layers follow a define \u2192 build \u2192 interact cycle.    LayerData defines the layer, LayerGameObject builds and synchronizes it, and the Layer Panel and scene view let    users interact with it \u2014 all staying in sync through the model-view-presenter pattern.</li> </ul>"},{"location":"docs/developers/layers/#1-mental-model-at-a-glance","title":"1. Mental model at a glance","text":"Term Think of it as Where it lives Project The workshop that stores all layer blueprints and settings; opening it reconstructs the scene from data. <code>Project</code> / <code>.nl3d</code> LayerData A blueprint node in the project hierarchy \u2014 pure data (id, name, parent/children, visibility, properties). No in-world GameObjects. <code>Assets/_Application/Layers/LayerData.cs</code> ReferencedLayerData A blueprint with a handle to runtime content (e.g., <code>prefabId</code>). Owns/attaches a presenter and may resolve external assets/streams. <code>Assets/_Application/Layers/LayerTypes/ReferencedLayerData.cs</code> LayerGameObject The presenter/visualizer created and managed by <code>ReferencedLayerData</code>; builds and syncs the in-world representation and the layer\u2019s UI entry. <code>Assets/_Application/Layers/LayerGameObject.cs</code> Layer UI (LayerUIManager / LayerUI) The panel view for inspecting, toggling, renaming, and reordering layers; UI only (no scene orchestration). <code>Assets/_Application/Layers/UI/HierarchyInspector/LayerUIManager.cs</code>, <code>LayerUI.cs</code> Property Sections Modular editors for layer settings; write to <code>LayerData</code> and, when a presenter exists, trigger re-render via the presenter. <code>Assets/_Application/Layers/Properties/Properties.cs</code>, <code>PropertySectionWithLayerGameObject.cs</code>, <code>LayerGameObjectPropertySectionInstantiator.cs</code> Builder / Spawner / Layers service The foremen that instantiate presenters for referenced blueprints and keep hierarchy/order in sync with data. <code>Assets/_Application/Layers/LayerBuilder.cs</code>, <code>LayerSpawner.cs</code>, <code>Services/Layers.cs</code> <p>Together they form the Layer System: data-defined blueprints (<code>LayerData</code>) inside a Project; only referenced blueprints (<code>ReferencedLayerData</code>) create a presenter (<code>LayerGameObject</code>) that drives the UI panel and * in-world representation*, with property edits flowing through the model and being reflected live.</p>"},{"location":"docs/developers/layers/#2-a-day-in-the-life-of-a-layer","title":"2. A day in the life of a layer","text":"<ol> <li> <p>A project is opened, and its stored <code>.nl3d</code> file is read.    The project loader reconstructs every <code>LayerData</code> entry \u2014 a set of blueprints describing the layers that make up the    scene. At this point, nothing is visible yet; the data simply defines what should exist.</p> </li> <li> <p>Each blueprint finds its craftsman.    For every <code>LayerData</code>, a <code>LayerGameObject</code> presenter is instantiated.    This presenter interprets the stored data into live scene content \u2014 spawning GameObjects, loading prefabs, or    connecting to external datasets such as WMS or 3D Tiles.</p> </li> <li> <p>The layer\u2019s two views come online.</p> <ul> <li>The scene view is created, building the actual 3D representation (meshes, sprites, or tile hierarchies).</li> <li>The UI view appears in the Layer Panel, mirroring the model\u2019s name, order, and visibility.</li> </ul> </li> <li> <p>Everything stays in sync.    When the user toggles visibility, renames a layer, or adjusts a property in the UI, the presenter updates the    <code>LayerData</code>.    The change is reflected immediately in the scene.    Likewise, when project data is modified programmatically, the presenter propagates those updates back to both views.</p> </li> <li> <p>The layer tidies up when it\u2019s removed or replaced.    The presenter detaches from its model, destroys associated GameObjects, and ensures the updated state is stored in    the project.    When reopened, the same data can rebuild the same scene, ensuring reproducibility between sessions.</p> </li> </ol> <p>If you prefer a concrete example, picture the \u201cBuildings\u201d layer with a referenced dataset and a few basic properties:</p> Action What happens behind the scenes Layer is loaded <code>LayerData</code> specifies a <code>ReferencedLayerData</code> with a prefab ID pointing to building models. Presenter created <code>LayerGameObject</code> resolves the prefab, spawns the models, and registers itself in the hierarchy. User toggles visibility The UI updates the <code>visible</code> flag in <code>LayerData</code>; the presenter calls <code>SetActive(false)</code> on the scene objects. User edits color The property section writes the change to the model; the presenter reconfigures the material. Layer deleted The presenter cleans up, detaching its references and removing the model from the project. <p>Every step follows the same cycle: data model defines \u2192 presenter interprets \u2192 views reflect \u2192 data model updates.</p>"},{"location":"docs/developers/layers/#3-understanding-layers","title":"3. Understanding Layers","text":""},{"location":"docs/developers/layers/#31-the-workshop-projects-as-containers","title":"3.1. The workshop: Projects as containers","text":"<p>A Project in Netherlands3D acts as the workspace of the system. It stores not only project-wide configuration and  metadata but also an ordered collection of Layer blueprints (<code>LayerData</code> objects).</p> <p>Each blueprint defines:</p> <ul> <li>What the layer is (<code>type</code>)</li> <li>How it should appear (<code>visible</code>, <code>style</code>, <code>properties</code>)</li> <li>How it connects to others (<code>parent</code>, <code>children</code>)</li> </ul> <p>When you open a project (<code>.nl3d</code> file), the system rebuilds your workspace:</p> <ol> <li>It reads all stored <code>LayerData</code> objects.</li> <li>It instantiates a LayerGameObject for each one that has a visualisation, or presenter.</li> <li>Those presenters rebuild their corresponding scene content and user interface entries.</li> </ol> <p>The result: your saved digital world \u2014 exactly as it was when you left it.</p>"},{"location":"docs/developers/layers/#32-the-blueprint-layerdata","title":"3.2. The blueprint: LayerData","text":"<p><code>LayerData</code> is the model \u2014 pure, serializable information. It doesn\u2019t render, animate, or run code. It describes what exists, not how it behaves.</p> <p>Each <code>LayerData</code> instance defines:</p> <ul> <li>A unique identifier (<code>id</code>)</li> <li>Its type (determines which presenter will interpret it)</li> <li>Relationships (parent/child layers)</li> <li>Visibility, name, and metadata</li> <li>Optional serialized property blocks (through the properties system)</li> </ul> <p>Because <code>LayerData</code> is stored as JSON (using Newtonsoft), it\u2019s platform-agnostic and editable outside Unity if needed.</p>"},{"location":"docs/developers/layers/#33-the-craftsman-layergameobject","title":"3.3. The craftsman: LayerGameObject","text":"<p>Once the project loads, each blueprint is handed to a craftsman \u2014 a <code>LayerGameObject</code>. This class acts as the Presenter in the MVP pattern: it binds the pure data from <code>LayerData</code> to two forms of presentation:</p> <ol> <li>The Scene View \u2014 a tangible GameObject hierarchy with renderers, meshes, or other runtime elements.</li> <li>The UI View \u2014 a panel entry for toggling, reordering, and editing.</li> </ol> <p>Its duties include:</p> <ul> <li>Creating and maintaining the scene object tree.</li> <li>Reacting to model updates (visibility, order, style changes).</li> <li>Forwarding UI edits back to the model.</li> <li>Managing lifecycle events such as instantiation, destruction, and rehydration after serialization.</li> </ul>"},{"location":"docs/developers/layers/#34-the-instruments-layer-panel-and-in-world-representation","title":"3.4. The instruments: Layer panel and in-world representation","text":"<p>The craftsman doesn\u2019t work alone \u2014 it interacts with instruments that let both developers and users see and control its results.</p>"},{"location":"docs/developers/layers/#341-ui-view-the-layer-panel","title":"3.4.1 UI View \u2014 the Layer Panel","text":"<p>The Layer Panel conceptually mirrors Unity\u2019s hierarchy but with more context. It\u2019s managed by <code>LayerUIManager</code> and composed of <code>LayerUI</code> elements \u2014 one per layer. Through this interface you can:</p> <ul> <li>Toggle visibility</li> <li>Reorder layers</li> <li>Select layers for editing</li> <li>Delete layers</li> <li>Open property sections for fine-tuning</li> </ul> <p>Unlike the classic Unity hierarchy, the panel is not just a visual list \u2014 it\u2019s fully synchronized with the <code>LayerData</code> hierarchy.</p>"},{"location":"docs/developers/layers/#342-scene-view-the-3d-result","title":"3.4.2 Scene View \u2014 the 3D result","text":"<p>Each layer\u2019s <code>LayerGameObject</code> builds its own subtree of GameObjects, representing what that layer contributes to the scene. Depending on the layer type, this might be:</p> <ul> <li>A mesh or tile (e.g., Cartesian tiles)</li> <li>A set of sprites or annotations</li> <li>A streamed dataset (e.g., OGC 3D Tiles or WMS imagery)</li> <li>A custom prefab loaded via <code>ReferencedLayerData</code></li> </ul>"},{"location":"docs/developers/layers/#35-types-of-blueprints-basic-vs-referenced-layers","title":"3.5. Types of blueprints: Basic vs Referenced layers","text":"Type What it describes Common use Basic Layer Self-contained; data and visual are built entirely from the model. Folders, polygon overlays, feature masks. Referenced Layer Contains a pointer to external content (prefab, library ID, streamed source). 3D Tiles, WMS imagery, CityJSON models. <p>Referenced layers are defined by <code>ReferencedLayerData</code>, which tells the presenter how to resolve the external resource. Their <code>LayerGameObject</code> might live outside the main hierarchy, but they still behave like native layers in the UI panel.</p>"},{"location":"docs/developers/layers/#36-fine-tuning-the-result-properties-and-property-sections","title":"3.6. Fine-tuning the result: Properties and Property Sections","text":"<p>Once a layer is built, its look and behaviour can be adjusted through Property Sections \u2014 modular UI components bound to its model and presenter.</p> <p>The properties system includes:</p> <ul> <li><code>Properties.cs</code> \u2014 the backbone for registering and reading property blocks.</li> <li><code>PropertySectionWithLayerGameObject.cs</code> \u2014 a base for UI sections that interact with presenters.</li> <li><code>LayerGameObjectPropertySectionInstantiator.cs</code> \u2014 a factory for spawning the right sections per layer type.</li> </ul> <p>Example property sections:</p> <ul> <li><code>FillColorPropertySection.cs</code> \u2014 controls polygon fill color.</li> <li><code>VerticalDatumPropertySection.cs</code> \u2014 adjusts reference elevation.</li> <li><code>ToggleScatterPropertySection.cs</code> \u2014 toggles scattered objects in polygon layers.</li> <li><code>CredentialsInputPropertySection.cs</code> \u2014 manages authentication for remote layers.</li> <li><code>WMSPropertySection.cs</code> \u2014 configures WMS source parameters.</li> </ul> <p>Each property section updates the model, not the scene directly. The presenter observes model changes and reflects them into the scene view \u2014 keeping data authoritative.</p>"},{"location":"docs/developers/layers/#37-the-ecosystem-of-creation-and-updates","title":"3.7. The ecosystem of creation and updates","text":"<p>Several utilities keep the system coherent:</p> Role Responsibility Typical Files Layers Service Facade that coordinates everything: building, destroying, and syncing. <code>Services/Layers.cs</code> LayerBuilder A Builder for constructing new models, which can be added using the Layers Service. <code>LayerBuilder.cs</code> LayerSpawner Factory for constructing, or spawning, the LayerGameObjects -or presenters-. <code>LayerSpawner.cs</code> LayerUIManager UI hierarchy and visibility control. <code>LayerUIManager.cs</code> <p>Together, they ensure that adding a new layer or reloading a project follows the same predictable pattern.</p>"},{"location":"docs/developers/layers/#38-hierarchy-order-and-visibility","title":"3.8. Hierarchy, order, and visibility","text":"<p>The hierarchy of <code>LayerData</code> mirrors Unity\u2019s transform hierarchy:</p> <ul> <li>Parenting maps to <code>Transform.parent</code>.</li> <li>Reordering maps to <code>SetSiblingIndex</code>.</li> <li>Visibility maps to <code>GameObject.SetActive</code>.</li> </ul> <p>Referenced layers maintain the same semantics even when their roots live elsewhere.</p>"},{"location":"docs/developers/layers/#4-crafting-layers","title":"4. Crafting Layers","text":""},{"location":"docs/developers/layers/#5-where-layers-live-and-how-they-travel","title":"5. Where Layers live and how they travel","text":""},{"location":"docs/developers/layers/#6-tips-best-practices","title":"6. Tips &amp; best practices","text":"<ul> <li>Let data lead. <code>LayerData</code> is the source of truth; presenters interpret it.</li> <li>Keep presenters idempotent. They should rebuild safely when data changes or reloads.</li> <li>Minimize deep nesting. Each transform level adds cost; prefer logical grouping.</li> <li>Clean teardown. Deregister and destroy referenced content carefully.</li> <li>Stay data-driven. Avoid hardcoded child references; rely on serialized data and builders.</li> <li>Respect Functionality toggles. Integrate with the <code>FunctionalityListener</code> system.</li> </ul>"},{"location":"docs/developers/layers/#8-recap","title":"8. Recap","text":"<ol> <li>The Project is your workshop \u2014 a collection of layer blueprints (<code>LayerData</code>).</li> <li>Each Layer is a blueprint that comes to life through its Presenter (<code>LayerGameObject</code>).</li> <li>The Presenter visualizes the in-world scene, and the UI panel visualizes the UI view.</li> <li>Properties let users fine-tune layer data; the presenter reflects those changes live.</li> <li>The LayerUIManager handles panel interaction, while LayerSpawner and Layers handle creation logic.</li> <li>Everything stays serializable, modular, and data-driven \u2014 ensuring reproducibility across sessions and machines.</li> </ol>"},{"location":"docs/developers/layers/#9-further-reading","title":"9. Further reading","text":"<ul> <li>Guide: Adding a new Layer Type</li> </ul>"},{"location":"docs/developers/platform-architecture/","title":"Platform Overview","text":"<p>Netherlands3D is a comprehensive platform designed to develop specialized 3D viewers that unify geospatial data from various sources. By integrating information from multiple parties, it enables organizations to visualize, analyze, and interact with spatial data in one centralized, interactive 3D environment. This approach transforms individual datasets into a cohesive, integral viewer, providing insights and context that would be hard to achieve by viewing data in isolation.</p>"},{"location":"docs/developers/platform-architecture/#a-platform-for-building-custom-viewers","title":"A Platform for Building Custom Viewers","text":"<p>Netherlands3D stands out as a flexible solution for creating tailored viewers suited to specific use cases. Its modular design, composed of individual Unity packages, allows developers to select and combine only the components they need. Each viewer built with Netherlands3D can be as simple or as complex as the project demands, with the ability to incorporate advanced functionalities such as live data updates, 3D rendering of large datasets, and interactive tools for exploration.</p>"},{"location":"docs/developers/platform-architecture/#centralized-data-integration","title":"Centralized Data Integration","text":"<p>The platform\u2019s core strength lies in its capacity to aggregate data from multiple external sources, including GIS databases, real-time sensor feeds, and specialized geospatial services. Netherlands3D acts as a data integrator, gathering disparate data streams and presenting them in a unified 3D viewer. This enables users to work within a single environment while accessing and analyzing comprehensive spatial data from various partners and services. By bringing diverse datasets together, Netherlands3D supports the development of digital twins and other projects requiring up-to-date and holistic data views.</p>"},{"location":"docs/developers/platform-architecture/#core-components","title":"Core Components","text":""},{"location":"docs/developers/platform-architecture/#building-blocks-unity-packages","title":"Building Blocks (Unity Packages)","text":"<p> Building blocks are the fundamental components of the Netherlands3D platform, each packaged as a Unity module with a specific function. These packages manage key tasks within the viewer -such as data handling, layer management,  and integrations with OGC standardized services- and can be added or removed independently to suit the viewer\u2019s  purpose.</p> <p>Each package is designed to be modular, allowing developers to choose only the components required for a particular project. This modularity supports the integration of data from various sources, such as GIS services and sensor networks, into a cohesive and interactive 3D viewer. By breaking down functionality into separate, reusable Unity packages, Netherlands3D simplifies maintenance and scalability, making it easy to adapt the viewer to evolving needs and datasets.</p>"},{"location":"docs/developers/platform-architecture/#functionalities","title":"Functionalities","text":"<p> Functionalities are specialized modules that encapsulate the capabilities of Netherlands3D\u2019s core building blocks. These functionalities handle unique tasks or provide interactions that enrich the viewer. Examples include urban development,  live sensor data overlays, and environmental simulation tools.</p> <p>The modular nature of functionalities allows them to be activated or configured on a per-project basis. By offering specific, configurable tools, functionalities make it easy for end-users to create viewers that cater to  specialized use cases. This flexible setup also enables developers to integrate real-time data or add interactive features, fostering engagement and insight through data visualization.</p>"},{"location":"docs/developers/platform-architecture/#the-twin-application","title":"The \"Twin\" Application","text":"<p>The Twin application provides a foundational viewer setup, pre-configured with essential building blocks and a selection of baseline functionalities. Designed to help users get started quickly, Twin offers an accessible path for building on the platform, providing a solid base configuration that can be expanded as needed.</p> <p>In addition to being a starting template, Twin also serves as an incubator for Netherlands3D\u2019s development team. New building blocks and functionalities are developed, tested, and refined within Twin before being packaged independently. This process allows the development team to evaluate how emerging functionalities interact within a full viewer context, addressing any issues early and ensuring seamless integration into the larger ecosystem.</p> <p>Once a new module or functionality reaches a level of stability and maturity, it is moved into its own Unity package, making it available for integration into other projects. This approach fosters innovation within a controlled environment, accelerating development while maintaining reliability.</p> <p>You can see the code at https://github.com/Netherlands3D/twin or see it in action at https://netherlands3d.eu/twin.</p>"},{"location":"docs/developers/projects/","title":"Projects","text":""},{"location":"docs/developers/projects/#overview","title":"Overview","text":"<p>Netherlands3D is a dynamic platform designed to allow users to interact with 3D geographical maps of locations across the Netherlands. This platform enables a wide array of spatial data interactions, from visualizing sensor telemetry to managing infrastructure data like cables, pipes, and zoning information. At the core of this functionality is the concept of Projects, which serve as containers for all user interactions and data on the platform.</p> <p>Projects in Netherlands3D encompass everything from the base map to the specific data layers, styles, and configurations that define the user's current view. Users can save these projects as snapshots of their work, allowing them to revisit, share, or continue working seamlessly at any time. This structure not only facilitates complex data analysis but also ensures that all spatial relationships are preserved and accurately represented.</p>"},{"location":"docs/developers/projects/#project-file-format","title":"Project File Format","text":"<p>Before diving into the technical specifics of how projects operate within the system, it's essential to understand the file format used to store project data. The project file acts as a blueprint, capturing all the layers, styles, configurations, and settings that define the project. </p> <p>Todo</p> <p>Describe the file format</p>"},{"location":"docs/developers/projects/#system-operation-overview","title":"System Operation Overview","text":"<p>Netherlands3D operates on a robust system that initializes with a default project file<sup>1</sup>. This default project acts as the foundation upon which all subsequent user interactions and loaded projects are based.</p>"},{"location":"docs/developers/projects/#included-empty-project","title":"Included Empty Project","text":"<p>Upon startup, the system loads an empty project file<sup>1</sup> from the Assets<sup>2</sup> folder. This project serves as the  initial state of the application, providing a base map and predefined configurations that set the scene for the user's  interaction. The empty project is crucial for ensuring that the application is ready to use immediately upon launch,  without requiring any user input.</p>"},{"location":"docs/developers/projects/#customizable-default-project","title":"Customizable Default Project","text":"<p>A default project is fully configurable per deployment, allowing providers to tailor the initial view and settings to their specific needs. For instance, a province or municipality might want to highlight a particular region or set specific visualization parameters to align with their objectives. This flexibility ensures that the application can be used in various contexts, whether as an interactive tool for end-users or a static viewer for presenting a digital twin of a specific location.</p> <p>Todo</p> <p>Describe how this can be done</p>"},{"location":"docs/developers/projects/#project-loading-and-replacement","title":"Project Loading and Replacement","text":"<p>Once the application is running, users can load their own project files. When a new project file is loaded, it replaces the current project in its entirety, bringing in all new data layers, styles, and configurations. This process ensures a smooth transition between different datasets and views, allowing users to focus on their work without worrying about residual configurations from previous projects.</p> <p>Todo</p> <p>Describe how this works in more detail with a flowchart illustrating the overall process</p>"},{"location":"docs/developers/projects/#how-layers-work","title":"How Layers Work","text":"<p>Self-registering layers</p> <p>A variant of the described flow exists where by adding the visualisation of a layer it self-registers the layer's data onto the current project. This flow will be described in a separate chapter for clarity.</p> <p></p> <p>The diagram provided illustrates the lifecycle of layers within a project, detailing how they are acquired, constructed, and visualized. Here's a breakdown:</p>"},{"location":"docs/developers/projects/#acquiring-layers","title":"Acquiring Layers","text":"<p>Layers in Netherlands3D can be added to a project in several ways:</p> <ul> <li> <p>Importing via URL or File Upload: The system allows users to import data layers by providing a URL or uploading a file. The uploaded or referenced file is stored within the current project, and the system determines the layer type based on the file name or its contents.</p> </li> <li> <p>Dragging from Object Library: Users can also add layers by dragging objects from a pre-existing object library. The system determines the type of layer based on the selected object.</p> </li> <li>Opening a Project: When a project is opened, the system unpacks its contents to a predefined storage path. This process involves instantiating a ProjectData object and associated LayerData objects through deserialization.</li> </ul>"},{"location":"docs/developers/projects/#constructing-layers","title":"Constructing Layers","text":"<p>Once a layer is added, the system begins constructing it:</p> <ul> <li>The system finds a visualizer identifier for the specific layer type and then instantiates a LayerData object accordingly.</li> <li>The LayerData is then registered with the current project, linking it to the broader project context.</li> </ul> <p>Layers consist of two primary components:</p> <ul> <li>Layer Data: This is a lightweight, serializable data object containing information about the layer, such as its source data location (e.g., file paths, URIs).</li> <li>Layer Visualizer: This component handles the actual visualization work, such as spawning tiles and rendering geometry.</li> </ul>"},{"location":"docs/developers/projects/#visualizing-layers","title":"Visualizing Layers","text":"<p>The final stage is visualizing the layers within the application:</p> <ul> <li>The system grabs the appropriate visualizer prefab based on the identifier in LayerData.</li> <li>The visualizer loads the data from LayerData, and the application schedules visualization activities.</li> <li>If necessary, the source data is parsed or interpreted before visualization, ensuring that all data layers are accurately represented.</li> <li>Finally, the visualization scheduler renders the data, allowing users to interact with the newly loaded layers seamlessly.</li> </ul> <p>This structured approach to handling layers ensures that all data is properly managed, visualized, and integrated within the project framework, offering a powerful tool for spatial analysis and geographic data management in the Netherlands3D platform.</p> <ol> <li> <p>https://github.com/Netherlands3D/twin/blob/main/Assets/Scriptables/CurrentProject.asset\u00a0\u21a9\u21a9</p> </li> <li> <p>https://github.com/Netherlands3D/twin/tree/main/Assets/Scriptables\u00a0\u21a9</p> </li> </ol>"},{"location":"docs/developers/quickstart/","title":"Quick Start Guide","text":"<p>Info</p> <p>This quickstart is aimed at developers who want to build on top of this platform, if all you want is to deploy it pre-configured on your platform, please read the guide on  deploying using Docker.</p>"},{"location":"docs/developers/quickstart/#prerequisites","title":"Prerequisites","text":"<p>Netherlands3D is developed in Unity, thus you'll need few prerequisites to start with the platform:</p> <ol> <li>Install Unity, the recommended version is Unity 6 (6000.0.58f2), including the WebGL build options. Please check     the Unity Download Page -or Unity Hub- and the official Installation Guide for assistance.</li> <li>Basic understanding of Unity and C# programming language.</li> </ol>"},{"location":"docs/developers/quickstart/#getting-started","title":"Getting Started","text":"<ol> <li> <p>We use Git LFS for storing large files. For Windows users, this is included in Git for Windows, while Mac users need to do the following:</p> <pre><code>brew install git-lfs\ngit lfs install\n</code></pre> </li> <li> <p>Clone the Netherlands3D/twin repository from GitHub:</p> <p>Warning</p> <p>The projects contains long paths, make sure you clone in a folder that is not too deeply nested - see  https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation?tabs=registry  for more information.</p> <pre><code>git clone https://github.com/Netherlands3D/twin.git\n</code></pre> </li> <li> <p>Once cloned, open the project in Unity. </p> </li> <li> <p>Now, go to the File menu, then select Build Settings. In the Build Settings window, choose WebGL and click Switch Platform.</p> </li> </ol>"},{"location":"docs/developers/quickstart/#recommendations","title":"Recommendations","text":""},{"location":"docs/developers/quickstart/#copy-the-main-scene","title":"Copy the Main scene","text":"<p>It's recommended to create a copy of the 'Main' scene before making any modifications. This ensures that you're not directly altering the original scene which, as the project is in continuous development, can lead to conflicts.</p> <p>To copy a scene in Unity:</p> <ul> <li>Select the 'Main' scene in the Project window.</li> <li>Press Ctrl+D or right-click and select 'Duplicate' from the context menu.</li> </ul>"},{"location":"docs/developers/quickstart/#next-steps","title":"Next Steps","text":"<p>With just these steps, you can immediately build and release your own customized Digital Twin; next up you can read up  on what and how you can configure the platform without making any code changes.</p>"},{"location":"docs/developers/styling/","title":"Layer Styles","text":"<p>Imagine you are dressing a city map for a public event. The <code>eu.netherlands3d.layer-styles</code> package is the wardrobe manager: it keeps outfits ready for every feature, checks who is walking past, and hands out the right clothes on the spot. </p> <p>This document walks through that wardrobe in plain language, highlighting the moving parts, the flow of data, and how other systems in Netherlands3D pick up the finished look.</p>"},{"location":"docs/developers/styling/#quick-cheat-sheet","title":"Quick cheat sheet","text":"<ul> <li>Purpose: Bridge the gap between saved styling data and the layer-specific renderers that bring it to life.</li> <li>Audience: Anyone wiring layer data to presentation logic\u2014whether you script styles on the fly, ship them with   layer metadata, or build custom authoring tools later.</li> <li>Mental shortcut: Treat the package as CSS for features. Rules match features, symbolizers hold properties, and the   resolver cascades them into a single outfit per feature.</li> </ul>"},{"location":"docs/developers/styling/#1-mental-model-at-a-glance","title":"1. Mental model at a glance","text":"Term Think of it as Where it lives LayerStyle A labeled clothing rack that groups related outfits <code>LayerStyle.cs</code> StylingRule A note on the rack saying \u201cIf the visitor matches this description, give them outfit X\u201d <code>StylingRule.cs</code> Symbolizer The actual outfit: colors, visibility flags, masks, custom notes <code>Symbolizer.cs</code> StyleResolver The wardrobe attendant who reads every note, checks the visitor, and layers outfits together <code>StyleResolver.cs</code> <p>Together they deliver CSS-inspired \u201ccascade\u201d behaviour: several rules can match one feature, and the last matching rule wins when the same property is set twice.</p> <p></p> <p>Pseudo-CSS to illustrate the anatomy of a Layer Style.</p> <p>Why not just use CSS?</p> <p>Good question! The expression language used for CSS selectors was never intended for complex queries such as the geospatial community knows, therefore we base our selectors on the Mapbox Style Spec's Expression language (https://docs.mapbox.com/style-spec/reference/expressions/).</p> <p>Also, we use JSON serializable data structures instead of a text-based syntax due to performance and layer  information is already stored in a JSON data structure. </p>"},{"location":"docs/developers/styling/#2-a-day-in-the-life-of-a-feature","title":"2. A day in the life of a feature","text":"<ol> <li>A layer is loaded and brings along one or more <code>LayerStyle</code> objects. Each style can include a    <code>default</code> rule so the layer has a baseline outfit without writing any selectors.</li> <li>A feature walks up with its attributes tucked inside <code>LayerFeature</code> and passes this to the StyleResolver.</li> <li>Every rule gets a chance. If a rule has no selector, it matches automatically; otherwise the expression is    evaluated against the feature. This is where you filter on height, zoning, owner, or any other attribute.</li> <li>Matching rules stack. When the selector passes, that rule\u2019s symbolizer is merged on top of the current    symbolizer. Later matches overwrite earlier ones, just like cascading CSS</li> <li>The layer visualizer receives one symbolizer containing the final set of properties. Each layer type (buildings,    terrain, parcels\u2026) interprets the symbolizer in its own rendering code, allowing wildly different visualisations    while keeping the contract the same.</li> </ol> <p>If you prefer a concrete -fictive- story, picture the \u201cCanal District Buildings\u201d layer with three rules:</p> Rule Selector (story form) Key style tweaks <code>default</code> Everything gets a calm sandstone paint Soft beige fill, subtle outline <code>Monuments</code> Buildings marked with <code>isMonument</code> Swap fill to deep green, add golden outline <code>NightLights</code> Opening hours past 22:00 Window color switches from blue to yellow <p>Written as pseudo-CSS</p> <pre><code>/* All features' fill color is \"sandstone\" */\n* {\n    fill: sandstone;\n}\n\n/* Except for windows in buildings - their fill color is blue */\nBuilding Window {\n    fill: blue;\n}\n\n/* \n  When buildings have the `is-monument` attribute set to the value `true`, \n  their fill color is deepgreen and they have a golden stroke\n*/\nBuilding[is-monument=true] {\n    fill: deepgreen;\n    stroke: golden;\n}\n\n/* \n  Windows of buildings whose opening hours is later than 22:00 should \n  have yellow windows\n*/\nBuilding[opening-hours &gt; 22:00] Window {\n    fill: yellow;\n}\n</code></pre> <p>When the feature for the Old Town Hall shows up, the resolver </p> <ol> <li>applies the default styling rule, </li> <li>spots the monument badge, and </li> <li>notes that its opening hours stretch late into the night. </li> </ol> <p>The final symbolizer mixes all three contributions, and the visualizer turns those knobs however it likes (perhaps by  feeding a shader, perhaps by toggling a prefab).</p>"},{"location":"docs/developers/styling/#3-what-does-a-symbolizer-look-like","title":"3. What does a symbolizer look like?","text":"<p>Symbolizers store everything as strings so they survive JSON round-tripping without special converters. Typed helpers translate those strings back into Unity data types when you need them, for example: </p> <ul> <li>colors become <code>Color</code> structs, </li> <li>visibility is exposed as <code>bool</code> </li> <li>masks are bitfields written as binary strings, and </li> <li>custom properties are JSON blobs prefixed with <code>--</code> to follow MDN-style naming (lowercase kebab-case).</li> </ul> <p>Here is an illustrative example of what a symbolizer might represent when serialized:</p> <pre><code>{\n  \"properties\": {\n    \"fill\": \"#FFAA33FF\",     // soft orange facade\n    \"stroke\": \"#333333FF\",   // charcoal outlines\n    \"visibility\": \"visible\",       // feature should render\n    \"mask-layer-mask\": \"00000100\", // use third mask layer bit\n    \"--shadow-style\": \"long\"      // custom flag read by a shader extension\n  }\n}\n</code></pre> <p>You set these values with the <code>SetFillColor</code>, <code>SetStrokeColor</code>, <code>SetVisibility</code>, <code>SetMaskLayerMask</code>, and <code>SetCustomProperty</code> helpers; clearing a property simply removes the key so downstream systems know to ignore it.</p>"},{"location":"docs/developers/styling/#4-understanding-the-cascade","title":"4. Understanding the Cascade","text":"<p>If several styling rules apply to the same feature, the cascade decides which property values survive. It works like layers of transparent paint: each new rule adds color where it speaks, but leaves untouched areas showing through from earlier coats.</p> <p>Core idea:</p> <ol> <li>Rules are evaluated in order.</li> <li>Matching rules merge their <code>Symbolizer</code> properties into the current result.</li> <li>If a property key already exists, the new value overwrites the old one.</li> <li>Missing keys are ignored, meaning \u201ckeep whatever is already there.\u201d</li> </ol> <p>You can picture it as a running dictionary merge:</p> <pre><code>foreach (var rule in rules)\n{\n    if (rule.Matches(feature))\n        finalSymbolizer.Merge(rule.Symbolizer);\n}\n</code></pre> <p>The merge method simply copies non-null entries:</p> <pre><code>public void Merge(Symbolizer other)\n{\n    foreach (var kvp in other.Properties)\n        Properties[kvp.Key] = kvp.Value;\n}\n</code></pre>"},{"location":"docs/developers/styling/#pseudo-css-cascade-example","title":"Pseudo-CSS Cascade Example","text":"<p>Let\u2019s restate the \u201cCanal District Buildings\u201d scenario in cascade form:</p> <pre><code>/* 1. Default look \u2014 everyone starts beige */\n* {\n  fill: sandstone;\n  --my-custom-property: flagged;\n}\n\n/* 2. Monuments override fill and stroke */\nBuilding[is-monument=true] {\n  fill: deepgreen;\n  stroke: golden;\n}\n</code></pre> <p>Now imagine a single feature:</p> <pre><code>{\n  \"geometry\": [123.11, 123.12, 321.21, 321.11],\n  \"properties\": {\n    \"is-monument\": true,\n    \"opening-hours\": \"23:00\"\n  }\n}\n</code></pre> <p>Cascade resolution:</p> Step Rule Applied Merged Properties Notes 1 <code>default</code> <code>fill: sandstone</code>, <code>--my-custom-property: flagged</code> Base layer with property 2 <code>Monuments</code> <code>fill: deepgreen</code>, <code>stroke: golden</code> Override fill and adds stroke <p>Final symbolizer result:</p> <pre><code>{\n  \"fill\": \"deepgreen\",\n  \"--my-custom-property\": \"flagged\",\n  \"stroke\": \"golden\"\n}\n</code></pre> <p>The renderer only ever sees this merged view. No selector logic or layer-specific detail leaks into rendering  code\u2014making it trivial to test and reuse.</p>"},{"location":"docs/developers/styling/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Later rules win on key collisions.</li> <li>Missing properties don\u2019t clear existing values.</li> <li>Order matters; specificity does not.</li> <li>The cascade operates purely through dictionary merges\u2014no parsing, no sorting, no text evaluation.</li> </ul>"},{"location":"docs/developers/styling/#5-crafting-styling-rules","title":"5. Crafting styling rules","text":"<p>A <code>StylingRule</code> combines a friendly name, one symbolizer, and an optional selector expression. Selectors use the Serializable GIS Expressions library, so you can compose Mapbox-style expressions (<code>==</code>, <code>in</code>, arithmetic, color utilities, etc.) to decide when a rule applies. Leave the selector <code>null</code> to create a base rule that always fires.</p> <p>Narrative example:</p> <ul> <li>Rule name: <code>Tall towers</code></li> <li>Selector: \"height &gt; 70\" expressed as <code>[\"&gt;\", [\"get\", \"height\"], 70]</code></li> <li>Symbolizer: Glowing outline and a semi-transparent fill.</li> </ul> <p>When a skyscraper feature arrives, the rule paints it accordingly; shorter buildings never see this style. During resolution, any 72-metre high-rise will slip into this style after the default styling, while a 45-metre apartment block simply keeps the baseline look. If you later add a <code>Residential highlight</code> rule that also matches the apartment block, whichever rule comes last in the style list decides the final stroke colour.</p>"},{"location":"docs/developers/styling/#6-where-styles-live-and-how-they-travel","title":"6. Where styles live and how they travel","text":"<p>The package is deliberately agnostic about storage. Anything Newtonsoft JSON can serialize/deserialise will work, so projects are free to tuck styles into scriptable objects, JSON files, or layer metadata. </p> <p>In Netherlands3D, layer styles travel alongside layer data objects\u2014each layer reads the symbolizer contract and applies  it using layer-specific visualisation code. This division keeps the package focused on the data contract between  persistence and presentation: authoring tools fill in the styles, while visualizers interpret them.</p> <p>Because styles are plain C# objects, you can experiment quickly in code. For example, during prototyping you might deserialize a JSON file into a <code>LayerStyle</code>, tweak the resulting <code>Symbolizer</code> objects in memory to respond to user input, and then write the updated structure back to disk\u2014no custom editor tooling required. Later, if you decide to build a designer UI, it only has to speak the same JSON contract.</p> <p>Because the data structures are plain C# classes with JSON constructors, there is no dedicated Unity editor UI today. Teams manipulate styles in code during runtime, keeping integration simple and leaving room for bespoke authoring pipelines later on.</p>"},{"location":"docs/developers/styling/#7-tips-gotchas-and-conventions","title":"7. Tips, gotchas, and conventions","text":"<ul> <li>Custom properties: Prefix them with <code>--</code> (automatically enforced) and use lowercase kebab-case for readability,   mirroring CSS custom property conventions.</li> <li>Merge order matters: Supply styles/rules to the resolver in the order you want later rules to win. The resolver   simply iterates the dictionary values, so keep the collection deterministic if you rely on precise overrides.</li> <li>Specificity does not matter: contrary to CSS, there is no resolving based on specificity. This may be added in a   later version but to preserve performance it is not implemented.</li> <li>Null means \u201cignore me\u201d: When a property is missing or a getter returns <code>null</code>, the renderer should leave the   previous value untouched. This is how the cascade differentiates between \u201cI don\u2019t care\u201d and \u201cexplicitly clear this   setting.\u201d</li> </ul>"},{"location":"docs/developers/styling/#8-recap","title":"8. Recap","text":"<ol> <li>Start with a <code>LayerStyle</code> rack and its default rule.</li> <li>Add descriptive <code>StylingRule</code> notes with selectors and symbolizers.</li> <li>Hand the rack to the <code>StyleResolver</code>.</li> <li>As each feature comes in, the resolver stacks matching symbolizers into one outfit.</li> <li>The layer renderer interprets the final symbolizer however it likes\u2014painting meshes, toggling game objects, feeding    shaders\u2014without ever needing to know where the data came from.</li> </ol> <p>With this shared mental picture, team members can approach the package as a friendly wardrobe rather than a mysterious black box, and layer teams can concentrate on rendering while data teams focus on expressive styling contracts.</p>"},{"location":"docs/developers/styling/#9-further-reading","title":"9. Further reading","text":"<ul> <li>Explanation: Projects</li> <li>Explanation: Layer styling</li> <li>Guide: Adding a simple type of layer</li> </ul>"},{"location":"docs/developers/contributing/coding-standards/","title":"Coding Standards","text":"<p>This document outlines the coding standards for our Unity project. Adhering to consistent coding styles helps maintain the readability, maintainability, and collaboration ease of our codebase. These standards are in alignment with Unity\u2019s C# scripting practices and incorporate additional guidelines specific to our project.</p>"},{"location":"docs/developers/contributing/coding-standards/#1-naming-and-code-style","title":"1. Naming and Code Style","text":"<p>We follow the naming and code style tips provided by Unity  to ensure consistency and familiarity for all developers working in our Unity project. Key aspects of this style  include:</p> <ul> <li>PascalCasing for public properties, class names, and methods.</li> <li>camelCasing for private fields and local variables.</li> <li>Suffix boolean variables with Is, Has, or Can (e.g., isReady, hasAccess, canShoot).</li> <li>Avoid abbreviations unless they are well-known (e.g., maxHealth is preferable over mH).</li> </ul> <p>We also emphasize clarity and meaningful names over brevity, ensuring that variable and function names communicate their intent effectively.</p> <p>It is important to read the full guide at https://unity.com/how-to/naming-and-code-style-tips-c-scripting-unity  for a more complete picture of the coding guidelines followed in this project.</p>"},{"location":"docs/developers/contributing/coding-standards/#general-principles","title":"General Principles","text":"<ul> <li>Call a thing what it is. A bird should be called Bird.</li> <li>Choose names that can be pronounced and remembered.</li> <li>Be consistent. When you choose a name, stick to it.</li> <li>Use Pascal case, like this: ComplicatedVerySpecificObject. Do not use spaces, underscores, or hyphens.</li> <li>Do not use version numbers, or words to indicate their progress (WIP, final).</li> <li>Do not use abbreviations: DVamp@W should be DarkVampire@Walk.</li> <li>Keep the most specific descriptor on the left: PauseButton, not ButtonPaused. It is, for instance, easier to find    the pause button in the inspector if not all buttons start with the word Button.</li> <li>Some names form a sequence. Use numbers in these names, for example, PathNode0, PathNode1. Always start with 0, not 1.</li> <li>Do not use numbers for things that don\u2019t form a sequence. For example, Bird0, Bird1, Bird2 should be Flamingo, Eagle, Swallow.</li> </ul>"},{"location":"docs/developers/contributing/coding-standards/#structure","title":"Structure","text":"<p>The organisation of your project folder should follow a similar pattern.</p> <p>Warning</p> <p>We are in the process of moving project files to the structure below, until that process is complete you can expect to find asset folders directly in the root of the Assets folder.</p> <p>For new components it is recommended to follow this structure.</p> <p>We differentiate between architectural folders and asset folders. Architectural folders are meant to organize the  project in such a way that we have a modular -or composable- architecture with independent layers; asset folders can be  found inside each architectural folder and is similar to the regular folder structure that is normal with Unity.</p>"},{"location":"docs/developers/contributing/coding-standards/#architectural-folders","title":"Architectural folders","text":"<p>In the <code>Assets</code> folder there are four special folders:</p> <ol> <li>_Application - assets needed for the application itself, such as<ul> <li>Rendering pipelines, </li> <li>Inputsystem, </li> <li>Overall ui, </li> <li>Bootstrapping</li> <li>etc.</li> </ul> </li> <li>_BuildingBlocks - contains a series of folders for each building block that can be consumed by a functionality</li> <li>_Functionalities</li> <li>_UIKit</li> </ol>"},{"location":"docs/developers/contributing/coding-standards/#unity-folder-structure","title":"Unity Folder Structure","text":"<ul> <li>Animations</li> <li>Editor</li> <li>Fonts</li> <li>Materials</li> <li>Models</li> <li>Resources</li> <li>Prefabs</li> <li>Scenes</li> <li>ScriptableObjects</li> <li>Scripts</li> <li>Shaders</li> <li>Sprites</li> <li>Textures</li> </ul>"},{"location":"docs/developers/contributing/coding-standards/#2-bracing-style","title":"2. Bracing Style","text":"<p>We use the Allman style for braces, which is standard in most C# coding conventions. This style places opening  braces on a new line:</p> <pre><code>public class Player\n{\n    public void Jump()\n    {\n        // Code here\n    }\n}\n</code></pre> <p>This ensures clear structure and improves readability, especially in nested code blocks.</p>"},{"location":"docs/developers/contributing/coding-standards/#3-indentation","title":"3. Indentation","text":"<p>Indentation is essential for making code readable and understandable at a glance. We use 4 spaces for indentation rather than tabs. This ensures consistent formatting across different environments and prevents issues with mixed tab and space usage.</p> <p>Ensure the indentation is correct, especially when working with nested blocks of code.</p>"},{"location":"docs/developers/contributing/coding-standards/#nesting-levels","title":"Nesting Levels","text":"<p>To maintain clarity and readability, the number of nesting levels within any method or function should be limited to 2 at most. If a deeper level of nesting is required, consider refactoring the code into supporting methods or even supporting services. This helps in avoiding overly complex methods and improves the maintainability of the code.</p> <p>Example</p> <p>Instead of having deeply nested if-statements or loops:</p> <pre><code>public void ProcessPlayerInput(Player player)\n{\n    if (player != null)\n    {\n        if (player.HasControl())\n        {\n            if (player.IsAlive)\n            {\n                if (player.HasWeapon())\n                {\n                    if (player.CanShoot())\n                    {\n                        ShootWeapon(player);\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>This code is difficult to read due to the excessive nesting. To improve readability, we can refactor the logic into separate methods:</p> <pre><code>public void ProcessPlayerInput(Player player)\n{\n    if (!IsValidPlayer(player)) return;\n\n    if (CanPlayerShoot(player))\n    {\n        ShootWeapon(player);\n    }\n}\n\nprivate bool IsValidPlayer(Player player)\n{\n    return player != null &amp;&amp; player.HasControl() &amp;&amp; player.IsAlive;\n}\n\nprivate bool CanPlayerShoot(Player player)\n{\n    return player.HasWeapon() &amp;&amp; player.CanShoot();\n}\n</code></pre> <p>In this refactored example, the nesting is limited to 2 levels, and the logic has been broken down into meaningful, self-explanatory methods, making the code easier to understand and maintain. Each method handles a specific responsibility, which also helps with unit testing and debugging.</p>"},{"location":"docs/developers/contributing/coding-standards/#4-git-branching-strategy","title":"4. Git Branching Strategy","text":"<p>When creating branches for new features or bug fixes, follow the naming conventions outlined below. These conventions make it clear what type of change is being worked on and make branches easier to track and manage.</p> <ul> <li> <p>Branch Prefixes:</p> </li> <li> <p><code>feature/</code> for new features.</p> </li> <li> <p><code>fix/</code> for bug fixes or adjustments.</p> </li> <li> <p>Branch Name Format: Use kebab-case for branch names, which involves using hyphens (-) to separate words.</p> </li> </ul> <p>Examples:</p> <ul> <li>feature/implement-player-movement</li> <li>fix/camera-rotation-bug</li> </ul> <p>Following this strategy keeps the Git history clean and makes collaboration smoother, as everyone can quickly understand the purpose of each branch.</p>"},{"location":"docs/developers/contributing/documentation/","title":"Contributing to our Documentation","text":"<p>Thank you for your interest in contributing to the Netherlands3D documentation. This guide provides all the necessary information to help you get started with contributing to our documentation, which is composed of Markdown documents in our GitHub repository and is automatically built using MkDocs whenever a pull request is merged.</p>"},{"location":"docs/developers/contributing/documentation/#getting-started","title":"Getting Started","text":"<p>First, you'll need to set up your environment for making contributions:</p> <ol> <li>Fork the Repository: Go to https://github.com/Netherlands3D/netherlands3D.github.io/ and fork the repository to     your GitHub account.</li> <li>Clone the Fork: Clone your forked repository to your local machine to make changes.</li> </ol>"},{"location":"docs/developers/contributing/documentation/#previewing-changes","title":"Previewing Changes","text":"<p>You can preview the documentation locally in two different ways: either using Docker (recommended, no local installation required),or by installing MkDocs directly on your system.</p>"},{"location":"docs/developers/contributing/documentation/#option-1-using-docker-recommended","title":"Option 1: Using Docker (Recommended)","text":"<p>If you have Docker Desktop installed and running, you can follow these steps:</p> <ol> <li>Open Powershell (or your IDE's terminal)</li> <li>Make sure you are in your project folder (usually something like <code>C:\\Users\\[username]\\[path to where you cloned]\\Netherlands3D.github.io</code>)</li> <li>Run the included helper script:    <pre><code>.\\bin\\develop.bat\n</code></pre></li> </ol> <p>This will start a virtual webserver inside Docker and make the site available at:</p> <pre><code>http://localhost:8000\n</code></pre> <p>As long as the script is running, any edits you make to the documentation files will automatically be detected and the site will refresh. In most cases, your browser will even reload automatically.</p> <p>This method ensures a consistent environment for all contributors.</p>"},{"location":"docs/developers/contributing/documentation/#option-2-installing-mkdocs-locally","title":"Option 2: Installing MkDocs Locally","text":"<p>If you prefer to install MkDocs directly on your machine:</p> <ol> <li>Follow the installation guide on the MkDocs website and on     the mkdocs-material website.</li> <li>In your project directory, run:</li> </ol> <pre><code>mkdocs serve\n</code></pre> <p>This will start a local development server and make the site available at:</p> <pre><code>http://localhost:8000\n</code></pre> <p>Like with Docker, changes to the files will automatically update the preview.</p>"},{"location":"docs/developers/contributing/documentation/#making-contributions","title":"Making Contributions","text":""},{"location":"docs/developers/contributing/documentation/#language-and-voice","title":"Language and Voice","text":"<ul> <li>For user and organisation facing parts of the documentation, write in Dutch using the passive voice.</li> <li>For developer-facing documentation, write in English.</li> </ul>"},{"location":"docs/developers/contributing/documentation/#adding-or-editing-content","title":"Adding or Editing Content","text":"<ol> <li>Create a New Branch: Before making any changes, create a new branch in your forked repository.</li> <li>Add/Edit Markdown Files: Make your changes or add new content in the appropriate Markdown (.md) files. Be sure to    follow    the language and voice guidelines mentioned above.</li> <li>Update mkdocs.yml: If you are adding a new page, don't forget to update the mkdocs.yml configuration file to    include    your new page in the navigation.</li> </ol>"},{"location":"docs/developers/contributing/documentation/#submitting-your-contributions","title":"Submitting Your Contributions","text":"<p>Once you are satisfied with your changes:</p> <ol> <li>Commit Your Changes: Add your changes to your fork and commit them with a clear commit message.</li> <li>Push to Your Fork: Push your changes to your GitHub fork.</li> <li>Create a Pull Request: Go to the original Netherlands3D/docs repository and create a new pull request. Target the    main branch for your pull request and provide a clear description of your changes.</li> <li>Review Process: Your pull request will be reviewed by the Netherlands3D documentation team. Be open to feedback    and make any requested changes.</li> </ol>"},{"location":"docs/developers/contributing/documentation/#conclusion","title":"Conclusion","text":"<p>Contributing to the Netherlands3D documentation is a collaborative effort. We appreciate your willingness to contribute and look forward to improving our documentation with your help. If you have any questions or need assistance, please open an issue in the GitHub repository.</p>"},{"location":"docs/developers/contributing/writing-explanation-pages/","title":"Writing Explanation Pages","text":"<p>Explanation pages in Netherlands3D are designed to teach understanding \u2014 not procedures or API details. They connect architectural reasoning, design principles, and mental models in a way that developers, product managers, and auditors can follow without needing to read the source code.</p> <p>This guide describes how to write an Explanation page in our documentation using the Netherlands3D narrative structure.</p>"},{"location":"docs/developers/contributing/writing-explanation-pages/#1-purpose-of-explanation-pages","title":"1. Purpose of Explanation Pages","text":"<p>Explanation pages answer the question:</p> <p>\u201cHow does this concept work \u2014 and why is it designed this way?\u201d</p> <p>They are where readers develop a mental model. Unlike tutorials or guides, explanations are not step-by-step or goal-oriented. They focus on conceptual clarity, architectural insight, and rationale.</p> <p>You should write an Explanation page when you need to:</p> <ul> <li>Clarify how a core system (e.g., Layers, Styling, Catalogs, Tiles) fits into the overall architecture.</li> <li>Explain design trade-offs, conceptual patterns, or system lifecycles.</li> <li>Provide a shared vocabulary for technical and non-technical stakeholders.</li> <li>Help readers reason about code without diving into implementation details.</li> </ul>"},{"location":"docs/developers/contributing/writing-explanation-pages/#2-relationship-to-the-diataxis-framework","title":"2. Relationship to the Di\u00e1taxis Framework","text":"Di\u00e1taxis Category Focus Tone Typical Output Tutorials Learn by doing Friendly, step-by-step \u201cHello World\u201d examples How-to Guides Achieve a goal Practical, direct \u201cHow to add a new layer type\u201d Explanations Understand concepts Narrative, reflective \u201cHow layer styles cascade\u201d Reference Look up facts Precise, formal API lists, configuration schemas <p>This guide focuses exclusively on Explanations. For more information, see https://diataxis.fr/.</p>"},{"location":"docs/developers/contributing/writing-explanation-pages/#3-core-structure-for-an-explanation-page","title":"3. Core Structure for an Explanation Page","text":"<p>We use a consistent nine-part structure inspired by Layer Styles and Layers explainers. It balances narrative storytelling with technical clarity.</p> Section Purpose Typical Elements Title &amp; Hero Image Introduce the concept visually and narratively. Short metaphorical title, right-aligned image or diagram. Intro (analogy) Set the scene \u2014 connect an everyday metaphor to the technical topic. A \u201cImagine you are\u2026\u201d paragraph linking real-world intuition. Quick cheat sheet Establish audience and purpose. Three bullets: Purpose, Audience, Mental shortcut. 1. Mental model at a glance Present the conceptual building blocks. A table mapping terms \u2192 metaphors \u2192 file locations. 2. A day in the life of X Walk through runtime behavior or flow. 4\u20136 steps describing lifecycle or data flow. 3. What does X look like? Show how it looks in code or data form. JSON, YAML, or code snippet representing structure. 4. Understanding the lifecycle / cascade / flow Explain how the system behaves dynamically. Example logic, small code block, and annotated tables. 5. Crafting / Defining / Extending X Show how to create or modify it. Step-by-step or conceptual instructions. 6. Where X lives and how it travels Describe how it connects to the rest of the system. Explain persistence, serialization, or interaction with other modules. 7. Tips, gotchas, conventions Capture practical wisdom and conventions. Bullet list of dos, don\u2019ts, naming, and performance notes. 8. Recap Reinforce main takeaways. 4\u20136 concise summary points. 9. Further reading Link to related guides and references. Crosslinks to guides, references, or ADRs. <p>This structure helps maintain narrative coherence across all explanation pages.</p>"},{"location":"docs/developers/contributing/writing-explanation-pages/#4-writing-style-guidelines","title":"4. Writing Style Guidelines","text":""},{"location":"docs/developers/contributing/writing-explanation-pages/#tone","title":"Tone","text":"<ul> <li>Use plain language and conversational flow \u2014 write as if explaining to a new developer joining the project.</li> <li>Prefer analogies and metaphors that make abstract systems tangible (\u201cThink of the resolver as a wardrobe   attendant\u201d).</li> <li>Balance metaphor and precision: introduce with metaphor, then map it explicitly to real code.</li> </ul>"},{"location":"docs/developers/contributing/writing-explanation-pages/#structure-and-formatting","title":"Structure and Formatting","text":"<ul> <li>Use consistent heading numbers (1\u20139).</li> <li>Always include Quick cheat sheet early on for fast scanning.</li> <li>Include tables for mental models and code blocks for structure or examples.</li> <li>Separate sections with horizontal rules (<code>---</code>) for readability.</li> <li>Use MkDocs callouts (<code>!!! note</code>, <code>!!! warning</code>, <code>!!! example</code>, <code>!!! question</code>) to enrich explanations.</li> <li>Use JSONC syntax for serialized examples so comments can annotate meaning.</li> </ul>"},{"location":"docs/developers/contributing/writing-explanation-pages/#visuals","title":"Visuals","text":"<ul> <li>Include at least one right-aligned or inline image per explainer (e.g., diagram, conceptual illustration).</li> <li>Caption images using <code>/// caption</code> blocks when relevant.</li> <li>Keep visuals conceptual \u2014 not UI screenshots \u2014 unless they explain the architecture.</li> </ul>"},{"location":"docs/developers/contributing/writing-explanation-pages/#references","title":"References","text":"<ul> <li>Link directly to relevant <code>.cs</code> files in GitHub (preferably with permalink).</li> <li>Use relative links for internal docs (<code>./guides/...</code>, <code>../imgs/...</code>).</li> </ul>"},{"location":"docs/developers/contributing/writing-explanation-pages/#5-example-skeleton-template","title":"5. Example Skeleton Template","text":"<p>Use this template as a starting point for any new Explanation page:</p> <pre><code># [Concept Name]\n\n![concept-diagram.png](../imgs/concept-diagram.png){align=right width=300}\n\nImagine you are [metaphor here].  \nThis document explains how [concept] works within Netherlands3D, showing its moving parts, data flow, and relationships\nwith other systems.\n\n## Quick cheat sheet\n\n- **Purpose:** [Short description]\n- **Audience:** [Intended readers]\n- **Mental shortcut:** [Metaphor summary]\n\n## 1. Mental model at a glance\n\n| Term | Think of it as | Where it lives |\n|------|----------------|----------------|\n| [Key term] | [Analogy] | `[File.cs]` |\n| ... | ... | ... |\n\n## 2. A day in the life of a [concept]\n\n1. [Step 1]\n2. [Step 2]\n3. [Step 3]\n4. ...\n\n## 3. What does it look like?\n\n```jsonc\n{ ...example structure... }\n```\n\n## 4. Understanding the [flow/lifecycle/cascade]\n\nExplain how this system behaves dynamically, using annotated examples or diagrams.\n\n## 5. Crafting or extending a [concept]\n\nGuidelines for defining or extending the concept, with examples.\n\n## 6. Where it lives and how it travels\n\nExplain how it\u2019s serialized, stored, or passed between systems.\n\n## 7. Tips, gotchas, and conventions\n\n* [Convention 1]\n* [Convention 2]\n* [Performance tip]\n\n## 8. Recap\n\n1. [Key insight]\n2. [Key insight]\n3. [Key insight]\n\n## 9. Further reading\n\n* [Guide link]\n* [Reference link]\n</code></pre>"},{"location":"docs/developers/contributing/writing-explanation-pages/#6-author-checklist","title":"6. Author Checklist","text":"<p>Before submitting a new Explanation page:</p> <ul> <li>[ ] The document follows the nine-section structure.</li> <li>[ ] It uses a clear, relatable metaphor in the introduction.</li> <li>[ ] It includes a Quick cheat sheet table.</li> <li>[ ] It references real code files where appropriate.</li> <li>[ ] JSON or C# snippets match current code.</li> <li>[ ] It links to at least one related Guide and Reference page.</li> <li>[ ] It has been proofread for consistent tone and technical accuracy.</li> </ul>"},{"location":"docs/developers/contributing/writing-explanation-pages/#7-example-pages-to-learn-from","title":"7. Example Pages to Learn From","text":"<ul> <li>Layers</li> <li>Layer Styles</li> </ul>"},{"location":"docs/developers/contributing/writing-explanation-pages/#8-summary","title":"8. Summary","text":"<p>Explanation pages form the conceptual backbone of the Netherlands3D documentation. They connect the why behind systems to the how found in guides and references, giving readers the mental model to navigate complex architectures confidently.</p> <p>By following this structure, every new explainer remains readable, cohesive, and visually aligned with the rest of the docs \u2014 helping both new contributors and long-term maintainers understand the system, not just use it.</p>"},{"location":"docs/developers/contributing/writing-explanation-pages/#9-further-reading","title":"9. Further reading","text":"<ul> <li>Contributing to the documentation</li> <li>Writing guides</li> </ul>"},{"location":"docs/developers/contributing/writing-guides/","title":"Writing How-to Guides","text":"<p>How-to Guides in Netherlands3D describe practical procedures that achieve a specific goal. They are for readers who already understand the concepts (from Explanation pages) and now want to do something concrete \u2014 like \u201ccolor terrain parts,\u201d \u201cadd a new layer type,\u201d or \u201cconnect a catalog service.\u201d</p> <p>This guide explains how to structure, write, and review a Netherlands3D How-to Guide following the  Di\u00e1taxis framework.</p>"},{"location":"docs/developers/contributing/writing-guides/#1-purpose-of-how-to-guides","title":"1. Purpose of How-to Guides","text":"<p>How-to Guides answer the question:</p> <p>\u201cHow do I accomplish this task?\u201d</p> <p>They focus on getting results, not on explaining architecture or theory. Readers expect to follow steps, run examples, and see immediate outcomes.</p> <p>You should write a How-to Guide when:</p> <ul> <li>You\u2019re documenting a repeatable process or workflow.</li> <li>The reader already understands the why, and only needs the how.</li> <li>The procedure can be completed in a few clear steps, often with code.</li> </ul>"},{"location":"docs/developers/contributing/writing-guides/#2-relationship-to-the-diataxis-framework","title":"2. Relationship to the Di\u00e1taxis Framework","text":"Di\u00e1taxis Category Focus Tone Typical Output Tutorials Learn by doing Guided, educational \u201cBuild your first layer project\u201d How-to Guides Achieve a goal Practical, concise \u201cHow to color parts of the terrain\u201d Explanations Understand concepts Reflective, narrative \u201cHow layer styles cascade\u201d Reference Look up facts Formal, precise API and configuration details <p>This page focuses exclusively on How-to Guides. For more information, see  https://diataxis.fr/.</p>"},{"location":"docs/developers/contributing/writing-guides/#3-standard-structure","title":"3. Standard Structure","text":"<p>Each guide follows a predictable structure for clarity and scanning. Readers should be able to jump to the section they need and copy-paste code safely.</p> Section Purpose Typical Elements Title Clearly describe the goal. \u201cHow to color parts of the terrain\u201d Introduction Explain what the reader will achieve and why it\u2019s useful. 2-3 lines with context. Prerequisites List what\u2019s needed before starting. Layers, components, SDK versions, or project setup. Step-by-Step Instructions Core of the guide \u2014 numbered steps that lead to success. 3-6 sequential sections, each with code or screenshots. Verification / Testing Show how to confirm the result works. Checklist or run instructions. What\u2019s Next? Suggest extensions or related improvements. Optional, encourages exploration. Performance Tips / Common Pitfalls Optimization hints or warnings. Optional, but very useful. Further Reading Link to explanations, guides, or references. Always end with cross-references."},{"location":"docs/developers/contributing/writing-guides/#4-writing-style-guidelines","title":"4. Writing Style Guidelines","text":""},{"location":"docs/developers/contributing/writing-guides/#tone","title":"Tone","text":"<ul> <li>Be direct and task-oriented: readers are here to do something.</li> <li>Use imperative verbs (\u201cClick,\u201d \u201cCreate,\u201d \u201cCall,\u201d \u201cAdd\u201d).</li> <li>Avoid theoretical detours \u2014 link to explanation pages instead.</li> <li>Write one goal per guide. If a task has branches, make separate guides.</li> </ul>"},{"location":"docs/developers/contributing/writing-guides/#code-and-formatting","title":"Code and Formatting","text":"<ul> <li>Use C# for Unity examples unless another language is unavoidable.</li> <li>Use fenced code blocks (<code>```csharp</code>, <code>```jsonc</code>, etc.) with inline comments for clarity.</li> <li>Provide copy-pasteable snippets that compile or run as written.</li> <li>Separate sections with horizontal rules (<code>---</code>) for readability.</li> <li>Use MkDocs callouts (<code>!!! tip</code>, <code>!!! warning</code>, <code>!!! example</code>) to emphasize key details.</li> </ul>"},{"location":"docs/developers/contributing/writing-guides/#style-of-instruction","title":"Style of Instruction","text":"<p>Each step should:</p> <ol> <li>State the goal (\u201cCreate a color mapping for terrain features\u201d).</li> <li>Explain the reasoning briefly (\u201cThis uses the feature\u2019s material index\u201d).</li> <li>Show the code or action required.</li> <li>Conclude with what the reader should observe (\u201cFootpaths now appear beige.\u201d).</li> </ol>"},{"location":"docs/developers/contributing/writing-guides/#visual-and-structural-conventions","title":"Visual and Structural Conventions","text":"<ul> <li>Start every code step with a heading like Step 1: ...</li> <li>Use consistent section titles (<code>## Step 1</code>, <code>## Step 2</code>, etc.).</li> <li>Include at least one example output (screenshot, visual, or JSON result).</li> <li>Keep lines under ~100 characters where possible for readability in narrow docs layouts.</li> </ul>"},{"location":"docs/developers/contributing/writing-guides/#5-template-for-a-how-to-guide","title":"5. Template for a How-to Guide","text":"<pre><code># How to [goal in plain language]\n\n## Introduction\n\nBriefly describe what the guide helps achieve, and why.  \nInclude one sentence explaining the broader context (e.g. within Netherlands3D or Unity).\n\n---\n\n## Prerequisites\n\n- [Required layer or object]\n- [Specific environment or component]\n- [Any setup steps completed]\n\n---\n\n## Step 1: [Title of first step]\n\nExplain what this step accomplishes.\n\n```csharp\n// Example code snippet\n```\n\n!!! tip\nHelpful reminder or optional shortcut.\n\n---\n\n## Step 2: [Next step title]\n\n...\n\n---\n\n## Step 3: [Verification or further configuration]\n\nExplain how to confirm it works.\n\n---\n\n## What\u2019s next?\n\nOptional: suggest follow-up tasks or advanced variations.\n\n---\n\n## Performance tips\n\nOptional: share optimizations, caveats, or best practices.\n\n---\n\n## Further Reading\n\n* [Explanation: related concept](../explainers/related-concept.md)\n* [Reference: relevant API](../reference/relevant-api.md)\n</code></pre>"},{"location":"docs/developers/contributing/writing-guides/#6-checklist-for-authors","title":"6. Checklist for Authors","text":"<p>Before submitting your guide:</p> <ul> <li>[ ] The title clearly states a single goal.</li> <li>[ ] Steps are numbered and sequential.</li> <li>[ ] Each step shows an action, explanation, and expected result.</li> <li>[ ] Code compiles and matches current API signatures.</li> <li>[ ] Uses proper Markdown formatting and callouts.</li> <li>[ ] Ends with at least one link to an Explanation and Reference page.</li> </ul>"},{"location":"docs/developers/contributing/writing-guides/#7-examples-to-learn-from","title":"7. Examples to Learn From","text":"<ul> <li>How to color parts of the terrain</li> <li>How to add styling support to layers</li> <li>How to enable functionalities for specific layers</li> </ul>"},{"location":"docs/developers/contributing/writing-guides/#8-summary","title":"8. Summary","text":"<p>How-to Guides are hands-on recipes: short, focused, and reliable. They show how to use the system, not how it\u2019s built. By following this structure, every new guide in Netherlands3D remains clear, repeatable, and consistent with the rest of the Di\u00e1taxis documentation set.</p>"},{"location":"docs/developers/contributing/writing-guides/#9-further-reading","title":"9. Further reading","text":"<ul> <li>Contributing to the documentation</li> </ul>"},{"location":"docs/developers/decisions/","title":"Architectural Decisions","text":"<p>In the Netherlands3D project, we recognize the importance of documenting key architectural decisions to ensure that the rationale behind our choices is clear, traceable, and accessible to all contributors and stakeholders. This section serves as a living document where we track these decisions, both accepted and rejected, to provide a transparent record of our technical direction.</p>"},{"location":"docs/developers/decisions/#why-track-architectural-decisions","title":"Why Track Architectural Decisions?","text":"<p>Architectural decisions often shape the foundation of a project and influence how future features are built. By documenting these decisions:</p> <ul> <li>We ensure clarity and alignment: Everyone working on the project understands why certain paths were chosen over   others.</li> <li>We maintain consistency: Having a record of decisions helps to maintain a coherent and stable architectural vision   as the project evolves.</li> <li>We enable future-proofing: Teams and future developers can reference past decisions to avoid re-evaluating or   re-implementing resolved issues.</li> <li>We encourage informed collaboration: It creates an open dialogue for discussing technical options and ensures   everyone has access to the decision-making process.</li> </ul>"},{"location":"docs/developers/decisions/#what-to-expect","title":"What to Expect","text":"<p>In this section, you will find a record of:</p> <ul> <li>Accepted proposals: Decisions that have been approved and are guiding the current development.</li> <li>Rejected proposals: Ideas that were considered but ultimately not adopted, along with the reasons why.</li> <li>Ongoing discussions: Some entries may reflect decisions that are still under consideration, providing insight into   our ongoing thought process.</li> </ul> <p>Each architectural decision is written in a lightweight, actionable format that includes a summary of the problem, the considered options, the decision taken, and the rationale behind it. We strive to keep these entries concise while capturing the essential technical and business context.</p>"},{"location":"docs/developers/decisions/#language-considerations","title":"Language Considerations","text":"<p>Since the core Netherlands3D team operates primarily in Dutch, many architectural proposals and discussions will initially be documented in Dutch. This allows us to facilitate faster and more in-depth discussions within the team. However, we strive to provide English translations for most of these decisions to ensure that non-Dutch speakers can follow and contribute to the project. Whenever possible, both Dutch and English versions of each decision will be available.</p>"},{"location":"docs/developers/decisions/20241009-styling-of-layers/","title":"2024-10-09 - Laagstijlen / Symbologie","text":"Datum 09-10-2024 Status Geaccepteerd"},{"location":"docs/developers/decisions/20241009-styling-of-layers/#context","title":"Context","text":"<p>Als uitkomst van dit voorstel willen we dat Netherlands3D gebruik maakt van visualisaties waarbij lagen worden gestileerd met behulp van symbologie, gebaseerd op de OGC Cartographic Symbology - Part 1: Core Model &amp; Encodings  (https://docs.ogc.org/DRAFTS/18-067r4.html). De implementatie is een systeem vergelijkbaar met CSS, waarbij een  Symbolizer styling-eigenschappen bevat, en Selectors (beschreven als Expressions) bepalen wanneer en hoe  deze eigenschappen worden toegepast.</p> <p>Hoewel de term \"symbologie\" gebruikelijk is in GIS, noemen we dit systeem \"styling\" om het toegankelijker te maken voor een breder publiek en de parallel met CSS te benadrukken.</p> <p>Scheiding tussen Styling en Visualisatie</p> <p>Het styling-systeem zelf doet niets met de daadwerkelijke visualisatie. Het systeem beschrijft alleen hoe de styling moet zijn, maar het is aan de visualisatiecode die hoort bij een laag om te bepalen of en hoe de styling-eigenschappen worden toegepast. Dit betekent dat het mogelijk is dat bepaalde styling-eigenschappen niet worden toegepast als de visualisatiecode daarvoor geen ondersteuning biedt.</p>"},{"location":"docs/developers/decisions/20241009-styling-of-layers/#besluit","title":"Besluit","text":"<p>We implementeren een flexibel styling-systeem waarin Symbolizers styling-eigenschappen bevatten, en Selectors en Expressions bepalen wanneer deze eigenschappen van toepassing zijn. Dit systeem wordt toegepast op lagen, en de mogelijke waarden binnen een Symbolizer worden bepaald door de aanwezige Symbolizer-extensies.</p> <p>Externe partijen kunnen hun eigen extensies en styling-eigenschap prefixes toevoegen, volgens het patroon uit hoofdstuk 8.1.7 van de OGC-specificatie: <code>vendor.&lt;vendor naam&gt;.&lt;eigenschap naam&gt;</code>. Voor Netherlands3D betekent dit dat we de prefix <code>vendor.netherlands3d.&lt;eigenschap naam&gt;</code> zullen hanteren.</p>"},{"location":"docs/developers/decisions/20241009-styling-of-layers/#rationale","title":"Rationale","text":"<p>Het gebruik van een systeem, vergelijkbaar met CSS, biedt de flexibiliteit en uitbreidbaarheid die nodig is voor het werken met dynamische geodata. Door selectors en expressies te gebruiken, kunnen we styling-eigenschappen toepassen op basis van attribuutwaarden of andere condities. Symbolizer-extensies zorgen ervoor dat nieuwe styling-eigenschappen kunnen worden toegevoegd zonder de kernstructuur te verstoren. Door gebruik te maken van extension methods met default-waarden, waarborgen we een voorspelbare werking van het systeem, zelfs wanneer geen expliciete waarde aanwezig is.</p>"},{"location":"docs/developers/decisions/20241009-styling-of-layers/#codeorganisatie","title":"Codeorganisatie","text":"<p>De implementatie van het systeem wordt initieel ondergebracht als Building Block in de Twin applicatie en zodra de  structuur uitontwikkeld is, verhuist naar een aparte OpenUPM-package. De code voor de verschillende  Symbolizer-extensies wordt georganiseerd in mappen, waarbij iedere extensie een Requirement Class uit de OGC-specificatie volgt. Dit maakt het beheer van verschillende extensies overzichtelijk en zorgt voor een heldere scheiding tussen kernfunctionaliteit en uitbreidingen.</p> <p>Wij passen zelf de styling-eigenschap prefix <code>vendor.netherlands3d.&lt;eigenschap naam&gt;</code> toe voor onze eigen uitbreidingen. Derde partijen kunnen hun eigen extensies via hun eigen packages toevoegen en daarbij hun eigen  styling-eigenschap prefixes introduceren volgens hetzelfde patroon uit hoofdstuk 8.1.7 van de OGC-specificatie.</p>"},{"location":"docs/developers/decisions/20241009-styling-of-layers/#implementatiestrategie","title":"Implementatiestrategie","text":"<p>We voeren de implementatie stapsgewijs uit. Dit houdt in dat we niet alle eigenschappen van de Symbolizer in \u00e9\u00e9n keer toevoegen, maar in kleine iteraties werken. Elke iteratie implementeert \u00e9\u00e9n of meer specifieke eigenschappen van de Symbolizer, afhankelijk van de eisen van een user story. Bijvoorbeeld: wanneer een user story vraagt om een laag een enkele vulkleur te geven, wordt alleen de fill-eigenschap van de Symbolizer-extensie voor vectorfeatures ge\u00efmplementeerd.</p> <p>Hoewel hoofdstuk 17 van de OGC-specificatie extra opties beschrijft zoals het gebruik van het \"alter\" veld, variabelen en het includen van stylesheets, zullen we deze opties expliciet niet implementeren. Ons doel is niet om de volledige specificatie te implementeren, maar om de organisatiestructuur van symbolizers, expressies en styling te adopteren. Dit voorkomt dat we het wiel opnieuw uitvinden, maar zorgt ervoor dat we ons beperken tot een basisstructuur die ons flexibiliteit biedt zonder de complexiteit van volledige implementatie.</p>"},{"location":"docs/developers/decisions/20241009-styling-of-layers/#implementatie","title":"Implementatie","text":"<pre><code>classDiagram\n    namespace Netherlands3D {\n        class Layers\n    }\n    namespace Layers {\n        class LayerData {\n            +LayerStyle styles\n        }\n        class Styles\n    }\n\n    namespace Styles {\n    class LayerStyle {\n        +StylingRule stylingRules\n        +Metadata metadata\n    }\n\n    class Metadata {\n        + string name\n    }\n\n    class StylingRule {\n        +string name\n        +Symbolizer symbolizer\n        +Expression selector\n    }\n\n    class Expression {\n    }\n\n    class Symbolizer {\n        - Dictionary properties\n        ~ void GetProperty(string name)\n        ~ object SetProperty(string name, object value)\n    }\n\n    class CoreSymbolizerExtension {\n        +GetVisibility() bool\n        +SetVisibility(bool visible)\n        +GetOpacity() float\n        +SetOpacity(float opacity)\n    }\n\n    class VectorSymbolizerExtension {\n        +GetFill() Color\n        +SetFill(Color fillColor)\n    }\n    }\n\n    LayerData --&gt; \"0..*\" LayerStyle\n    LayerStyle --&gt; \"0..*\" StylingRule\n    LayerStyle --&gt; \"0..1\" Metadata\n    StylingRule --&gt; \"0..1\" Symbolizer\n    StylingRule --&gt; \"0..1\" Expression\n    CoreSymbolizerExtension .. Symbolizer : extension of\n    VectorSymbolizerExtension .. Symbolizer : extension of\n</code></pre> <p>Let op</p> <p>We wijken in de naamgeving af van de beschrijving in de OGC standaard bij de LayerStyle klasse, in de OGC standaard heeft deze enkel <code>Style</code>, maar om consistent te zijn in de applicatie en ter verduidelijking voegen wij het voorzetsel <code>Layer</code> toe om te benadrukken dat dit een style is behorende bij layers; vergelijkbaar met <code>LayerPropertyData</code></p>"},{"location":"docs/developers/decisions/20241009-styling-of-layers/#opslag-van-stijlen-in-het-projectbestand","title":"Opslag van Stijlen in het Projectbestand","text":"<p>Elke layer in het projectbestand krijgt een nieuw veld genaamd \"styles\" waarin de stylinginformatie wordt opgeslagen. Dit veld verwijst naar een JSON-structuur die hetzelfde formaat is zoals gedefinieerd in hoofdstuk 17 van de OGC Cartographic Symbology - Part 1: Core Model &amp; Encodings OGC-standaard. Hierdoor kunnen we stijlen opnieuw laden en heen en weer converteren tussen het interne representatiemodel en het JSON-bestand. Dit zorgt ervoor dat stijlen behouden blijven wanneer ze eenmaal gedefinieerd zijn.</p> <p>Technische Vereisten voor Serialization</p> <p>Omdat het hele projectbestand wordt geserialized met Newtonsoft's JSON.net, moet de klassestructuur van de symbolizers ook in dit format worden geserialized. Dit waarborgt strict typing en maakt het consistent met de rest  van het project.</p> <p>Voor de Symbolizer zal een aparte JsonConverter geschreven moeten worden die ervoor zorgt dat de waarden in de <code>properties</code> dictionary als losse velden direct in de JSON voor het symbolizer object verschijnen en niet dat een extra veld <code>properties</code> in de JSON terecht komt.</p>"},{"location":"docs/developers/decisions/20241009-styling-of-layers/#expressions-en-selectors","title":"Expressions, en Selectors","text":"<p>Bij het implementeren van expressions en selectors volgen we de structuur zoals beschreven in hoofdstuk 8.1.5 van de OGC Cartographic Symbology - Part 1: Core Model &amp; Encodings. Net als bij de styling-eigenschappen, zullen we de expressie-taal niet in \u00e9\u00e9n keer volledig implementeren, maar stap voor stap, afhankelijk van de vereisten van user stories.</p> <p>Voorbeeld</p> <p>Een voorbeeld hiervan is een user story waarin we een groep features kleuren op basis van een attribuutwaarde. Voor deze implementatie hebben we alleen de volgende onderdelen nodig:</p> <ul> <li>Een vergelijkingsoperator (alleen gelijkheid),</li> <li>Een attribuut-identiteits-expressie (om het attribuut aan te duiden),</li> <li>Een TextLiteral-expressie (om de letterlijke waarde te beschrijven).</li> </ul> <p>Dit iteratieve proces maakt het mogelijk om gericht de functionaliteiten toe te voegen die direct noodzakelijk zijn voor de behoeften van de gebruikers.</p>"},{"location":"docs/developers/decisions/20241009-styling-of-layers/#risicos","title":"Risico's","text":"<p>De OGC Cartographic Symbology-standaard bevindt zich in een draft-stadium, wat betekent dat de specificaties nog kunnen veranderen. We accepteren dat onze implementatie niet volledig overeenkomt met de definitieve specificatie, en houden hier rekening mee in toekomstige aanpassingen.</p>"},{"location":"docs/developers/decisions/20241009-styling-of-layers/#appendix-a-woordenlijst","title":"Appendix A: Woordenlijst","text":"<ul> <li>OGC Cartographic Symbology-standaard: De standaard waarop het styling-systeem is gebaseerd.</li> <li>Layer: Een verzameling van geografische objecten die in een bepaalde stijl worden weergegeven.</li> <li>Styling: Het toekennen van visuele eigenschappen aan geografische objecten.</li> <li>Style: Een verzameling van stylingregels die wordt toegepast op een layer.</li> <li>Styling-eigenschap: Een specifieke visuele eigenschap, zoals kleur of lijnstijl, die wordt toegepast op een   object.</li> <li>Symbolizer: Een object dat styling-eigenschappen bevat voor lagen.</li> <li>Symbologie: Een GIS-term voor het beschrijven van hoe geografische objecten visueel worden weergegeven.</li> <li>Selector: Een conditie die bepaalt wanneer een symbolizer moet worden toegepast.</li> <li>Expression: Een voorwaarde of waarde die bepaalt hoe en wanneer een bepaalde styling-eigenschap wordt toegepast.</li> <li>Symbolizer-extensie: Uitbreidingen die nieuwe styling-eigenschappen toevoegen aan de Symbolizer.</li> <li>Styling-eigenschap prefix: Een voorvoegsel toegevoegd aan eigen styling-eigenschappen om conflicten met   OGC-gedefinieerde eigenschappen te voorkomen, zoals beschreven in hoofdstuk 8.1.7 van de OGC-specificatie.</li> </ul>"},{"location":"docs/developers/decisions/20241009-styling-of-layers/#appendix-b-voorbeeld-flow-voor-het-wijzigen-van-kleur","title":"Appendix B: Voorbeeld flow voor het wijzigen van kleur","text":"<p>Wanneer een gebruiker de kleur van een laag aanpast in de UI, doorloopt de applicatie de volgende stappen:</p> <pre><code>graph TD\n    A[Gebruiker past kleur aan in UI] --&gt; B[UI haalt huidige laag op]\n    B --&gt; C[UI zoekt standaard stylingregel op en haalt Symbology object op]\n    C --&gt; D[UI roept SetFillColor aan op Symbology-object]\n    D --&gt; E[Symbology slaat nieuwe kleur op in private dictionary]\n    subgraph Update van visualisatie\n        E --&gt; F[Laag triggert update naar visualisatieklasse]\n        F --&gt; G[Visualisatieklasse haalt Symbology op]\n        G --&gt; H[Visualisatieklasse leest FillColor uit]\n        H --&gt; I[Visualisatieklasse past nieuwe kleur toe]\n    end\n    I --&gt; J[Visualisatie wordt bijgewerkt]</code></pre> <ol> <li>Gebruiker past kleur aan in UI: De gebruiker kiest een nieuwe kleur voor een laag.</li> <li>UI haalt huidige laag en standaard stylingregel op: De UI haalt de geselecteerde laag en de standaard    stylingregel op, inclusief het bijbehorende Symbology-object.</li> <li>Symbology-object bijwerken: De UI roept de <code>SetFillColor</code> method aan op het Symbology-object, dat de nieuwe kleur    opslaat in een private dictionary.</li> <li>Update van visualisatie: De laag triggert een update naar de visualisatieklasse, die vervolgens het    Symbology-object ophaalt, de nieuwe kleur uitleest, en deze toepast op de visualisatie.</li> <li>Visualisatie wordt bijgewerkt: De visualisatie wordt automatisch bijgewerkt om de nieuwe stijl van de laag te    reflecteren.</li> </ol> <p>Het updaten van de visualisatie is een herbruikbaar blok dat niet alleen in deze flow kan worden ingezet, maar ook bij het openen van een project. Door de scheiding tussen de symbologie data en de visualisatie kan, vergelijkbaar met de scheiding tussen LayerData en visualisatie, styling in het project uniform worden opgeslagen.</p>"},{"location":"docs/developers/decisions/20260204-async-await-standardisation/","title":"2026-02-04 - Gebruik van Async/Await en Unity Awaitables","text":"Datum 04-02-2026 Status Geaccepteerd"},{"location":"docs/developers/decisions/20260204-async-await-standardisation/#context","title":"Context","text":"<p>Binnen het project wordt steeds meer gebruikgemaakt van asynchrone functionaliteit. Tot nu toe werd dit op verschillende manieren ge\u00efmplementeerd  (Coroutines, Promises, Unity Awaitables), wat leidt tot variatie en verminderde uniformiteit in de codebase. Om de kwaliteit, voorspelbaarheid en  onderhoudbaarheid van de code te vergroten, stelt het team een eenduidige werkwijze vast voor nieuwe async\u2011implementaties.</p>"},{"location":"docs/developers/decisions/20260204-async-await-standardisation/#besluit","title":"Besluit","text":"<p>Vanaf heden gelden de volgende afspraken voor nieuwe, door het team geschreven code:</p> <ol> <li> <p>Async/await, tenzij    Asynchrone functionaliteit wordt standaard geschreven met <code>async/await</code>. Unity Coroutines worden niet meer gebruikt voor nieuwe code.</p> </li> <li> <p>Awaitable, tenzij    Bij Unity\u2011specifieke async operaties wordt gebruikgemaakt van Unity Awaitables.</p> </li> <li> <p>AwaitableCompletionSource, tenzij    Wanneer een async taak informatie moet teruggeven over succes of fout, wordt AwaitableCompletionSource gebruikt als standaard mechanisme.</p> </li> <li> <p>Promises alleen bij expliciete motivatie    Promises worden niet toegepast, tenzij er een duidelijke meerwaarde is die binnen het team wordt toegelicht. Alleen na akkoord mag een    uitzondering worden gemaakt.</p> </li> </ol>"},{"location":"docs/developers/decisions/20260204-async-await-standardisation/#gevolgen","title":"Gevolgen","text":"<ul> <li>Nieuwe eigen code volgt deze afspraken.  </li> <li>Bestaande code die hiervan afwijkt wordt niet direct aangepast, maar het recht trekken wordt gepland en opgepakt wanneer passend binnen   regulier werk.  </li> <li>De codebase zal door deze standaardisering geleidelijk uniformer en beter onderhoudbaar worden.  </li> <li>Minder variatie in async\u2011patronen resulteert in eenvoudiger onderhoud, betere leesbaarheid en snellere onboarding voor nieuwe teamleden.</li> </ul>"},{"location":"docs/developers/features/embedding/","title":"Embedding Netherlands3D on Your Website","text":"<p>You can easily embed Netherlands3D on your own website using an iframe. This allows you to showcase the 3D  representation of the Netherlands directly within your web pages. You can also customize the location and features  displayed using a query string.</p>"},{"location":"docs/developers/features/embedding/#using-an-iframe","title":"Using an Iframe","text":"<p>To embed Netherlands3D with Rijksdriehoekformaat (EPSG:28992) coordinates, use the following HTML code snippet. Replace the <code>src</code> attribute value with the URL of the Netherlands3D digital twin you'd like to embed:</p> <pre><code>&lt;iframe\n        src=\"https://netherlands3d.eu/twin/?origin=161088,503050,300&amp;features=terrain,buildings,trees,sun\"\n        width=\"640\"\n        height=\"480\"\n        frameborder=\"0\"\n&gt;&lt;/iframe&gt;\n</code></pre> <ul> <li> <p>src: Set this attribute to the URL of the Netherlands3D digital twin. You can customize the location and features   using the query string.</p> </li> <li> <p>width and height: Adjust these attributes to define the dimensions of the iframe on your webpage. Make sure the   width   fits your design, and the height provides an optimal viewing experience.</p> </li> <li> <p>frameborder: Set this attribute to \"0\" to remove the iframe border.</p> </li> </ul>"},{"location":"docs/developers/features/embedding/#configuring-location-and-features","title":"Configuring Location and Features","text":"<p>You can customize the location and features displayed in your embedded Netherlands3D using a query string. In the query string, the origin parameter should follow the format <code>origin=X,Y,elevation</code>, where <code>X</code> and <code>Y</code> is the position of the camera in Rijksdriehoekformaat (EPSG:28992) coordinates and elevation is the desired viewing elevation.</p> <p>Here's an example URL with a query string for your reference:</p> <pre><code>https://netherlands3d.eu/twin/?origin=161088,503050,300&amp;features=terrain,buildings,trees,sun\n</code></pre> <ul> <li> <p>origin: This parameter sets the initial view location in the   Rijksdriehoekformaat (EPSG:28992) coordinate system. It follows the format   <code>origin=X,Y,elevation</code>, where elevation is a value between <code>0</code> and <code>1400</code>.</p> </li> <li> <p>features: Use this parameter to specify which features to display in the digital twin. You can include multiple   features, separated by commas.</p> </li> </ul>"},{"location":"docs/developers/features/embedding/#using-the-setup-wizard","title":"Using the Setup Wizard","text":"<p>For an even easier way to generate the query string with the desired configuration, you can visit the Netherlands3D Setup Wizard (https://netherlands3d.eu/twin/). This interactive tool allows you to select the location, features, and other options, and it generates the corresponding query string for your iframe.</p> <p>Once you have the query string, insert it into the <code>src</code> attribute of your iframe code, and you'll have a fully customized embedded Netherlands3D digital twin on your website.</p>"},{"location":"docs/developers/features/floating-origin/","title":"Working with large distances (Floating Origin)","text":"<p>The Floating Origin system allows you to navigate the entire world without encountering floating-point precision errors. Instead of letting the camera roam infinitely far from the unity origin (0, 0, 0), it keeps the camera near the center  by shifting the entire world when needed:</p> <ul> <li> <p>When the camera moves more than 5 kilometers away from (0, 0, 0), the system shifts all GameObjects so that the camera   is back near the origin.</p> </li> <li> <p>This shift is invisible to the user\u2014everything appears stable, while in reality, the whole scene has been    repositioned.</p> </li> <li> <p>Each object stores its real-world coordinates separately, and the Floating Origin itself also tracks its own    real-world position, enabling accurate placement at all times.</p> </li> </ul> <p>Analogy: Imagine sliding the world underneath you in 5 km steps as you move, instead of moving the camera through the   world.</p>"},{"location":"docs/developers/features/floating-origin/#overview-of-the-floating-origin-system","title":"Overview of the Floating Origin System","text":"<p>Before the deep-dive into the components of the Floating Origin system, a basic understanding of the concepts in this  system is required: </p>"},{"location":"docs/developers/features/floating-origin/#real-world-coordinates-and-unity-positions","title":"Real world coordinates and Unity positions","text":"<p>In Unity, the transform component is responsible for tracking the position relative to Unity's (0,0,0) origin point,  when working with large worlds -such as our real-world- this system no longer works due to floating point precision  errors. To solve this, a second mechanic for tracking positions is introduced using real world coordinates in  the WGS84 lat/long ECEF coordinate system.</p> <p>As the distances expressed by real world coordinates are greater than Unity's floating point based transforms, it is  needed to track the real world coordinate of the (0,0,0) origin -called the Floating Origin- and the coordinates  of real world objects.</p> <p>When the camera moves thus far away from the Floating Origin that floating point issues may occur, the origin will  change its real-world coordinate to be nearer to the camera's real-world coordinate and shift the Unity position of all real-world objects to match the new real-world coordinate of Unity's (0,0,0) origin.</p>"},{"location":"docs/developers/features/floating-origin/#floating-origin","title":"(Floating) Origin","text":"<p>The Origin represents the real world coordinates of Unity's (0,0,0) origin and is responsible for tracking the distance  of the Camera from Unity's (0,0,0) origin. If the Camera moves too far away, rendering and calculation anomalies can  happen due to floating point precision issues and all real world objects -including the origin's own real-world  coordinates- need to be shifted so that all elements are back into a safe distance in Unity's coordinate system.</p>"},{"location":"docs/developers/features/floating-origin/#shifting","title":"Shifting","text":"<p>Shifting is the term for when real world objects need to have their Unity position adjusted to get closer to the  Floating Origin. Because the origin's Unity position never changes -it is always at 0,0,0- but its real-world coordinate can change, we need to respond to that by moving real-world objects' Unity position. As soon as this happened, all Game  Objects should be within a safe distance from 0,0,0 again.</p>"},{"location":"docs/developers/features/floating-origin/#real-world-objects","title":"Real-world objects","text":"<p>Real-world objects -sometimes referred to as spatial objects- are game objects whose location is tied to the real-world and have a location in the real world. An example may be a windmill, where a UI element is an example of something that  is not.</p> <p>Real-world objects have a World Transform component that tracks the real-world position and orientation of the object  and when a shift is emitted, they will reposition themselves or its parts.</p>"},{"location":"docs/developers/features/floating-origin/#world-transform","title":"World Transform","text":"<p>The World Transform tracks the real-world position and orientation for a real-world object. The World Transform also reacts to the Origin calling for a shift, but delegates the actual work to a World Transform Shifter component. This allows for objects to respond to shifts differently.</p>"},{"location":"docs/developers/features/floating-origin/#world-transform-shifter","title":"World Transform Shifter","text":"<p>The World Transform Shifter is the component that handles the shifting of a Game Object. Usually you do not need to  provide a specific World Transform Shifter with a World Transform, in that case the default  GameObjectWorldTransformShifter is used. </p>"},{"location":"docs/developers/features/floating-origin/#origin","title":"Origin","text":"<p>In the Floating Origin System, the Origin is an important concept referring to the focal point within the Unity game world. It is crucial for large scale projects where precision becomes a challenge.</p> <p>The Origin is typically associated with its own separate GameObject. This GameObject serves as an indicator or marker of the origin point, and doesn't have any visual representation in the game environment. Its primary role is to maintain the game world's central point and handle shifts in that point to ensure accuracy and consistency in objects' locations in the world.</p> <p>To use the Origin, create an empty GameObject in your scene. This empty GameObject often doesn't need any other components besides Origin. Then, attach the Origin script to this GameObject. Now, the Origin GameObject will continually monitor its distance from the camera (or a specified mainShifter object) while playing.</p>"},{"location":"docs/developers/features/floating-origin/#performance-optimizations-in-origin","title":"Performance Optimizations in Origin","text":"<p>Understanding and managing performance is key in any system, and the Floating Origin System includes several performance optimizations to ensure efficient operation.</p>"},{"location":"docs/developers/features/floating-origin/#using-sqrmagnitude-instead-of-magnitude","title":"Using sqrMagnitude Instead of Magnitude","text":"<p>The process of calculating distance often involves the operation of square roots, which introduce computational complexity. In the Floating Origin System, we use Unity's built-in sqrMagnitude method instead of magnitude for distance calculations.</p> <p>The sqrMagnitude method calculates the square of the magnitude of a distance vector, which omits the need for a square root operation. Since the Origin uses a squared threshold for determining shifting necessity, this optimization aligns perfectly. Simply put, both the mainShifter's distance and the threshold are squared values, so no square root operation is needed, resulting in improved performance without comprising correct operation.</p>"},{"location":"docs/developers/features/floating-origin/#using-a-coroutine-to-wait-until-the-end-of-frame","title":"Using a Coroutine to Wait Until the End of Frame","text":"<p>The Floating Origin System uses Unity's Coroutine feature to postpone the shifting evaluation to the end of each frame. The shifting operation checks at the end of the frame if it needs to reposition the Origin based on the final position of the mainShifter.</p> <p>This optimization minimizes unnecessary Origin shifting, as multiple changes to the mainShifter position within a single frame will only trigger the shifting operation once at the end of the frame. This approach effectively reduces computational load by minimizing the frequency of costly shifting operations.</p>"},{"location":"docs/developers/features/floating-origin/#the-origin-triggers-the-shifts","title":"The Origin triggers the shifts","text":"<p>The Origin in the Floating Origin System demonstrates an example of encapsulation, a fundamental principle of object-oriented programming. Instead of distributing responsibilities across multiple components (like making the camera responsible for calculating distances and triggering shifts), the Floating Origin System centralizes these responsibilities within the Origin.</p> <p>Encapsulating Responsibilities</p> <p>The Origin is responsible for continually monitoring its distance from the camera (or another defined mainShifter object). Using a pre-determined threshold, the Origin decides when the shift operation needs to occur. Once that threshold is surpassed, the Origin triggers a shift operation to reestablish itself closer to the camera or mainShifter. This design decision encapsulates the behavior within the Origin, making it a standalone component that can independently determine and respond to shifts.</p> <p>Performance and Design Improvements</p> <p>The encapsulation model presents several advantages:</p> <ul> <li> <p>Performance: By monitoring the mainShifter's distance at the end of each frame and shifting only when necessary,   the Origin can optimize performance and reduce unnecessary shifts, irrespective of how many changes occur to the   mainShifter during the frame.</p> </li> <li> <p>Design Simplicity: Having the Origin act as the central point of control simplifies task delegation amongst   components and makes the overall system easier to understand.</p> </li> <li> <p>Encapsulation: By keeping related functions within the Origin, the design favors encapsulation, ensuring a clean   system where components' responsibilities are clearly defined and do not blend.</p> </li> </ul>"},{"location":"docs/developers/features/floating-origin/#worldtransform","title":"WorldTransform","text":"<p>An analogy: transforms and rigidbodies</p> <p>To illustrate how the WorldTransform and their Shifters work, you can compare them to the way Transform and RigidBodies work in Unity. The Transform holds the position, rotation and scale and can be manipulated; but the actual physics  interaction -movement forced by external factors- is accomplished through a RigidBody component, or even a  CharacterController.</p> <p>In Unity, you have one transform and one type of RigidBody/Character Controller; and with the WorldTransform this works similarly: the WorldTransform works like a Transform and records the position of the real-world object, where a  WorldTransformShifter functions like a RigidBody and exerts force on the WorldTransform when a Shift happens. </p> <p>The WorldTransform is effectively the real-world equivalent of an object's location within the Unity game world. When the Origin shifts, the WorldTransform is adjusted correspondingly. Meanwhile, Unity's native Transform class remains untouched. This results in two interconnected, but separate, coordinate systems.</p> <p>Not all objects will need to handle a shift in the same way. The default is to shift the GameObject itself, but some objects are containers whose children need to shift and not themselves -example: tile handlers- or where transformation matrices are used instead of transform components -example: instanced objects-. By delegating this responsibility to a World Transform Shifter all real-world objects will track their coordinates in the same way but have different ways to react to shift events.</p>"},{"location":"docs/developers/features/floating-origin/#worldtransformshifter","title":"WorldTransformShifter","text":"<p>The WorldTransformShifter is meant to manage the effects of moving the Origin on GameObjects. Custom behaviors for  different types of GameObjects when the Origin shifts can be defined by implementing the method ShiftTo in derived  classes of WorldTransformShifter.</p> <p>When it is not the GameObject itself whose position needs to change but a child or something not directly linked to the  transform position, then you need to use one of the other strategies. See below for more information.</p> <p>Tip</p> <p>The WorldTransform and its Shifters is an implementation of the Strategy design pattern.</p>"},{"location":"docs/developers/features/floating-origin/#specialized-shifters","title":"Specialized Shifters","text":"<p>Specialized Shifters are used to manage Origin shifts for unique types of GameObjects not part of the Unity base package. These could be packages like Netherlands3D 3DTiles that have their unique behaviors. An example of this is ThreeDTilesWorldTransformShifter. This sub-class handles shifts for child GameObjects associated with the Content component. When an Origin shift happens, it iterates over all Content components and adjusts the positions of all their children.</p>"},{"location":"docs/developers/features/floating-origin/#usage","title":"Usage","text":"<p>To use the Floating Origin System within your Unity projects:</p> <ol> <li>Attach the Origin component to a GameObject that will act as the world origin.</li> <li>For objects that should maintain real-world positions, attach the WorldTransform component.</li> <li>For specialized objects, for example, objects from the Netherlands3D 3DTiles package, attach a specialized    WorldTransformShifter, like ThreeDTilesWorldTransformShifter.</li> </ol>"},{"location":"docs/developers/features/geojson/","title":"GeoJSON Support","text":"<p>Netherlands3D enables users to import and work with GeoJSON data seamlessly. Below is a breakdown of how GeoJSON files are supported, including file handling, parsing, coordinate transformation, and more.</p>"},{"location":"docs/developers/features/geojson/#importing","title":"Importing","text":"<p>Netherlands3D supports <code>.json</code> and <code>.geojson</code> file extensions by default. For custom file types, you can extend support by modifying:</p> <ul> <li>FileOpen script: Enables selection of additional file types.</li> <li>FileTypeAdapter: Handles the processing of new file types.</li> </ul> <p>GeoJSON files are uploaded and embedded as assets within the open NL3D project. When opened from a URL, pointing to GeoJSON files ( e.g., https://raw.githubusercontent.com/blackmad/neighborhoods/refs/heads/master/utrecht.geojson), these are added as remote assets, ensuring they reload every time a project is opened.</p>"},{"location":"docs/developers/features/geojson/#parsing-and-performance","title":"Parsing and Performance","text":"<p>To prevent application freezes when importing large files, GeoJSON parsing is spread across multiple frames. The default parsing time per frame is 0.01 seconds, but this value can be adjusted by modifying the <code>maxParseDuration</code> variable in <code>GeoJSONLayer.cs</code>.</p>"},{"location":"docs/developers/features/geojson/#supported-feature-types","title":"Supported Feature Types","text":"<p>Netherlands3D supports the following GeoJSON feature types:</p> <ul> <li>Polygon</li> <li>MultiPolygon</li> <li>LineString</li> <li>MultiLineString</li> <li>Point</li> <li>MultiPoint</li> </ul> <p>Features of the same type are combined into a single layer in the application:</p> <ul> <li>Polygon and MultiPolygon \u2192 One layer.</li> <li>LineString and MultiLineString \u2192 One layer.</li> <li>Point and MultiPoint \u2192 One layer.</li> </ul>"},{"location":"docs/developers/features/geojson/#coordinate-transformation","title":"Coordinate Transformation","text":"<p>GeoJSON coordinates are converted to Unity coordinates using the  <code>eu.netherlands3d.coordinates</code> package. The transformation leverages the parsed CRS (Coordinate Reference System).</p>"},{"location":"docs/developers/features/geojson/#crs-support","title":"CRS Support","text":"<ul> <li>Netherlands3D supports the \"Named CRS\" feature described in the original pre-2018 GeoJSON   specification (see details here), enabling backwards compatibility   for older GeoJSON files that define their own CRS.</li> <li>Support for the \"Linked CRS\" variant is not provided.</li> <li>Custom CRS definitions are not supported in the current GeoJSON specification, but legacy files using \"Named CRS\" are   still supported.</li> </ul>"},{"location":"docs/developers/features/geojson/#visualization-and-appearance","title":"Visualization and Appearance","text":"<p>A material can be assigned to a GeoJSONLayer to control the visualization's appearance. This allows for customization of how imported GeoJSON features are displayed in the 3D environment.</p>"},{"location":"docs/developers/features/geojson/#error-handling","title":"Error Handling","text":"<p>Netherlands3D includes error handling for GeoJSON imports. If parsing fails, an event is invoked to display error messages on-screen, ensuring users are informed of any issues during the import process.</p>"},{"location":"docs/developers/features/geojson/#troubleshooting","title":"Troubleshooting","text":"<p>If GeoJSON data does not display correctly in Netherlands3D, follow these steps to verify data correctness before debugging the code:</p> <ol> <li>Open the file in QGIS: Check if QGIS can successfully display the data. If QGIS cannot load the file, the data    may be incorrect.</li> <li>Validate the GeoJSON structure and geometry: Use    the GeoJSON Validator to confirm the file\u2019s structure and geometry are    valid.</li> <li>Test the file in GeoJSON.io: Try loading the file in GeoJSON.io to verify if the data    renders correctly.</li> </ol> <p>These steps help ensure the GeoJSON file is correct and usable, minimizing unnecessary debugging in the code.</p>"},{"location":"docs/developers/guides/adding-styling-support-to-layers/","title":"Add styling support to layers","text":""},{"location":"docs/developers/guides/adding-styling-support-to-layers/#goal","title":"Goal","text":"<p>Show how to extend <code>LayerGameObject</code> to surface its visual elements as <code>LayerFeature</code> instances, and how to build a companion \u201cStyler\u201d class that applies and persists style rules to your layer\u2019s features.</p>"},{"location":"docs/developers/guides/adding-styling-support-to-layers/#prerequisites","title":"Prerequisites","text":"<ul> <li>You already have a subclass of <code>LayerGameObject</code> for your custom layer type (e.g. <code>MyCustomLayerGameObject</code>).</li> <li>You understand the basics of the Netherlands3D Expression &amp; Styling system (see \u201cHow to color parts of the terrain\u201d   guide).</li> </ul>"},{"location":"docs/developers/guides/adding-styling-support-to-layers/#step-1-expose-your-features","title":"Step 1: Expose your features","text":"<p>In your <code>LayerGameObject</code> subclass\u2019s <code>Awake()</code>, create one <code>LayerFeature</code> per visual element (e.g. per material,  per mesh, per component). This lets the styling engine treat them as independent style targets.</p> <p>Example</p> <p>In this example is shown how each of the materials is converted into a LayerFeature since that is for a mesh layer  often that which distinguishes a feature - or type of feature. This can also be a GameObject -as happens for the  .OBJ import- or actual GeoJSON.net Feature objects.</p> <pre><code>// MyCustomLayerGameObject.cs\nprotected override void Awake()\n{\n    base.Awake();\n\n    for (int i = 0; i &lt; layer.DefaultMaterialList.Count; i++)\n    {\n        // duplicate material so color changes don\u2019t bleed into the original\n        var mat = new Material(layer.DefaultMaterialList[i]);\n        layer.DefaultMaterialList[i] = mat;\n\n        var feature = CreateFeature(mat); // Create the feature and ..\n        LayerFeatures.Add(mat, feature); // .. register it\n    }\n}\n</code></pre> <p>The styling system only sees what you expose as <code>LayerFeatures</code>. By calling <code>CreateFeature(geometry)</code>, you get a  <code>LayerFeature</code> with a hook to <code>AddAttributesToLayerFeature</code> (next step).</p>"},{"location":"docs/developers/guides/adding-styling-support-to-layers/#step-2-annotate-each-feature-with-identifying-attributes","title":"Step 2: Annotate each feature with identifying attributes","text":"<p>Override <code>AddAttributesToLayerFeature</code> to record everything the Styler needs\u2014e.g. material index, material name, any semantic tags.</p> <p>Example</p> <pre><code>// MyCustomLayerGameObject.cs\nprotected override LayerFeature AddAttributesToLayerFeature(LayerFeature feature)\n{\n    // guard that the geometry is a material\n    if (feature.Geometry is not Material mat) return feature;\n\n    // perform a lookup of the material index\n    int idx = mesh.DefaultMaterialList.IndexOf(mat);\n\n    feature.Attributes.Add( \n        CartesianTileLayerStyler.MaterialIndexIdentifier, // key for the attribute, here shown as a const \n        idx.ToString() // record the material index as an identifier for this feature\n    );\n    feature.Attributes.Add(\n        CartesianTileLayerStyler.MaterialNameIdentifier, // key for the attribute, here shown as a const\n        mat.name // record the material name as a name for this feature\n    );\n\n    return feature;\n}\n</code></pre> <p>Expressions work by matching on feature attributes. This step encodes the minimal context your Styler will need. Please note that LayerFeatures can also be used for other purposes, such as showing information in the information panels, thus more attributes may be needed.</p> <p>Tip</p> <p>If you add custom attributes on top of the source data -such as GeoJSON features- it is recommended to prefix these to prevent naming collisions. The prefix for custom attributes is generally <code>data-</code>, by default the styling system will also include <code>nl3d_layer_id</code> and <code>nl3d_layer_name</code>.</p>"},{"location":"docs/developers/guides/adding-styling-support-to-layers/#step-3-implement-applystyling-to-invoke-your-styler","title":"Step 3: Implement <code>ApplyStyling</code> to invoke your Styler","text":"<p>Override <code>ApplyStyling</code> and, for each feature, request the resolved <code>Symbolizer</code> using the <code>GetStyling()</code> method and  hand it off to your custom Styler class.</p> <p>Example</p> <pre><code>// MyCustomLayerGameObject.cs\npublic override void ApplyStyling()\n{\n    foreach (var (_, feature) in LayerFeatures)\n    {\n        var styling = GetStyling(feature);\n        MyCustomLayerStyler.Apply(layer, styling, feature);\n    }\n\n    base.ApplyStyling();\n}\n</code></pre> <p>Calling <code>base.ApplyStyling()</code> at the end ensures events fire for UI panels, property refreshes, etc.</p>"},{"location":"docs/developers/guides/adding-styling-support-to-layers/#step-4-build-your-styler-helper","title":"Step 4: Build your \u201cStyler\u201d helper","text":"<p>Encapsulate all expression-creation and object-manipulation logic in a static helper class (e.g. <code>MyCustomLayerStyler</code>). This keeps your layer class clean and makes styling behavior discoverable.</p>"},{"location":"docs/developers/guides/adding-styling-support-to-layers/#step-4a-register-and-retrieve-styling-rules","title":"Step 4a: Register and Retrieve Styling Rules","text":"<p>Before you can apply visuals, your Styler must expose methods to register new style rules and retrieve saved styles for UI integration.</p> <ul> <li> <p>Registering: create or update a <code>StylingRule</code> in <code>LayerData.DefaultStyle.StylingRules</code>. For example:   <pre><code>MyCustomLayerStyler.SetColor(layerGO, feature, Color.red);\n</code></pre>   Internally, this creates an expression like <code>Get(\"data-materialindex\") == \"2\"</code> and sets the rule\u2019s FillColor.</p> </li> <li> <p>Retrieving: read back any existing override or fall back to the default material color:   <pre><code>Color? current = MyCustomLayerStyler.GetColor(layerGO, feature);\n</code></pre></p> </li> </ul> <p>This separation ensures that style registration and UI display logic live in your Styler class, cleanly apart from rendering.</p>"},{"location":"docs/developers/guides/adding-styling-support-to-layers/#step-4b-applying-styling-rules","title":"Step 4b: Applying styling rules","text":"<p>To update any visuals, the Apply method must take the resolved <code>Symbolizer</code> \u2014 which encapsulates all style  properties for a feature\u2014and translate those into concrete modifications on your layer\u2019s objects. </p> <p>This typically involves:</p> <ul> <li>Retrieving style attributes (e.g. fill color, opacity, line width) from the <code>Symbolizer</code>.</li> <li>Determining which visual element to target (by material index, component reference, or other attribute).</li> <li>Applying those properties directly to the Unity object (e.g. changing <code>Material.color</code>, adjusting mesh renderer    settings).</li> </ul> <p>By centralizing this logic in <code>Apply</code>, you ensure that all style rules are consistently enforced whenever  <code>ApplyStyling()</code> is called.</p> <pre><code>// MyCustomLayerStyler.cs\npublic static class MyCustomLayerStyler\n{\n    // Declare keys for custom attributes to keep track\n    public const string MaterialIndexIdentifier = \"data-materialindex\";\n\n    // Applies the resolved style to the Unity objects\n    public static void Apply(BinaryMeshLayer meshLayer, Symbolizer styling, LayerFeature feature) \n    {\n        // Grab the fill color from the symbolizer\n        Color? color = styling.GetFillColor();\n        if (!color.HasValue) return;\n\n        // Attempt to get the material index from the layer feature' attributes\n        if (!int.TryParse(layerFeature.Attributes[MaterialIndexIdentifier], out var materialIndex)) return;\n\n        // Apply the grabbed color to the given material\n        layer.DefaultMaterialList[materialIndex].color = color.Value;\n    }\n}\n</code></pre>"},{"location":"docs/developers/guides/adding-styling-support-to-layers/#verification","title":"Verification","text":"<ol> <li>Enter Play Mode and open your custom layer\u2019s property panel.</li> <li>Define a new style rule (e.g. \u201cmaterial == 2 \u2192 color = red\u201d).</li> <li>Observe that only the intended feature(s) change color.</li> <li>Save and reload the project \u2014 verify your rule is still applied.</li> </ol>"},{"location":"docs/developers/guides/adding-styling-support-to-layers/#whats-next","title":"What\u2019s next?","text":"<ul> <li>Add support for line-width, opacity or other symbolizer properties.</li> <li>Expose a color-picker or style-preset dropdown in your layer\u2019s UI.</li> <li>Document your Styler API so other developers can discover available expressions.</li> </ul>"},{"location":"docs/developers/guides/adding-styling-support-to-layers/#further-reading","title":"Further Reading","text":"<ul> <li>Explanation: Layer styling - for more in-depth information how the styling system works.</li> </ul>"},{"location":"docs/developers/guides/asset-bundles/","title":"Using Asset Bundles to add Objects to the Object Library","text":""},{"location":"docs/developers/guides/asset-bundles/#introduction","title":"Introduction","text":"<p>This is an experimental feature</p> <p>This feature is in an experimental stage and the guide below is subject to change. Use at your own peril.</p> <p>Asset Bundles are an excellent way to extend the functionality of Netherlands3D by enabling developers to include advanced or prebuilt assets, such as textured FBX files, that may not be feasible to load during the initial application startup.</p> <p>By utilizing Asset Bundles, you can significantly reduce the initial loading time of your application while providing end users with access to complex assets on demand. This guide will walk you through how to build an Asset Bundle, load it into your Netherlands3D project, and make the included assets available in the Object Library for your twin.</p>"},{"location":"docs/developers/guides/asset-bundles/#prerequisites","title":"Prerequisites","text":"<p>This feature is only available when using the Netherlands3D \"Twin\" project as  the basis for your digital twin viewer. The instructions in this guide assume that you are following the same directory  structure and conventions as the \"Twin\" project. Ensure that your project setup aligns with these assumptions to avoid  integration issues.</p>"},{"location":"docs/developers/guides/asset-bundles/#step-1-creating-a-layer-prefab","title":"Step 1: Creating a Layer Prefab","text":"<p>Before building an Asset Bundle, you need to create a prefab that can be registered as a Layer prefab. This prefab serves as the entry point for your assets and will automatically be made available in the Object Library.</p> <p>This can be accomplished by following our guide on  adding a simple type of layer. Do remember  the name of the asset file, as we will be using that in the last step.</p>"},{"location":"docs/developers/guides/asset-bundles/#step-2-build-an-asset-bundle","title":"Step 2: Build an Asset Bundle","text":"<p>To create an Asset Bundle, follow these steps:</p> <ol> <li> <p>Organize your assets, including the Layer Prefab:</p> <ul> <li>Place all the assets you wish to include in your Asset Bundle into the folder named <code>AssetBundleAssets</code> in the   <code>Assets/_Functionalities/AssetBundles</code> folder within your Unity project.</li> </ul> </li> <li> <p>Assign assets to the Asset Bundle:</p> <ul> <li>Select each asset you wish to include and assign it to an Asset Bundle. This can be done in the Inspector   window, under the AssetBundle dropdown menu. For more information, refer to   the Unity documentation.</li> </ul> </li> <li> <p>Build the Asset Bundle:</p> <ul> <li>Navigate to the Unity menu bar, select <code>Assets</code>, and then click <code>Build AssetBundles</code>.</li> <li>Unity will compile your assets into a single Asset Bundle and place it in the <code>StreamingAssets</code> folder of your   project.</li> </ul> </li> </ol> <p>Tip</p> <p>If you make any changes to a prefab or asset included in an Asset Bundle, you must rebuild the Asset Bundle by repeating the steps above.</p>"},{"location":"docs/developers/guides/asset-bundles/#notes","title":"Notes:","text":"<ul> <li> <p>Ensure that all assets included in the Asset Bundle are properly configured and optimized to avoid runtime issues.</p> </li> <li> <p>Assigning assets to an Asset Bundle is a critical step for ensuring they are included in the build.</p> </li> <li> <p>Keep your memory footprint as low as possible, and then even lower. WebGL applications are bound to a maximum of 2GBs    of RAM by the browser.</p> </li> </ul>"},{"location":"docs/developers/guides/asset-bundles/#step-3-registering-your-asset-bundle-with-the-object-library","title":"Step 3. Registering your Asset Bundle with the Object Library","text":"<p>Once an asset bundle is available, you need to ensure the viewer know about it and registers the prefab -from step 1- as an object in the Object Library. You can do this by creating a game object responsible for loading the Object from the Asset bundle:</p> <ol> <li>Create a new GameObject as a child of the <code>Functionalities</code> GameObject in the Hierarchy</li> <li>Attach the <code>AssetBundleLoader</code> MonoBehaviour</li> <li>Configure the Loading Screen Prefab and Canvas -recommended is to use the <code>AssetBundleLoader</code> prefab for the loader,     and the <code>InterfaceUtilities</code> as the canvas.</li> <li>Assign the name of your asset bundle to the <code>Bundle Name</code> field - this is the name you used in Step 2 when tagging      assets.</li> <li>Assign the name of your Layer GameObject prefab's asset file -from Step 1- to the <code>Prefab Name</code> field, including the     <code>.prefab</code> extension</li> </ol> <p>That's it! When you load your application, you should find your new object in the Object Library.</p>"},{"location":"docs/developers/guides/asset-bundles/#common-issues-and-solutions","title":"Common Issues and Solutions","text":"<p>Below are some common issues developers encounter when using Asset Bundles, along with their solutions:</p> <ol> <li> <p>Issue: Asset Bundle fails to load.</p> </li> <li> <p>Solution: Check that the Asset Bundle file is placed in the correct location and that the file path in your script       is accurate.</p> </li> <li> <p>Issue: Prefab is not found in the Asset Bundle.</p> </li> <li> <p>Solution: Ensure that the prefab\u2019s name matches the name used in the AssetBundleLoader prefab.</p> </li> <li> <p>Issue: Changes to prefabs are not reflected.</p> </li> <li> <p>Solution: Rebuild the Asset Bundle after making any changes to the included prefabs or assets.</p> </li> <li> <p>Issue: Some assets are not visible or missing</p> </li> <li> <p>Solution: Reimport the assets in the asset bundle folder, check if their Asset Bundle field is properly set and       rebuild the asset bundle.</p> </li> <li> <p>Issue: The application crashes upon loading with a popup dialog.</p> </li> <li> <p>Solution: make your assets smaller, your asset bundle pushes the memory usage of the application beyond 2GB of RAM      and WebGL applications crash when that happens.</p> </li> </ol>"},{"location":"docs/developers/guides/dealing-with-cors-issues/","title":"Dealing with CORS issues during development","text":"<p>When using external web services (e.g., WFS, WMS, 3D Tiles) with Netherlands3D,  Cross-Origin Resource Sharing (CORS) restrictions can disrupt  development. To avoid waiting on backend adjustments from a DevOps team, you can use a local CORS proxy like  <code>local-cors-proxy</code>, which circumvents these issues while developing.</p> <p>What is CORS, and Why Does It Affect Web Applications?</p> <p>CORS (Cross-Origin Resource Sharing) is a security feature in web browsers that restricts web applications from  making requests to a different domain than the one that served the initial page. This policy prevents unauthorized  access to sensitive data from other origins (e.g., servers) that didn\u2019t explicitly permit the connection. Desktop  applications, unlike web applications, aren\u2019t bound by browser-enforced CORS rules, which is why they can access  multiple origins without restrictions.</p>"},{"location":"docs/developers/guides/dealing-with-cors-issues/#step-1-install-nodejs-and-npm","title":"Step 1: Install Node.js and NPM","text":"<p>If you don\u2019t already have Node.js, download and install it from Node.js.</p>"},{"location":"docs/developers/guides/dealing-with-cors-issues/#step-2-install-local-cors-proxy","title":"Step 2: Install <code>local-cors-proxy</code>","text":"<p>Open your terminal (or PowerShell in Windows) and install  local-cors-proxy globally:</p> <pre><code>npm install -g local-cors-proxy\n</code></pre>"},{"location":"docs/developers/guides/dealing-with-cors-issues/#step-3-start-the-local-cors-proxy","title":"Step 3: Start the Local CORS Proxy","text":"<p>To start, run the following command, where <code>&lt;TARGET_WEBSERVICE_URL&gt;</code> is the service URL you need to access:</p> <pre><code>lcp --proxyUrl &lt;TARGET_WEBSERVICE_URL&gt;\n</code></pre> <p>By default, this will run on port <code>8010</code>. For a custom port, specify it as <code>--port &lt;PORT_NUMBER&gt;</code>.</p>"},{"location":"docs/developers/guides/dealing-with-cors-issues/#step-4-handling-self-signed-certificates","title":"Step 4: Handling Self-Signed Certificates","text":"<p>If the target service uses a self-signed certificate, you may need to disable SSL verification by setting the <code>NODE_TLS_REJECT_UNAUTHORIZED</code> environment variable to <code>0</code>.</p> Linux / macOSWindows PowerShell <pre><code>export NODE_TLS_REJECT_UNAUTHORIZED=0\n</code></pre> <pre><code>$env:NODE_TLS_REJECT_UNAUTHORIZED=0\n</code></pre> <p>This setting should be applied before running the proxy.</p>"},{"location":"docs/developers/guides/dealing-with-cors-issues/#step-5-pass-proxied-urls-in-netherlands3d","title":"Step 5: Pass Proxied URLs in Netherlands3D","text":"<p>Point service requests to the proxy URL, e.g., <code>http://localhost:8010/&lt;original_service_url_path&gt;</code>, allowing requests to pass through the proxy for CORS management. This includes importing services by URL in the layers panel.</p>"},{"location":"docs/developers/guides/dealing-with-cors-issues/#step-6-test-the-setup","title":"Step 6: Test the Setup","text":"<p>Run Netherlands3D, confirming that requests are passing through the proxy. Use browser developer tools or monitor the terminal to check for successful CORS handling.</p>"},{"location":"docs/developers/guides/how-to-color-parts-of-the-terrain/","title":"How to color parts of the terrain","text":""},{"location":"docs/developers/guides/how-to-color-parts-of-the-terrain/#introduction","title":"Introduction","text":"<p>How to use the CartesianTileLayerStyler and expressions to assign distinct fill colors to specific terrain feature types\u2014e.g. footpaths, residential zones, and roads\u2014based on their material index.</p> <p>Using the Netherlands3D styling system ensures that any styling rules you define are saved directly into the project file and will be automatically reapplied whenever the project is reopened or the layer is reloaded.</p>"},{"location":"docs/developers/guides/how-to-color-parts-of-the-terrain/#prerequisites","title":"Prerequisites","text":"<ul> <li>A <code>BinaryMeshLayer</code> or similar layer already added to your scene</li> </ul>"},{"location":"docs/developers/guides/how-to-color-parts-of-the-terrain/#step-1-identify-your-feature-type-material-index-mapping","title":"Step 1: Identify your feature-type \u2192 material-index mapping","text":"<p>Your tile data assigns each feature a material index via the <code>data-materialindex</code> attribute. Decide which indices correspond to each terrain part. For example:</p> <pre><code>// These values depend on how your CartesianTiles are authored!\nconst int footpathIndex      = 0;   // e.g. \u201cfootpath\u201d material\nconst int residentialIndex   = 1;   // e.g. \u201cresidential area\u201d material\nconst int roadIndex          = 2;   // e.g. \u201croad\u201d material\n</code></pre> <p>If you\u2019re not sure, inspect your layer\u2019s mesh materials in the editor or log <code>layerFeature.Attributes[\"data-materialindex\"]</code> at runtime.</p>"},{"location":"docs/developers/guides/how-to-color-parts-of-the-terrain/#step-2-choose-your-colors","title":"Step 2: Choose your colors","text":"<p>Define the <code>Color</code> instances you want to use:</p> <pre><code>var footpathColor = new Color(0.8f, 0.7f, 0.5f); // a light sandy tone\nvar residentialColor = new Color(0.9f, 0.9f, 0.6f); // a pale yellow\nvar roadColor = new Color(0.7f, 0.7f, 0.7f); // light gray\n</code></pre>"},{"location":"docs/developers/guides/how-to-color-parts-of-the-terrain/#step-3-apply-styling-in-code","title":"Step 3: Apply styling in code","text":"<p>In your layer-initialization (or UI callback), call <code>CartesianTileLayerStyler.SetColor</code> for each type:</p> <pre><code>void StyleTerrainLayer(BinaryMeshLayer terrainLayer)\n{\n    // Get the LayerGameObject wrapper\n    var layerGO = terrainLayer.GetComponent&lt;LayerGameObject&gt;();\n\n    // Iterate the existing features in this layer\n    foreach (var kvp in layerGO.LayerData.LayerFeatures)\n    {\n        var layerFeature = kvp.Value;\n\n        // Get the material index identifier from the attributes        \n        if (!layerFeature.Attributes.TryGetValue(\"data-materialindex\", out var idxStr)) continue;\n        if (!int.TryParse(idxStr, out var materialIndex)) continue;\n\n        // Choose color based on materialIndex\n        switch (materialIndex)\n        {\n            case footpathIndex: CartesianTileLayerStyler.SetColor(layerGO, layerFeature, footpathColor); break;\n            case residentialIndex: CartesianTileLayerStyler.SetColor(layerGO, layerFeature, residentialColor); break;\n            case roadIndex: CartesianTileLayerStyler.SetColor(layerGO, layerFeature, roadColor); break;\n            // add more cases as needed\n        }\n    }\n}\n</code></pre> <p>What\u2019s happening? For each <code>LayerFeature</code> you find with a given index, <code>SetColor</code> builds an expression like</p> <pre><code>Expression.EqualTo(\n    Expression.Get(\"data-materialindex\"),\n    \"&lt;index&gt;\"\n)\n</code></pre> <p>and installs a <code>StylingRule</code> that fills any real feature with that same index in your layer.</p>"},{"location":"docs/developers/guides/how-to-color-parts-of-the-terrain/#step-4-verify-in-the-editor","title":"Step 4: Verify in the Editor","text":"<ol> <li>Enter Play Mode (or run in the Scene view).</li> <li>Inspect your terrain layer: footpaths should now use <code>footpathColor</code>, residential blocks use <code>residentialColor</code>, and    roads use <code>roadColor</code>.</li> <li>If anything looks off, check the console for parsing errors or confirm the right material indices.</li> </ol>"},{"location":"docs/developers/guides/how-to-color-parts-of-the-terrain/#whats-next","title":"What\u2019s next?","text":"<ul> <li>Combine multiple indices: if \u201croads\u201d span two materials, use a single <code>StylingRule</code> with <code>Expression.Any</code>:   <pre><code>var roadExpr = Expression.Any(\n    Expression.EqualTo(Expression.Get(\"data-materialindex\"), \"2\"), // first road material\n    Expression.EqualTo(Expression.Get(\"data-materialindex\"), \"3\") // second road material\n);\n</code></pre>   It is recommended to add a convenience method, such as <code>SetRoadColor()</code> to the <code>CartesianTileLayerStyler</code> class -or   through an extension method- to have a logical interface how to manipulate the styling of this type of layer.</li> <li>Dynamic UI: build a color-picker panel that reads the current style via <code>GetColor</code> and lets users tweak colors at   runtime.</li> </ul>"},{"location":"docs/developers/guides/how-to-color-parts-of-the-terrain/#performance-tips","title":"Performance tips","text":"<ul> <li>Regroup similar expressions into fewer rules; avoid one-rule-per-feature if you have hundreds.</li> </ul>"},{"location":"docs/developers/guides/how-to-color-parts-of-the-terrain/#further-reading","title":"Further Reading","text":"<ul> <li>Explanation: Layer styling - for more in-depth information how the styling system works.</li> </ul>"},{"location":"docs/developers/guides/loading-a-custom-project-file/","title":"Loading your own customized default Project","text":"<p>In the Netherlands3D application, a default file named <code>ProjectTemplate.nl3d</code> is used. This file is located in the  <code>StreamingAssets</code> folder and is loaded at application startup. It defines the default settings, such as the  location, and allows the twin installation to be customized according to the needs of the organization using the  application.</p>"},{"location":"docs/developers/guides/loading-a-custom-project-file/#creating-the-intended-project","title":"Creating the intended Project","text":"<p>To create a custom project file, use your twin installation to configure the desired view, including layers and settings. Once satisfied with the setup, save the project as a file named <code>ProjectTemplate.nl3d</code>. This file can then be used to define the default settings for your Netherlands3D application.</p>"},{"location":"docs/developers/guides/loading-a-custom-project-file/#built-from-source","title":"Built from Source","text":"<p>If you choose to build the Netherlands3D project from source rather than using the available Docker image, you can directly place the created <code>ProjectTemplate.nl3d</code> file into the <code>StreamingAssets</code> folder before building the  application. This allows the default settings to be included with your custom-built application.</p>"},{"location":"docs/developers/guides/loading-a-custom-project-file/#using-docker-and-mounts","title":"Using Docker and Mounts","text":"<p>The default Netherlands3D application is deployed as a Docker image, built via our GitHub Actions pipeline and hosted in the Github Container Registry. Docker images act as virtual servers with all required files and configurations preconfigured. Typically, this setup offers little flexibility to modify files in the image without rebuilding it.</p> <p>To simplify things for organizations and DevOps specialists, our Docker image is designed to allow an external directory to be mounted in the Docker container. This makes it possible to add a custom project file without rebuilding the image.</p> <p>!!! info What is Mounting?</p> <pre><code>Mounting is a technique that makes an external storage location, such as a folder on a server or in the cloud,\naccessible within an application or container. It works as a virtual link: files or directories from the external\nlocation become accessible as if they were locally available in the container.\n\nFor example:\n\n- By mounting a folder, configurations or files can be modified without rebuilding the container.\n- In environments that support file-level mounts (like Docker), it is more efficient to directly mount a file\n  to `/usr/share/nginx/html/StreamingAssets/DefaultTemplate.nl3d`, as changes become immediately visible without\n  restarting the container.\n</code></pre>"},{"location":"docs/developers/guides/loading-a-custom-project-file/#general-steps-for-configuring-a-mount","title":"General Steps for Configuring a Mount","text":"<ol> <li>Prepare the external storage location:<ul> <li>Ensure the storage location (e.g., a folder on a server or a cloud storage container) is configured and   accessible.</li> </ul> </li> <li>Place the project file:<ul> <li>Place the custom project file (e.g., <code>DefaultTemplate.nl3d</code>) in the external storage location.</li> </ul> </li> <li> <p>Configure the mount:</p> <ul> <li> <p>Set up the mount so that the external storage location is linked to the desired directory in the Docker container,   such as <code>/usr/share/nginx/html/StreamingAssets/Projects/</code>. For a single file mount, use *   <code>/usr/share/nginx/html/StreamingAssets/DefaultTemplate.nl3d</code>*.</p> </li> <li> <p>Restart the application or container to apply the new configuration. A single file mount does not require a   restart.</p> </li> <li>Verify:</li> <li>Check if the application has correctly loaded the changes.</li> </ul> </li> </ol>"},{"location":"docs/developers/guides/loading-a-custom-project-file/#example-configuring-a-mount-locally-via-docker-command-line","title":"Example: Configuring a Mount Locally via Docker Command Line","text":"<p>Here is an example of how to configure a mount using the Docker command line when running Netherlands3D locally:</p> <ol> <li>Make the project file available:<ul> <li>Ensure the custom project file <code>DefaultTemplate.nl3d</code> is available on your local system or an external storage   location.</li> </ul> </li> <li> <p>Start the Docker container with a file mount:</p> <ul> <li> <p>Use the following command to start the container:</p> <pre><code>docker run -d \\\n  -v /path/to/DefaultTemplate.nl3d:/usr/share/nginx/html/StreamingAssets/DefaultTemplate.nl3d \\\n  --name netherlands3d \\\n  ghcr.io/netherlands3d/twin:latest\n</code></pre> </li> </ul> <p>In this example, the file <code>/path/to/DefaultTemplate.nl3d</code> is directly linked to the expected location in the   container. 3. No restart required: - Since the file is mounted directly, changes are immediately visible without restarting the container. 4. Verify: - Check if the application has correctly loaded the changes by opening it in the browser.</p> </li> </ol>"},{"location":"docs/developers/guides/loading-a-custom-project-file/#example-configuring-a-mount-via-azure-portal","title":"Example: Configuring a Mount via Azure Portal","text":"<p>Below are the steps to set this up using the Azure Portal:</p> <ol> <li>Create a Blob Storage Container:<ul> <li>In the Blob Storage for your environment, create a container to store project files, for example, named *   <code>projects</code>*.</li> </ul> </li> <li>Upload the project file:<ul> <li>Upload the new default project file, named <code>DefaultTemplate.nl3d</code>, to the container.</li> </ul> </li> <li>Go to the Web App Service:<ul> <li>Open the Azure Portal and navigate to the Web App Service for your environment.</li> </ul> </li> <li>Open Settings:<ul> <li>Open the <code>Settings</code> menu and go to <code>Configuration</code> in the sidebar.</li> </ul> </li> <li>Configure Path Mappings:<ul> <li>Go to the <code>Path mappings</code> tab.</li> <li>Add a new Azure Storage Mount with a name of your choice, such as \"Projects\".</li> </ul> </li> <li>Link the Blob Storage:<ul> <li>In the <code>Storage Accounts</code> dropdown, select the storage account associated with the Blob Storage containing the   container.</li> <li>In the <code>Storage Container</code> dropdown, select the container you created earlier, such as <code>projects</code>.</li> </ul> </li> <li>Set the Mount Path:<ul> <li>Enter the following value for <code>Mount Path</code>: <code>/usr/share/nginx/html/StreamingAssets/Projects/</code>.</li> <li>This makes the contents of the Blob Storage container available at this location in the Docker container.</li> </ul> </li> <li>Save Settings:<ul> <li>Click <code>Ok</code>, and then <code>Save</code> to save the changes.</li> </ul> </li> <li>Restart the Web App Service:<ul> <li>Go back to the <code>Overview</code> page for the Web App Service and click <code>Restart</code>. This will restart the Docker   container and initialize the <code>DefaultTemplate.nl3d</code> file.</li> </ul> </li> <li>Check in the browser:<ul> <li>Open the application in the browser to verify that the configuration has been applied correctly.</li> </ul> </li> </ol>"},{"location":"docs/developers/guides/troubleshooting-build-pipeline-failures/","title":"Troubleshooting Build Pipeline Failures","text":"<p>This guide outlines common issues, their root causes, and solutions specific to our Unity build pipeline, which uses Game-CI on GitHub Actions.</p>"},{"location":"docs/developers/guides/troubleshooting-build-pipeline-failures/#unity-build-errors","title":"Unity Build Errors","text":"<p>When Unity encounters a problem during the build process, the <code>Game-CI: Build Unity project</code> step fails, and you\u2019ll see the failure reflected in the logs. These errors often stem from issues in the Unity project itself, such as script compilation errors, asset import problems, or build configuration issues.</p>"},{"location":"docs/developers/guides/troubleshooting-build-pipeline-failures/#how-to-identify-the-errors","title":"How to Identify the Errors","text":"<p>Unity build errors can be located in the logs generated by the <code>Game-CI: Build Unity project</code> step. Here's how to locate and analyze these errors:</p> <ol> <li>Access the Build Logs:<ul> <li>Navigate to the failed job in the GitHub Actions interface.</li> <li>Click on the <code>Game-CI: Build Unity project</code> step in the job log to expand it.</li> </ul> </li> <li>Search for \"Error\":<ul> <li>Use the browser's search functionality (usually <code>Ctrl+F</code> or <code>Cmd+F</code>) to search for the word <code>Error</code> in the logs.</li> <li>Look for error messages from Unity, which often indicate the root cause of the failure.</li> <li>The most useful messages usually precede the \"Build Output\" marker in the logs:    <pre><code>###########################\n# Build output #\n###########################\n</code></pre></li> </ul> </li> <li>Common Unity Build Error Patterns:<ul> <li>Script Compilation Errors:   Example: <code>Assets/Scripts/MyScript.cs(10,20): error CS1002: ; expected</code>   These errors indicate issues in your code that must be fixed before the build can proceed.</li> <li>Missing or Corrupted Assets:   Example: <code>Failed to import package: Packages/com.unity.render-pipelines.universal/Runtime/Shaders/UniversalForwardLit.shader</code>   Ensure that all required assets are available and properly configured.</li> <li>Build Configuration Errors:   Example: <code>BuildFailedException: Player export failed. Reason: Invalid BuildTarget</code>   Check your build settings and ensure they match the expected platform.</li> </ul> </li> <li>Download Logs for Local Analysis: If the error is unclear, download the full log from the GitHub Actions    interface and analyze it locally. Look for keywords like <code>Exception</code>, <code>Failed</code>, or <code>Error</code>.</li> </ol>"},{"location":"docs/developers/guides/troubleshooting-build-pipeline-failures/#fixing-unity-build-errors","title":"Fixing Unity Build Errors","text":"<p>After identifying the issue, address it in the Unity project:</p> <ul> <li>For Script Errors:<ul> <li>Open Unity locally and resolve compilation issues.</li> </ul> </li> <li>For Asset Problems:<ul> <li>Ensure all necessary assets are imported and not corrupted.</li> <li>Reimport the asset manually if required.</li> </ul> </li> <li>For Build Configuration Issues:<ul> <li>Verify your <code>Player Settings</code>, platform-specific settings, and other configurations.</li> </ul> </li> </ul>"},{"location":"docs/developers/guides/troubleshooting-build-pipeline-failures/#github-container-registry-403-error","title":"GitHub Container Registry 403 Error","text":"<p>Symptom: The <code>Docker: Login to GitHub Container Registry</code> or <code>Docker: Build and push image</code> step fails with a <code>403 Forbidden</code> error.</p> <p>Cause: Transient authentication issues between GitHub Actions and the GitHub Container Registry.</p> <p>Solution: Restart the failed build pipeline, authentication retries often resolve the issue.</p>"},{"location":"docs/developers/guides/troubleshooting-build-pipeline-failures/#unity-license-server-concurrency-issues","title":"Unity License Server Concurrency Issues","text":"<p>Symptom: The <code>Game-CI: Build Unity project</code> step fails with errors related to Unity license activation.</p> <p>Cause: Multiple builds running simultaneously can cause Unity\u2019s license server to block one of the requests.</p> <p>Solution: Restart the failed pipeline.</p>"},{"location":"docs/developers/guides/troubleshooting-build-pipeline-failures/#disk-space-issues","title":"Disk Space Issues","text":"<p>Symptom: The pipeline fails with errors indicating insufficient disk space, often during the <code>Game-CI: Build Unity project</code> step or Docker build steps.</p> <p>Cause: Limited disk space on the runner due to temporary files or cached data.</p> <p>Solution:</p> <ul> <li>The <code>Free Disk Space (Ubuntu)</code> step in your workflow already clears space. If the issue persists:<ul> <li>Manually clean the runner by removing large or unnecessary files.</li> <li>Ensure <code>tool-cache</code> is enabled if more aggressive cleanup is needed.</li> </ul> </li> </ul>"},{"location":"docs/developers/guides/troubleshooting-build-pipeline-failures/#library-cache-issues","title":"Library Cache Issues","text":"<p>Symptom: The <code>Game-CI: Build Unity project</code> step fails due to corrupted or incompatible files in the <code>Library</code> directory.</p> <p>The error message <code>The file 'VirtualArtifacts/Primary/3dc838491f0e95d47a43e62101d2c8f2' is corrupted! Remove it and launch unity again!</code> or a variant there of shows.</p> <p>This can happen when a update in Unity version is done, or when some branches are still on a different version  of Unity.</p> <p>Cause: The cache may contain outdated or invalid files after changes to assets, packages, or project settings.</p> <p>Solution:</p> <ul> <li>Delete the cache for the offending branch on the Manage Caches page in Github: https://github.com/Netherlands3D/twin/actions/caches</li> </ul> <p>If the problem persists - delete all caches on this page; sometimes caches are re-used when they are similar.</p>"},{"location":"docs/developers/guides/troubleshooting-build-pipeline-failures/#github-pages-artifact-deployment-issues","title":"GitHub Pages Artifact Deployment Issues","text":"<p>Symptom: The <code>Github Pages: prepare artefact for deployment</code> or <code>Deploy to GitHub Pages</code> step fails.</p> <p>Cause: Issues may arise if the build artifact path is incorrect or the <code>actions/upload-pages-artifact</code> step doesn\u2019t execute properly.</p> <p>Solution:</p> <ul> <li>Verify the <code>path</code> in the <code>actions/upload-pages-artifact</code> step matches the correct build output   directory (<code>build/WebGL/WebGL</code>).</li> <li>Ensure the <code>deploy</code> job includes the correct permissions for GitHub Pages.</li> </ul>"},{"location":"docs/developers/guides/troubleshooting-build-pipeline-failures/#docker-build-and-push-issues","title":"Docker Build and Push Issues","text":"<p>Symptom: The <code>Docker: Build and push image</code> step fails with errors during the build or push process.</p> <p>Cause: Common reasons include:</p> <ul> <li>Incorrect Dockerfile paths.</li> <li>Build arguments (<code>SOURCE_PATH</code>) not resolving correctly.</li> <li>Network or authentication errors with the container registry.</li> </ul> <p>Solution:</p> <ul> <li> <p>Restart the build first to see if it is a temporary issue - otherwise proceed with the following steps</p> </li> <li> <p>Confirm the <code>context</code> and <code>file</code> paths in the Docker build step.</p> </li> <li>Verify that <code>build-args</code> matches the correct path to your Unity WebGL build output (<code>build/WebGL/WebGL</code>).</li> <li>Check Docker authentication using the <code>docker/login-action</code>.</li> </ul>"},{"location":"docs/developers/guides/troubleshooting-build-pipeline-failures/#general-best-practices","title":"General Best Practices","text":"<ol> <li>Monitor Logs:    Each step in your pipeline produces logs. Check these logs for detailed error messages and trace the failure to the    specific step.</li> <li>Retry Builds:    Issues such as transient authentication failures or license conflicts are often resolved by restarting the pipeline.</li> <li>Version Control:    Pin versions of Game-CI tools and Unity to avoid unexpected failures due to updates:     <pre><code>unityVersion: 2022.3.8f1\ncustomImage: unityci/editor:ubuntu-2022.3.8f1-webgl-2\n</code></pre></li> <li>Test Locally:    Run builds locally to catch issues before pushing changes to GitHub. Use Docker to test Game-CI locally:     <pre><code>docker run --rm -it -v \"$(pwd):/project\" unityci/editor:ubuntu-2022.3.8f1-webgl-2\n</code></pre></li> <li>Regular Maintenance:    Periodically update secrets, clean runners, and verify your project dependencies to maintain pipeline reliability.</li> </ol>"},{"location":"docs/developers/guides/ui/creating-a-custom-component/","title":"Creating a Custom Component","text":""},{"location":"docs/developers/guides/ui/creating-a-custom-component/#introduction","title":"Introduction","text":"<p>Unity's UI Toolkit allows you to build your own reusable UI components - known as Controls - that go beyond simple UXML templates by including actual behaviour, much like components in React.js. </p> <p>You can create these controls either by starting in the UI Builder or by copying an existing component. When using the  UI Builder, a few extra setup steps are required before the component is ready to publish. These are explained in their  own guide on using UI Builder.</p> <p>Also, when you want to use other custom controls inside the UI Builder, make sure to select them from the  \u201cCustom Controls (C#)\u201d section in the Project panel, rather than from the UXML documents listed under  \u201cUI Documents (UXML)\u201d, to ensure the correct version of the component is used.</p>"},{"location":"docs/developers/guides/ui/creating-a-custom-component/#overview","title":"Overview","text":"<p>This guide consists of the following parts:</p> <ol> <li>Setting up a simple presentation component</li> <li>Adding content (To be written)</li> <li>Configuring a component using props (To be written)</li> <li>Responding to events  (To be written)</li> </ol> <p>Through this structure it is expected that you can either reference the specific section when you want to accomplish one of these.</p>"},{"location":"docs/developers/guides/ui/creating-a-custom-component/#1-setup-a-simple-presentational-component","title":"1. Setup a simple presentational component","text":"<p>This example shows how to create a minimal \u201cHeader\u201d component that only manages its layout and styling.</p>"},{"location":"docs/developers/guides/ui/creating-a-custom-component/#make-the-component-in-c","title":"Make the component in C#","text":"<p>Minimal implementation:</p> <p>File: <code>Assets/UI Toolkit/Scripts/Components/Header.cs</code></p> <pre><code>using Netherlands3D.UI_Toolkit.Scripts;\nusing Netherlands3D.UI.ExtensionMethods;\nusing UnityEngine.UIElements;\n\nnamespace Netherlands3D.UI.Components\n{\n    [UxmlElement]\n    public partial class Header : VisualElement\n    {\n        public Header()\n        {\n            this.CloneComponentTree(\"Components\");\n            this.AddComponentStylesheet(\"Components\");\n        }\n    }\n}\n</code></pre> <p><code>CloneComponentTree</code> and <code>AddComponentStylesheet</code> automatically connect the UXML and USS files located in the <code>Components</code> subfolder of the shared UI Resources directory.</p> <p>They are Netherlands3D helper methods that:</p> <ul> <li>Centralize resource loading paths  </li> <li>Wrap Unity\u2019s default API  </li> <li>Add small guardrails</li> </ul>"},{"location":"docs/developers/guides/ui/creating-a-custom-component/#make-the-layout-template-uxml","title":"Make the layout template (UXML)","text":"<p>File: <code>Assets/UI Toolkit/Resources/UI/Components/Header.uxml</code></p> <pre><code>&lt;ui:UXML\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:ui=\"UnityEngine.UIElements\"\n    noNamespaceSchemaLocation=\"../../../../UIElementsSchema/UIElements.xsd\"\n    xmlns:nl3d=\"Netherlands3D.UI.Components\"\n    editor-extension-mode=\"False\"\n    class=\"header\"\n&gt;\n&lt;/ui:UXML&gt;\n</code></pre> <p>Tip</p> <p>The <code>xmlns:nl3d</code> namespace lets you reference Netherlands3D components without writing their full C# namespace, this  is demonstrated below when we add a label and icon. </p>"},{"location":"docs/developers/guides/ui/creating-a-custom-component/#make-the-styling-uss","title":"Make the styling (USS)","text":"<p>Example header bar: full\u2011width, automatic height, horizontal layout with spaced content.</p> <p>File: <code>Assets/UI Toolkit/Resources/UI/Components/Header-style.uss</code></p> <pre><code>.header {\n    /* Display contents horizontally (row) */\n    flex-direction: row;\n\n    /* Prevent this header from growing vertically */\n    flex-grow: 0;\n\n    /* Allow shrink\u2011to\u2011fit based on content */\n    flex-shrink: 1;\n\n    /* Spread child elements horizontally */\n    justify-content: space-between;\n\n    /* Use theme's white color */\n    background-color: var(--color-white);\n}\n</code></pre> <p>Warning</p> <p>Filename must end with <code>-style.uss</code>. Unity may incorrectly pair a USS file with a UXML if their names differ only by extension.</p>"},{"location":"docs/developers/guides/ui/creating-a-custom-component/#best-practices","title":"Best practices","text":"<ul> <li>Use USS variables for colors, spacing, and text styles.   These are defined in: <code>Assets/UI Toolkit/Resources/UI/_Theme.uss</code></li> </ul>"},{"location":"docs/developers/packages/creating-and-managing/","title":"Creating and managing Packages","text":"<p>Netherlands3D is a framework where you, as developer, can pick the functionality that you need from a series of  packages. This guide will empower you to develop your own packages by providing step-by-step instructions how you can create your own package, release it and last, but not least, publish it to OpenUPM.</p>"},{"location":"docs/developers/packages/creating-and-managing/#variables-placeholders","title":"Variables / Placeholders","text":"<p>Before we get started, let's define some terms as if they were variables. This documentation and the template files  in the Gist mentioned in the chapter Creating a new package uses various placeholders. These  can recognized as they are between brackets, for example <code>{NAME}</code>. </p> <p>This table provides an overview of them and their meaning.</p> Name Explanation Example NAME The name of the code repository, this is usually the DISPLAY_NAME in PascalCase. It is recommended to limit the name to two words, if more words add clarity than that takes precedence. PeriodicSnapshots PACKAGE_NAME The package name as known in the package manager and/or package.json; always starts with <code>eu.netherlands3d.</code> and followed by the display name -or similar- in kebab-case eu.netherlands3d.periodic-snapshots DISPLAY_NAME The human-readable name of a package, shown in the README or in the Package Manager Periodic Snapshots REPOSITORY_NAME Alias of NAME, used to make explicit that we want the repository name there. PeriodicSnapshots VERSION The version number in the package.json, according to SemVer. Important: contrary to the git tag, this does not start with a letter <code>v</code> 1.0.1 DESCRIPTION A single-line short description describing the package, can also be used on Github as the description for the repository This package provides the means to do take a series of snapshots for specific moments throughout the year. LONG_DESCRIPTION The description of the package detailing what it is used for. USAGE_INFORMATION Documentation how to use this package. See existing packages for examples NOTE One or more entries in the CHANGELOG -according to Keep A Changelog- describing what has been added, changed, removed or deprecated in a package <p>This vocabulary and their definitions will help to have a consistent experience when working with packages.</p>"},{"location":"docs/developers/packages/creating-and-managing/#creating-a-new-package","title":"Creating a new package","text":"<p>When creating a new package, it is recommended to first create it as an embedded package in the  Netherlands3D twin project. This will help to prototype and experiment until  the point where it is stable enough to be distributed.</p> <p>This can be done using the following steps:</p> <ol> <li> <p>Clone the Netherlands3D Twin project, located at https://github.com/Netherlands3D/twin.</p> </li> <li> <p>Make sure Unity is not open while performing the following steps; it generally tends to crash when it updates while setting up a package.</p> </li> <li> <p>Create a directory for your embedded package in the     <code>Packages</code> folder.</p> <p>Important</p> <p>The directory name MUST follow the structure <code>eu.netherlands3d.[name]</code> where <code>name</code> is in lower-case kebab-case.</p> </li> <li> <p>Copy the template files, located at https://gist.github.com/mvriel/8a8251b492d9d8f742da16667c49e412, and fill in the placeholders.</p> </li> <li> <p>Set up the package according to the following recommended directory structure: https://docs.unity3d.com/Manual/cus-layout.html</p> </li> <li> <p>Start Unity and allow for it to install the new package, you should see your new package in the \"Installed Packages\" section of the Package Manager with the tag <code>Custom</code> behind the name.</p> </li> <li> <p>When you want to add Scripts to this package: Make sure you have created the folder <code>Runtime\\Scripts</code> as a location to store them and add an Assembly Definition with the name <code>{PACKAGE_NAME}.Runtime</code>. </p> </li> </ol>"},{"location":"docs/developers/packages/creating-and-managing/#promoting-an-embedded-package","title":"Promoting an embedded package","text":"<p>It takes time and effort to get a package into a usable and moderately stable condition. Because of this the recommended way of working is to first create an embedded package in the Twin project -like an incubator project- and once it is  moderately stable: promote it to its own repository.</p> <p>Promoting an embedded package is done by one of the project maintainers -if not alone for the fact that a repository  needs to be made- and follows the following sequence of steps:</p> <ol> <li> <p>Create a repository whose name matches the <code>{NAME}</code> placeholder, thus a PascalCase representation of the     human-readable name.</p> </li> <li> <p>Move all files from the <code>Packages\\{PACKAGE_NAME}</code> folder in the Twin repository to the newly made repository's root     folder</p> </li> <li> <p>Check and adjust, at least, the URL's for the LICENSE, README and CHANGELOG in the <code>package.json</code>.</p> </li> <li> <p>Release and publish the promoted package, see the chapters on releasing and     publishing for the involved steps.</p> </li> <li> <p>In the Twin project, add a reference to <code>{PACKAGE_NAME}</code> to the package.json or install the package through    the package manager.</p> <p>Important</p> <p>After a package is added to OpenUPM for the first time, it can take between 30 and 60 minutes for it to  show up in the package listing.</p> </li> </ol> <p>Once a package is promoted, you can no longer edit it as part of the Twin project; in the next chapter  Changing a Package it is described how you can change a promoted package without all too much  hassle.</p>"},{"location":"docs/developers/packages/creating-and-managing/#changing-a-package","title":"Changing a package","text":"<p>To be written</p>"},{"location":"docs/developers/packages/creating-and-managing/#releasing-a-package","title":"Releasing a package","text":"<p>When you want to release a new version of a package you generally go through the following steps:</p> <p>Tip</p> <p>Before releasing, make sure you have tested your package in the Twin -or  another Netherlands3D-based project- installed as a local package.</p> <p>Especially important is:</p> <ul> <li>verifying that the correct dependencies are set and installed</li> <li>that the Assembly Definition can be used and</li> <li>that the Assembly Definition does not depend on Assembly Definitions that are not a dependency of your package,   especially Netherlands3D.Core.Runtime should be avoided</li> </ul> <p>Failure to do so may cause extra work because once a package is released, it is impossible to change something in the release and a new release must be made.</p> <ol> <li> <p>Go to the repository of your package. If there is none: see the chapter on     Promoting an embedded package and do that first.</p> </li> <li> <p>Ensure the version number in the package.json is updated</p> </li> <li> <p>Check the CHANGELOG.md: </p> </li> <li> <p>Does it contain all changes since the last version?</p> </li> <li> <p>Is the top-entry <code>[Unreleased]</code>? Fill in the new version number and add a date, see: https://keepachangelog.com/en/1.0.0/#effort</p> </li> <li> <p>Ensure any changes in the above are in the main branch</p> </li> <li> <p>Go to \"Releases\" on Github (<code>https://github.com/Netherlands3D/{NAME}/releases</code>) and</p> </li> <li> <p>Draft a new release       </p> </li> <li>Click on \"Choose a tag\"</li> <li>Enter the version number from the package.json with a preceding letter <code>v</code>, for example: <code>v1.0.1</code>.</li> <li>Click on the option \"Create new tag: <code>v{VERSION}</code> on publish\"</li> <li>(optional) Add a release title and description</li> <li>Click on the button \"Publish Release\"</li> </ol> <p>Once a new release/tag has been made, your new release of your package is all set! If it has already been  published on OpenUPM before, no further action is needed. OpenUPM will automatically pick up on the new tag and make the new version available.</p> <p>When the package has not been published on OpenUPM yet, now is a good time to do it.</p>"},{"location":"docs/developers/packages/creating-and-managing/#publishing-a-package-on-openupm","title":"Publishing a package on OpenUPM","text":"<p>When a package is released for the first time, it needs to be published by registering it on OpenUPM.</p> <p>Tip</p> <p>Before publishing, make sure you have tested your package in https://github.com/Netherlands3D/twin -or another Netherlands3D-based project- installed as a local package.</p> <p>Especially important is:</p> <ul> <li>verifying that the correct dependencies are set and installed</li> <li>that the Assembly Definition can be used and </li> <li>that the Assembly Definition does not depend on Assembly Definitions that are not a dependency of your package,   especially Netherlands3D.Core.Runtime should be avoided</li> </ul> <p>Failure to do so may cause extra work because once a package is published, it is inconvenient to unpublish it or  change publication details such as the name.</p> <p>To do so, you can take the following steps:</p> <ol> <li> <p>Go to https://openupm.com.</p> </li> <li> <p>Click on the \"+\" button in the menu bar to add a new package    </p> </li> <li> <p>Fill out the Github repository name in the intended field and click on \"Go\".        A form expands where you can verify the package name, ReadMe location and more</p> </li> <li> <p>Enter your github username in the \"Discovered by\" field; this is used to base a fork of OpenUPM from and add the     package as a pull request.</p> <p></p> <p>Note</p> <p>The section \"Advanced\" is for advanced use when multiple packages are hosted in the same repository; at the moment this method is not recommended and as such that part of the submission form can be skipped</p> </li> <li> <p>Check the \"Promotion\" section if the package fits any of these categories, and check these.</p> </li> <li> <p>Click on the \"Verify Package\" button, all other fields can be left unchanged.</p> </li> </ol> <p>As soon as the steps above have completed, you are asked to fork the <code>OpenUPM</code> repository and to commit these changes in a feature branch. At this point you can use the \"Create pull request\" button to create a pull request to OpenUPM.</p> <p>Tip</p> <p>If this is your first time submitting a package to OpenUPM, the maintainer of OpenUPM needs to approve the Pull  Request manually; this is generally done within 24 hours. Any subsequent pull requests will be automatically merged.</p> <p>After the pull request is merged, it will take 30 to 60 minutes for <code>OpenUPM</code> to add the package to the registry.</p>"},{"location":"docs/developers/packages/creating-and-managing/#faq","title":"FAQ","text":"<p>Can I depend on the <code>Netherlands3D.Core.Runtime</code> assembly?</p> <p>At time of writing, this assembly is within the code of the https://github.com/Amsterdam/Netherlands3D skeleton; meaning that this dependency only works when the package is used within a project that is based on this skeleton. This can be a problematic dependency since we are actively working on moving the contents of this skeleton into components.</p> <p>Because of the above, it is not recommended for a published package to depend on the <code>Netherlands3D.Core.Runtime</code> assembly.</p> <p>If code from this assembly is needed, it is recommended to extract this code into another package that you can depend  on or duplicate it into your own package until such a package can be made.</p> <p>For more information on this, see the question <code>Can I depend on Assemblies that are not in my own package?</code>.</p> <p>Can I depend on Assemblies that are not in my own package?</p> <p>You sure can! As long as these assemblies are in a package that is published in a Unity Package Registry such as  OpenUPM, and that you have added that package as a dependency to your <code>package.json</code> file.</p> <p>If you add an assembly whose package cannot be included in your <code>package.json</code> -either because it is not a package or a git-based package- then you will need to add installation instructions in the README. Without these instructions, any user of the package will have a missing assembly -and thus errors- without knowing how to fix it.</p> <p>One of the packages does not show up in the Package Manager after publishing</p> <p>Have you checked the minimum unity version in the <code>package.json</code>? If the minimum version is newer than your installed version, it will not be visible.</p> <p>Why OpenUPM and not add packages through a Git URL?</p> <p>Good question! When you add packages through a Git URL you lose certain features that packages hosted on a registry do have. This includes but is not limited to:</p> <ol> <li> <p>Unable to update to a new version: when you use a Git tag/release, then you need to uninstall and reinstall the     package when a new becomes available instead of just using the <code>Update</code> button.</p> </li> <li> <p>Git-url based packages cannot be used as dependencies: this means that if a package depends on another, with git     urls you need to manually install the correct dependencies and face possible version conflicts with newer versions.</p> </li> </ol>"},{"location":"docs/developers/testing/3d-models/","title":"Testing 3D Model Formats","text":""},{"location":"docs/developers/testing/3d-models/#introduction","title":"Introduction","text":"<p>This document provides guidance on testing 3D model formats supported by our system. It includes a list of available test models and a matrix of their properties, enabling systematic evaluation of compatibility, rendering behavior, and feature support.</p>"},{"location":"docs/developers/testing/3d-models/#scope-of-this-document","title":"Scope of This Document","text":"<p>This document focuses on testing the fundamental functionalities of 3D model loading, such as format compatibility, texture support, coordinate system alignment, and performance considerations. Additional features, including animation, material properties, and advanced optimizations, will be considered in later versions of the application. This document will be updated accordingly as new formats and capabilities are introduced.</p>"},{"location":"docs/developers/testing/3d-models/#test-models","title":"Test Models","text":"<p>Below is a list of example 3D models that can be used for testing. Each entry includes a download link and relevant metadata.</p> <p>Please note</p> <p>This is not an exhaustive list. It is recommended to test with as many variations as possible. If a new model highlights a different compatibility issue, please update this list accordingly.</p> Model Name Format Download Link Textures Materials Animation Coordinate System File Size OBJ with 4 colored materials .obj Download / Project \u274c \u2705 \u274c Local XX MB Rietveldhuis (Utrecht) .obj Download \u274c \u2705 \u274c EPSG:28992 (RD) XX MB <p>This table serves as a reference for understanding which formats support different properties, allowing focused testing and troubleshooting.</p> <p>* While compiling this list, some properties might not yet be tested. Please provide a pull request with missing information when encountered.</p>"},{"location":"docs/developers/testing/3d-models/#testing-methodology","title":"Testing Methodology","text":"<ol> <li> <p>Format Validation:</p> <ul> <li>Ensure the file format is correctly recognized and loaded.</li> <li>Check for potential parsing errors when opening the file.</li> </ul> </li> <li> <p>Texture &amp; Material Testing:</p> <ul> <li>(Upcoming) Verify that textures are correctly applied and rendered.</li> <li>Confirm that material properties (e.g., roughness, metallic) are correctly interpreted.</li> </ul> </li> <li> <p>Coordinate System &amp; Alignment:</p> <ul> <li>Ensure that the model loads in the correct orientation.</li> <li>Verify whether georeferenced models are loaded in the correct location</li> </ul> </li> <li> <p>Performance Testing:</p> <ul> <li>Load models with different complexities and file sizes to observe performance.</li> <li>Identify any models that cause excessive rendering lag or memory usage.</li> </ul> </li> </ol>"},{"location":"docs/developers/testing/3d-models/#future-format-support","title":"Future Format Support","text":"<p>We currently support <code>.obj</code> files and plan to add support for additional formats, such as <code>.gltf</code>. As new formats are introduced, this document will be updated with relevant testing procedures and additional test models.</p> <p>Should you encounter issues with a specific model, please document it and submit a report to improve format compatibility.</p>"},{"location":"docs/developers/testing/ogc-webservices/","title":"Testing OGC Web Services","text":""},{"location":"docs/developers/testing/ogc-webservices/#introduction","title":"Introduction","text":"<p>This document provides guidance on testing Open Geospatial Consortium (OGC) Web Map Services (WMS) and Web Feature Services (WFS). It includes a list of available test services and a matrix of their properties, enabling systematic evaluation against different capabilities and constraints.</p>"},{"location":"docs/developers/testing/ogc-webservices/#scope-of-this-document","title":"Scope of This Document","text":"<p>This document focuses on testing the fundamental functionalities of OGC Web Services, such as service availability, supported coordinate reference systems, bounding box capabilities, and format support. Advanced functionalities, including attribute and spatial filtering, will be considered in later versions of the application. This document will be updated accordingly to reflect new testing procedures when such features are introduced.</p>"},{"location":"docs/developers/testing/ogc-webservices/#test-endpoints","title":"Test Endpoints","text":"<p>Below is a list of example WMS and WFS services that can be used for testing. Each service should include its endpoint and relevant metadata -do not forget to scroll sideways to see all information. </p> <p>Please note</p> <p>This is not an exhaustive list, it is recommended to test with as many variations possible. Should a new variant be  found that has a different profile from these, please update this list to include it.</p> Endpoint Service Type Version Default CRS Multiple CRS Support BBOX Support Layer/Feature Count Supported Formats Supports parameterless invocation https://service.pdok.nl/cbs/vierkantstatistieken500m/2022/wfs/v1_0?request=GetCapabilities&amp;service=WFS WFS X.X.X EPSG:XXXX \u2705/\u274c \u2705/\u274c XX X \u2705/\u274c https://service.pdok.nl/cbs/vierkantstatistieken500m/2022/wms/v1_0?request=GetCapabilities&amp;service=WMS WMS X.X.X EPSG:XXXX \u2705/\u274c \u2705/\u274c XX X \u2705/\u274c https://service.pdok.nl/cbs/gebiedsindelingen/2024/wfs/v1_0?request=GetCapabilities&amp;service=WFS WFS X.X.X EPSG:XXXX \u2705/\u274c \u2705/\u274c XX X \u2705/\u274c https://service.pdok.nl/prorail/spoorwegen/wfs/v1_0?service=wfs&amp;request=GetCapabilities https://service.pdok.nl/rioned/beheerstedelijkwater/wfs/v1_0?request=GetCapabilities&amp;service=wfs https://service.pdok.nl/rws/digitaaltopografischbestand/wms/v1_0?request=GetCapabilities&amp;service=WMS https://service.pdok.nl/rws/digitaaltopografischbestand/wfs/v1_0?request=GetCapabilities&amp;service=WFS https://geo.rijkswaterstaat.nl/services/ogc/gdr/bps_kaart/ows?service=WMS&amp;request=getcapabilities&amp;version=1.3.0 https://service.pdok.nl/rvo/natura2000/wfs/v1_0?request=getcapabilities&amp;service=wfs https://service.pdok.nl/rws/ahn/wms/v1_0?request=GetCapabilities&amp;service=WMS https://service.pdok.nl/kadaster/plu/wms/v1_0?request=Getcapabilities&amp;service=WMS&amp;version=1.3.0 https://apps.geodan.nl/public/data/org/gws/YWFMLMWERURF/kea_public/wms?&amp;SERVICE=wms&amp;REQUEST=Getcapabilities https://service.pdok.nl/kadaster/kadastralekaart/wms/v5_0?&amp;service=WMS&amp;Request=GETCapabilities&amp;version=1.3.0 https://service.pdok.nl/hwh/luchtfotorgb/wms/v1_0?request=GetCapabilities&amp;service=wms https://nens.lizard.net/wms/raster_f284fcd9-84ef-4b5a-ad32-d20f6f8978c5/?SERVICE=WMS&amp;REQUEST=Getcapabilities <p>This table serves as a reference for understanding which services support different properties, allowing focused testing and troubleshooting.</p> <p>* While compiling this list, it is possible not all properties are available yet. Please provide a pull request with the missing information when encountering this.</p>"},{"location":"docs/developers/testing/ogc-webservices/#testing-methodology","title":"Testing Methodology","text":"<ol> <li>Service Validation:<ul> <li>Verify that the service responds when accessed directly at its base URL (without <code>service</code> and <code>request</code>   parameters) if the service supports parameterless invocation (see chapter below).</li> <li>Check whether the service responds correctly when providing <code>service=WMS/WFS</code> and <code>request=GetCapabilities</code>   parameters.</li> <li>Validate that individual layers or feature types can be requested using <code>GetMap</code> (for WMS) or <code>GetFeature</code> (for   WFS) and their supporting parameters.</li> </ul> </li> <li>CRS &amp; BBOX Testing:<ul> <li>Request maps or features in different CRSs and bounding boxes to confirm proper handling.</li> </ul> </li> <li>Format Compatibility:<ul> <li>Ensure that the expected image (PNG) and feature formats (GeoJSON) is used if multiple formats are supported.</li> </ul> </li> <li>Feature &amp; Layer Access:<ul> <li>Check layer listings (WMS) and feature queries (WFS) to confirm all advertised data is retrievable.</li> </ul> </li> <li>Performance Testing:<ul> <li>Note high response times while testing to provide guidance when doing performance reviews.</li> </ul> </li> </ol>"},{"location":"docs/developers/testing/ogc-webservices/#parameterless-invocation","title":"Parameterless Invocation","text":"<p>Some GIS endpoints support parameterless invocation, where calling the service using only its base URL (without explicitly providing <code>service</code> and <code>request</code> parameters) automatically returns the GetCapabilities response. While this is not part of the OGC standard, it is a commonly observed behavior in the field.</p> <p>This feature is often referenced in documentation and examples, making it necessary to support and test for. Services that implement parameterless invocation simplify client implementation but also introduce inconsistencies in behavior across different services. When testing, it is recommended to verify whether a service responds correctly when invoked without parameters and compare the results against an explicit <code>GetCapabilities</code> request.</p>"},{"location":"docs/developers/tilekit/","title":"Tilekit","text":""},{"location":"docs/developers/tilekit/#visie","title":"Visie","text":"<p>Tilekit is een raamwerk om geospatiale datasets te visualiseren middels een geheugen-geoptimaliseerde methode om grote  gebieden te kunnen visualiseren op een manier die web-geschikt is.</p>"},{"location":"docs/developers/tilekit/#introductie","title":"Introductie","text":"<p>Digitale twin omgevingen brengen een brede variatie aan ruimtelijke datasets samen: van fijnmazige tegeldiensten tot uitgebreide, ongetegelde modellen, van rasterlagen tot 3D-geometrie en thematische vectorinformatie. Elk van deze bronnen heeft een eigen structuur, formaat en dynamiek, maar in de applicatie moeten ze samenkomen in \u00e9\u00e9n integrale visualisatie.</p> <p>Tilekit is ontwikkeld om dit proces te vereenvoudigen. Het biedt een generiek en uitbreidbaar fundament waarmee elke dataset\u2014ongeacht of deze getegeld, ongetegeld, statisch of dynamisch is\u2014op een consistente manier kan worden ge\u00efnterpreteerd, beheerd en weergegeven. In plaats van dat iedere bron speciale behandeling nodig heeft, zorgt Tilekit voor \u00e9\u00e9n uniforme levenscyclus waarmee data effici\u00ebnt kan worden gestreamd en gevisualiseerd.</p> <p>Deze aanpak maakt het mogelijk om meerdere grote datasets tegelijk te gebruiken binnen Unity, inclusief WebGL-toepassingen waar zorgvuldig omgaan met geheugen en bandbreedte belangrijk is. Door datastructuren te optimaliseren, onderdelen strikt te scheiden en de tile-levenscyclus centraal te stellen, biedt Tilekit een solide basis voor schaalbare en performante visualisatie.</p> <p>Deze technische specificatie beschrijft hoe Tilekit dit bereikt: de ontwerpkeuzes, datastructuren, extensiepunten en service-typen die het systeem vormen. Het document helpt ontwikkelaars begrijpen hoe verschillende bronnen in \u00e9\u00e9n samenhangend geheel kunnen worden opgenomen, en hoe nieuwe datasettypes eenvoudig kunnen worden ge\u00efntegreerd in een groeiend landschap van ruimtelijke informatie.</p>"},{"location":"docs/developers/tilekit/#doelen","title":"Doelen","text":"<p>Tilekit heeft ten doel om een raamwerk te bieden voor het visualiseren van alle geospatiale content, deze flexibiliteit vereist een ontwerp waar bij de volgende doelen gesteld zijn:</p> <ul> <li>Raamwerk om, getegeld, geospatiale data in te laden en visualiseren.</li> <li>Geheugen-geoptimaliseerd om op het web grote gebieden te kunnen tonen.</li> <li>Makkelijk om onderdelen toe te voegen zonder het hele systeem aan te hoeven te passen.</li> <li>Ondersteunt publieke en afgeschermde bronnen middels authenticatie.</li> <li>Live streamen (remote datasets) of importeren (lokale datasets) van data moet mogelijk zijn </li> </ul>"},{"location":"docs/developers/tilekit/#filosofie","title":"Filosofie","text":"<p>Tilekit is gebouwd rondom het principe dat als een legoset een tegelsysteem in elkaar kan worden geprikt. Daarbij kunnen onderdelen vervangen worden als voortschrijdend inzicht dat vereist, of juist toegevoegd als er nieuwe databronnen geimplementeerd worden.</p>"},{"location":"docs/developers/tilekit/#duik-dieper-in-de-materie","title":"Duik dieper in de materie","text":"<ul> <li>Architectuur in vogelvlucht</li> <li>Memory management</li> <li>Tijdsafhandeling</li> <li>Data opslag</li> <li>Ophalen van data</li> <li>Tegelsysteem</li> <li>Features</li> <li>Appendix A. Casussen</li> <li>Appendix B. Bronvermeldingen</li> <li>Appendix C. Begrippen</li> </ul>"},{"location":"docs/developers/tilekit/#nog-uit-te-zoeken-beschrijven","title":"Nog uit te zoeken / beschrijven","text":"<ul> <li>Meer in-diepte hoe de architectuur werkt</li> <li>CRS afhandeling</li> <li>Tiling Schemes en hoe die werken</li> <li>Debugging tools</li> <li>Features</li> <li>Styling</li> <li>Memory Management Handreiking</li> <li>Postprocessing van tegels verder toelichten, mogelijk met clipping en masking als voorbeeld</li> <li>Beschrijving hoe hoogte wisselingen te kunnen doen (FAQ?)</li> </ul>"},{"location":"docs/developers/tilekit/appendix-a-casussen/","title":"Appendix a casussen","text":""},{"location":"docs/developers/tilekit/appendix-a-casussen/#appendix-a-casussen","title":"Appendix A. Casussen","text":""},{"location":"docs/developers/tilekit/appendix-a-casussen/#a1-wms","title":"A.1. WMS","text":""},{"location":"docs/developers/tilekit/appendix-a-casussen/#a11-doel","title":"A.1.1. Doel","text":"<p>De casus van het herimplementeren van WMS in het nieuwe tegelsysteem is bedoeld om te demonstreren hoe een vertegeling op basis van HLOD kan helpen om nabij de camera gedetailleerde tegels te tonen, en verder weg steeds grotere onnauwkeurige tegels.</p>"},{"location":"docs/developers/tilekit/appendix-a-casussen/#a12-demonstreert","title":"A.1.2. Demonstreert","text":"<ul> <li>Inladen Capaciteiten en omzetten naar TileSet definitie</li> <li>Impliciete vertegeling van een ongetegelde bron</li> <li>Inladen van een externe databron</li> <li>Verbeelden van remote tegels met afbeeldingen</li> <li>Dynamische aanpassing tegelgrootte en resolutie afhankelijk van afstand camera</li> </ul>"},{"location":"docs/developers/tilekit/appendix-a-casussen/#a13-requirements","title":"A.1.3. Requirements","text":"<ul> <li>Middels de Tileset definitie van dit systeem moet<ul> <li>binnen de bounding box van een WMS laag een tegelset getoond worden</li> <li>een implicit quadtree gebaseerde vertegeling gedefinieerd kunnen worden</li> <li>Meerdere sublevels mogelijk zijn om kleinere en grotere tegels te tonen afhankelijk van de afstand tot het </li> <li>zichtpunt.</li> <li>TBC</li> </ul> </li> </ul>"},{"location":"docs/developers/tilekit/appendix-a-casussen/#a2-geojson","title":"A.2. GeoJSON","text":""},{"location":"docs/developers/tilekit/appendix-a-casussen/#a21-doel","title":"A.2.1. Doel","text":""},{"location":"docs/developers/tilekit/appendix-a-casussen/#a22-demonstreert","title":"A.2.2. Demonstreert","text":"<ul> <li>Impliciete vertegeling van een ongetegelde bron</li> <li>Inladen van een lokale databron</li> <li>Inladen van een externe databron</li> </ul>"},{"location":"docs/developers/tilekit/appendix-a-casussen/#a23-requirements","title":"A.2.3. Requirements","text":""},{"location":"docs/developers/tilekit/appendix-b-bronvermeldingen/","title":"Appendix B. Bronvermeldingen","text":""},{"location":"docs/developers/tilekit/appendix-b-bronvermeldingen/#b1-bronnen","title":"B.1. Bronnen","text":"<ul> <li>OGC 3D Tiles<ul> <li>3D Tiles - Implicit tiling in detail</li> </ul> </li> <li>OGC API - Tiles</li> <li>OGC API - Features<ul> <li>Specificatie</li> </ul> </li> <li>https://www.w3.org/TR/sdw-bp/#bib-iso-19101-1-2014</li> <li>OGC CQL</li> <li>Use ScriptableObjects as delegate objects</li> <li>Refactoring Guru - Strategy Design Pattern</li> </ul>"},{"location":"docs/developers/tilekit/appendix-b-bronvermeldingen/#b2-videos","title":"B.2. Videos","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/","title":"Appendix C. Begrippen","text":"<p>// TODO: https://github.com/CesiumGS/3d-tiles/blob/main/specification/README.adoc uitkammen en de begrippen hierin zetten, zoals refinement</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#bounding-volume","title":"Bounding Volume","text":"<p>Aliassen: Begrenzingsvolume.</p> <p>Een begrenzingsvolume is een geometrisch volume dat wordt gebruikt om de ruimtelijke omvang van een object of een verzameling objecten te beschrijven. Het wordt vaak gebruikt voor optimalisaties zoals zichtbaarheid, selectie en hi\u00ebrarchische structuren (zoals tile trees).</p> <p>Er zijn drie standaardtypen begrenzingsvolumes:</p> <ul> <li>Box (doosvormig volume): een rechthoekige doos in 3D-ruimte (axis-aligned of geori\u00ebnteerd).</li> <li>Sphere (bolvormig volume): een bol met een middelpunt en straal.</li> <li>Region (regiovormig volume): een complexere beschrijving die een geogra\ufb01sch gebied aanduidt, vaak gedefinieerd door   een rechthoekige uitsnede in lengte- en breedtegraden, met een minimale en maximale hoogte (bijvoorbeeld voor gebruik   op een globe).</li> </ul> <p>Begrenzingsvolumes worden voornamelijk gebruikt om snel te kunnen bepalen of een object zichtbaar is of moet worden ingeladen, zonder alle details van het object zelf te hoeven analyseren.</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#bucket","title":"Bucket","text":"<p>Een bucket is een slice van een groter, vooraf gealloceerd en gealigneerd blok geheugen dat Tilekit gebruikt om compacte, variabele-lengtestructuren effici\u00ebnt op te slaan. Buckets bieden een uniforme manier om gegevens die niet overal dezelfde grootte hebben \u2014 zoals children-lijsten, contents-lijsten of strings in een stringtable \u2014 toch in voorspelbare, contiguous geheugenblokken onder te brengen.</p> <p>Elke bucket vertegenwoordigt een segment van vaste capaciteit binnen een groter geheugenblok. Door deze opdeling kan Tilekit variabele hoeveelheden data opslaan zonder dynamische allocaties of herschalen van arrays. In plaats van per item nieuwe geheugenruimte te reserveren, verwijst een element simpelweg naar een bucket met voldoende capaciteit voor zijn children, contents of andere variabele velden. Dit zorgt voor een stabiel geheugenprofiel, voorkomt fragmentatie en maakt snelle indexgebaseerde toegang mogelijk.</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#capabilities","title":"Capabilities","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#cold-storage","title":"Cold Storage","text":"<p>Een gematerialiseerde view op de brondataset binnen een interessegebied. Cold Storage bevat minimale, gestandaardiseerde gegevens in SoA-vorm: bounding volumes, resolutiemaatstaven, tile-indices, inhoudsverwijzingen en metagegevens. Cold Storage dekt niet noodzakelijk de volledige dataset.</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#databron","title":"Databron","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#design-pattern-builder","title":"Design Pattern: Builder","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#design-pattern-factory","title":"Design Pattern: Factory","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#design-pattern-strategy","title":"Design Pattern: Strategy","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#digitaal-terrein-model-dtm","title":"Digitaal Terrein Model (DTM)","text":"<p>Aliassen: Maaiveld, Grondoppervlak, Digital Terrain Model</p> <p>Een Digitaal Terrein Model (DTM) is een digitale representatie van het aardoppervlak, inclusief de natuurlijke terreinvormen, exclusief bovengrondse objecten zoals gebouwen en vegetatie. Het model bestaat uit een reeks gegevenspunten die hoogte-informatie bevatten, waardoor een driedimensionaal beeld van het terrein kan worden gecre\u00eberd.</p> <p></p> <p>Meer informatie:</p> <ul> <li>https://www.eea.europa.eu/help/glossary/eea-glossary/digital-terrain-model</li> <li>https://nl.wikipedia.org/wiki/Digitaal_hoogtemodel</li> </ul>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#digitaal-oppervlakte-model-dsm","title":"Digitaal Oppervlakte Model (DSM)","text":"<p>Aliassen: Digitaal Hoogtemodel, Digital Surface Model</p> <p>Omvat het Digitaal Terrein Model (DTM) plus alle bovengrondse objecten op het aardoppervlak zoals gebouwen en vegetatie. Het model bestaat uit een reeks gegevenspunten die hoogte-informatie bevatten, waardoor een driedimensionaal beeld van het terrein kan worden gecre\u00eberd.</p> <p></p> <p>Meer informatie:</p> <ul> <li>https://www.eea.europa.eu/help/glossary/eea-glossary/digital-terrain-model</li> <li>https://nl.wikipedia.org/wiki/Digitaal_hoogtemodel</li> </ul>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#fragmentatie","title":"Fragmentatie","text":"<p>Het fenomeen waarbij geheugen versnipperd raakt door veel kleine allocaties en deallocaties. Fragmentatie kan leiden tot crashes in omgevingen met vaste geheugengrenzen zoals WebGL. Tilekit voorkomt fragmentatie met SoA-structuren, pools en preallocatie.</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#geoide","title":"Geoide","text":"<p>Aliassen: NAP (soort van)</p> <p>De geo\u00efde is het oppervlak op gemiddeld zeeniveau, waar dezelfde zwaartekrachtspotentiaal( inclusief de potentiaal van de middelpuntvliedende kracht door de draaiing van de Aarde) heerst: hetequipotentiaalvlak. Zonder getijden, wind en verschillen in watertemperatuur en zoutgehalte zou het waterniveau in zee dit oppervlak volgen.</p> <p>Geo\u00efdehoogten zijn de hoogten tussen de geo\u00efde en een referentie-ellipso\u00efdevan eengeodetisch co\u00f6rdinatensysteem, bijvoorbeeldWGS84,ETRS89.</p> <p>Meer informatie:</p> <ul> <li>https://nl.wikipedia.org/wiki/Geo%C3%AFde</li> </ul>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#geometric-error","title":"Geometric Error","text":"<p>De geometricError is een maat (in meters) die zegt hoe \"grof\" een tegel is in vergelijking met zijn fijnere kinderen. Het komt neer op: hoeveel detail je mist als je deze tegel toont in plaats van zijn onderliggende (meer gedetailleerde) tegels.</p> <p>Tijdens het draaien van de app gebruiken we deze geometricError om te bepalen of een tegel voldoende detail geeft op het scherm. Dat doen we door het om te rekenen naar screen space error (SSE) \u2013 dat is de fout uitgedrukt in pixels op je scherm.</p> <p>Bijvoorbeeld:</p> <ul> <li>Stel: een tegel heeft een geometricError van 50 meter.</li> <li>Als die 50 meter visueel overeenkomt met 10 pixels op het scherm, dan is de SSE = 10.</li> <li>Als je een maximum SSE van bijvoorbeeld 8 pixels hanteert, dan weet je: deze tegel moet worden vervangen door zijn   kinderen, want hij is niet precies genoeg.</li> </ul> <p>Waarom dit belangrijk is? Dit helpt het systeem beslissen wanneer het moet inzoomen naar meer detail (kindtegels laden), of wanneer een grove weergave prima is (ouders tonen).</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#hlod","title":"HLOD","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#hot-tile","title":"Hot Tile","text":"<p>De daadwerkelijke, gematerialiseerde representatie in Unity. Hot tiles zijn zichtbaar in de sc\u00e8ne en gebruiken renderers, GPU-buffers, GameObjects of andere renderingmechanismen afhankelijk van het archetype.</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#getegelde-laag","title":"Getegelde laag","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#idempotent","title":"Idempotent","text":"<p>Idempotentie is de eigenschap van een object (of systeem) en/of een operatie daarop dat het object niet meer verandert als de operatie nogmaals wordt uitgevoerd.</p> <p>Bron: https://nl.wikipedia.org/wiki/Idempotentie</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#interessegebied","title":"Interessegebied","text":"<p>Het ruimtelijke gebied waarin Cold Storage wordt opgebouwd. Dit gebied omvat meer dan alleen de huidige cameraview, maar hoeft niet de volledige dataset te dekken. Het bepaalt de subset van tiles die Tilekit beschikbaar houdt voor selectie.</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#lagensysteem","title":"Lagensysteem","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#layerdata","title":"LayerData","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#mapping","title":"Mapping","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#materialisatie","title":"Materialisatie","text":"<p>Het proces waarbij een DataSet gegevens uit de databron ophaalt en omzet in de gestandaardiseerde Cold Storage-structuur van Tilekit. Materialiseren gebeurt uitsluitend voor de Cold Storage en betreft het vullen of bijwerken van de SoA-georganiseerde gegevens voor alle tiles binnen het interessegebied.</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#material-view","title":"Material View","text":"<p>Een concept uit databankterminologie dat beschrijft dat Cold Storage niet een kopie is van de brondata, maar een voorgematerialiseerde, performante view daarvan, gericht op snelle toegang.</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#memory-alignment","title":"Memory Alignment","text":"<p>De praktijk waarbij data op voorspelbare grenzen in het geheugen wordt geplaatst. Alignment bevordert performance, minimaliseert fragmentatie en maakt bulkoperaties effici\u00ebnter. In Tilekit worden cold data en buffers structureel gealigneerd.</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#midden-van-het-scherm","title":"Midden van het Scherm","text":"<p>Het midden van het scherm betekent concreet het punt in de viewport waar de camera naar kijkt, op de hoogte van het digitale terreinmodel (DTM), en als er geen digitaal terrein model aanwezig voor de gegeven lokatie: de hoogte van de [[#Geoide]].</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#nap-hoogte","title":"NAP hoogte","text":"<p>Zie: [[Orthometrische hoogte]]</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#orthometrische-hoogte","title":"Orthometrische hoogte","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#preallocatie","title":"Preallocatie","text":"<p>Het vooraf toewijzen van geheugen voor datastructuren die tijdens runtime nodig zijn. Tilekit verdeelt geheugen voor cold, warm en hot paden grotendeels v\u00f3\u00f3r runtime, waardoor allocaties tijdens de tile-levenscyclus worden voorkomen.</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#pools","title":"Pools","text":"<p>Herbruikbare verzamelingen van objecten, buffers of structuren die telkens opnieuw worden gebruikt in plaats van opnieuw gealloceerd. Pools zijn essentieel voor stabiliteit en performance in Tilekit.</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#screen-space-error-sse","title":"Screen Space Error (SSE)","text":"<p>De screen space error is een maat voor hoe zichtbaar een geometrische afwijking is op het scherm, uitgedrukt in pixels. Het wordt gebruikt om te bepalen of een object (zoals een tegel in een hi\u00ebrarchie) voldoende detail heeft op basis van de afstand tot de camera. Een hogere SSE betekent dat het detailverlies zichtbaar is voor de gebruiker, wat aangeeft dat een meer gedetailleerde versie (bijvoorbeeld kindtegels) ingeladen moet worden.</p> <p>De berekening is gebaseerd op de <code>geometricError</code> (een waarde in meters die de detailafwijking beschrijft) en de afstand tot de camera. De standaardformule is:</p> <pre><code>SSE = (geometricError / distanceToCamera) * schermProjectieFactor\n</code></pre> <p>Waarbij:</p> <ul> <li><code>geometricError</code> de maximale fout in wereldco\u00f6rdinaten is (bijvoorbeeld 50 meter),</li> <li><code>distanceToCamera</code> de afstand tot de camera is in meters,</li> <li><code>schermProjectieFactor</code> een constante factor is die afhangt van het schermformaat en de field of view.</li> </ul> <p>schermProjectieFactor is 1</p> <p>In onze situatie is <code>schermProjectieFactor</code> gelijk aan 1, dus de formule wordt vereenvoudigd tot:</p> <pre><code>SSE = geometricError / distanceToCamera\n</code></pre> <p>De keuze voor deze constante is omwille van performance en omdat een dergelijke mate van accuraatheid niet nodig is. </p> <p>Deze waarde wordt vergeleken met een ingestelde grenswaarde (<code>maximumScreenSpaceError</code>). Als de SSE groter is dan deze grens, moet een meer gedetailleerde versie worden geladen.</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#spatial-coherence","title":"Spatial Coherence","text":"<p>De gezamenlijke inhoud van alle kindtegels valt volledig binnen het begrenzingsvolume van de oudertegel.</p> <p>Dat betekent niet dat het hele begrenzingsvolume (zie Bounding Volume) van de oudertegel opgevuld moet zijn, maar wel dat de kindtegels niet buiten de grenzen van hun ouder mogen uitsteken.</p> <p>Kindtegels mogen elkaar onderling wel overlappen, zoals te zien is in deze afbeelding:</p> <p></p> <p>Zie https://portal.ogc.org/files/102132#core-bounding-volume-spatial-coherence voor meer informatie.</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#structure-of-arrays-soa","title":"Structure of Arrays (SoA)","text":"<p>Een geheugenindeling waarbij elk attribuut in een eigen lineaire array staat. SoA voorkomt fragmentatie, verbetert cachegedrag en maakt tile-selectie en diffing snel en voorspelbaar. Tilekit gebruikt SoA in Cold Storage en in delen van warm data.</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#tick","title":"Tick","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#tile","title":"Tile","text":"<p>Aliassen: Tegel</p> <p>Een tile is de kleinste ruimtelijke eenheid binnen Tilekit waarmee data uit een dataset wordt gestructureerd, geadresseerd en geselecteerd. Tiles vormen een uniforme abstractie over uiteenlopende databronnen, ongeacht of deze getegeld of ongetegeld zijn.</p> <p>Officiele OGC Definitie:</p> <p>[!quote] Bron: https://docs.ogc.org/is/20-057/20-057.html#term-tile Geometrische vorm met bekende eigenschappen die al dan niet het resultaat zijn van een betegelingsproces ( tessellatie). Een tegel bestaat uit een enkel samenhangend \u201cstuk\u201d zonder \u201cgaten\u201d of \u201clijnen\u201d (topologische schijf).</p> <p>In de context van een 2D-tegelmatrix is een tegel een van de rechthoekige gebieden in de ruimte, die uniek ge\u00efdentificeerd kan worden door rij- en kolomindices, welke samen de tegelmatrix vormen.</p> <p>In de context van een geospatiale data-tegelset bevat een tegel gegevens voor een dergelijke ruimtelijke indeling als onderdeel van een overkoepelende set tegels voor die betegelde geospatiale data.</p> <p>Een tile vertegenwoordigt altijd een ruimtelijk gebied (bijv. een bounding volume, quad, polygoon of andere ruimtebeschrijving) en verwijst naar de data die binnen dat gebied beschikbaar is. De tile bevat geen inhoud zelf, maar metadata en verwijzingen waarmee Tilekit kan bepalen:</p> <ul> <li>waar de tile zich ruimtelijk bevindt,</li> <li>welk detailniveau of resolutieniveau de tile vertegenwoordigt,</li> <li>welke children of parent-tiles eraan gekoppeld zijn (indien aanwezig),</li> <li>welke inhoud binnen de tile kan worden aangeboden (rasterbeelden, features, geometrie, etc.).</li> </ul> <p>Tiles in Tilekit komen altijd voort uit de Cold Storage: de gematerialiseerde view op een dataset binnen het interessegebied. Vanuit Cold Storage kan Tilekit tiles selecteren, prioriteren en verwerken zonder kennis van het onderliggende protocol of bestandsformaat.</p> <p>Omdat alle datasets dezelfde tile-abstractie gebruiken, kunnen Archetypes en DataSets uniform werken:</p> <ul> <li>DataSets bepalen hoe tiles uit de bron worden afgeleid,</li> <li>Archetypes bepalen hoe de inhoud van tiles moet worden ge\u00efnterpreteerd en weergegeven.</li> </ul> <p>Kort gezegd:</p> <p>Een tile is de ruimtelijke en structurele drager van informatie in Tilekit, en vormt het centrale ankerpunt waarop selectie, verwerking en visualisatie worden gebaseerd.</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#tileset","title":"TileSet","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#tile-lifecycle-cold-warm-hot","title":"Tile Lifecycle (Cold \u2192 Warm \u2192 Hot)","text":"<p>Het proces waarin tiles achtereenvolgens worden:</p> <ul> <li>opgenomen in Cold Storage,</li> <li>voorbereid als Warm Tile,</li> <li>en gevisualiseerd als Hot Tile.</li> </ul> <p>Deze lifecycle vormt het fundament van Tilekit\u2019s ontwerp.</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#tile-selection","title":"Tile Selection","text":"<p>Het proces waarin Tilekit bepaalt welke tiles relevant zijn op basis van camera, resolutie, afstand, tijdsaspecten of andere criteria. Tile selection werkt uitsluitend binnen het interessegebied (Cold Storage).</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#visualisatie","title":"Visualisatie","text":""},{"location":"docs/developers/tilekit/appendix-c-begrippen/#warm-tile","title":"Warm Tile","text":"<p>De set dataset-specifieke resources die nodig zijn om een tile snel hot te kunnen maken, zoals textures, meshes, attributen of polygonbuffers. Warm tiles worden opgebouwd vanuit cold data, maar zijn nog niet actief in de sc\u00e8ne.</p>"},{"location":"docs/developers/tilekit/appendix-c-begrippen/#zichtpunt","title":"Zichtpunt","text":"<p>De lokatie in de wereld waar de camera naar kijkt; in tegenstelling tot de camerapositie is deze lokatie waarschijnlijk middenin de viewport en de lokatie met het hoogste detailniveau en prioriteit van inladen.</p> <p>Deze lokatie representeert datgeen waar de aandacht van de gebruiker naartoe gaat.</p>"},{"location":"docs/developers/tilekit/appendix-d-frequently-asked-questions/","title":"Appendix d frequently asked questions","text":""},{"location":"docs/developers/tilekit/appendix-d-frequently-asked-questions/#appendix-d-frequently-asked-questions","title":"Appendix D. Frequently Asked Questions","text":""},{"location":"docs/developers/tilekit/appendix-d-frequently-asked-questions/#d1-databronnen-met-meerdere-lagen","title":"D.1. Databronnen met meerdere lagen","text":"<p>Tilekit zelf biedt geen faciliteit om iets te doen met databronnen met meerdere lagen, in Tilekit wordt aangenomen dat dit in de functionaliteit zelf gebeurd. </p> <p>In de afbeelding hiernaast kan je een voorbeeld flow zien waarbij de WMS functionaliteit de een TileSet definitie  opbouwt vanuit de capabilities van de WMS service zelf.</p> <p>In deze zelfde afbeelding is ook te zien hoe Tilekit omgaat met authenticatie, ook hierbij maken we gebruik van de  bestaande authenticatie systemen en kan je Tilekit een sjabloon request -inclusief credentials- aanmaken. </p> <p>Door deze scheiding van verantwoordelijkheden kan Tilekit flexibel omgaan met allerlei vormen van services.</p>"},{"location":"docs/developers/tilekit/architectuur-in-vogelvlucht/","title":"Architectuur in Vogelvlucht","text":"<p>Tilekit is opgebouwd vanuit \u00e9\u00e9n overkoepelend principe: elke ruimtelijke dataset\u2014ongeacht formaat, protocol of domein\u2014kan worden teruggebracht tot dezelfde driedelige levenscyclus van koud \u2192 warm \u2192 hot. Deze cyclus bepaalt hoe data wordt opgeslagen, voorbereid en uiteindelijk gematerialiseerd voor visualisatie.</p> <p>De architectuur maakt hierbij een strikt onderscheid tussen protocol-onafhankelijke visualisatieconcepten ( Archetypes) en protocol-afhankelijke datastromen (DataSets). Deze scheiding vormt de kern van Tilekits uitbreidbaarheid en schaalbaarheid.</p>"},{"location":"docs/developers/tilekit/architectuur-in-vogelvlucht/#1-dataopslag-cold-warm-en-hot","title":"1. Dataopslag: Cold, Warm en Hot","text":"<p>Tilekit hanteert drie niveaus van materialisatie:</p> <ul> <li>Cold Storage is een gematerialiseerde view van de brondataset binnen een interessegebied. Dit gebied is   groter dan de cameraview, maar omvat niet noodzakelijk de volledige dataset. In deze laag staan alleen de minimale,   gestandaardiseerde gegevens (bounding volumes, resolutiemaatstaven, metadata, verwijzingen naar content) in een   SoA-structuur.</li> <li>Warm Tiles bevatten de dataset-specifieke resources die nodig zijn om tiles snel zichtbaar te maken (zoals   textures, meshes, polygonbuffers of feature-attributen).</li> <li>Hot Tiles zijn de daadwerkelijk actieve representaties in de Unity-sc\u00e8ne.</li> </ul> <p>Deze scheiding zorgt ervoor dat Tilekit nauwkeurig kan bepalen welke data moet worden voorbereid of gevisualiseerd, zonder onnodige belasting van geheugen of CPU.</p>"},{"location":"docs/developers/tilekit/architectuur-in-vogelvlucht/#2-archetypes-protocol-onafhankelijke-visualisatiefamilies","title":"2. Archetypes: Protocol-onafhankelijke visualisatiefamilies","text":"<p>Archetypes vormen de basis van Tilekits visualisatiearchitectuur.</p> <p>Een Archetype beschrijft hoe een bepaald type ruimtelijke informatie moet worden behandeld en gevisualiseerd, los van waar die informatie vandaan komt. Voorbeelden:</p> <ul> <li>RasterArchetype: werkt met beelden en texturen, ongeacht of ze uit WMS, WMTS, PNG-bestanden of iets anders komen.</li> <li>VectorArchetype: tekent features als polygonen of lijnen, los van het protocol waarmee deze features zijn   verkregen.</li> <li>MeshArchetype: gaat om met 3D-geometrie, onafhankelijk van het bestandsformaat of domein.</li> <li>Eventuele nieuwe archetypes (bijv. voor voxels, point cloud tiles, multi-temporal lagen) kunnen eenvoudig worden   toegevoegd.</li> </ul> <p>Kenmerkend is dat een Archetype:</p> <ul> <li>het fundament biedt voor warm en hot tiles,</li> <li>weet hoe data moet worden voorbereid en gerenderd,</li> <li>maar niets weet over protocols, endpoints of bestandsindelingen.</li> </ul> <p>Archetypes zijn dus universele visualisatiebouwblokken.</p>"},{"location":"docs/developers/tilekit/architectuur-in-vogelvlucht/#3-datasets-protocol-afhankelijke-bronnen","title":"3. DataSets: Protocol-afhankelijke bronnen","text":"<p>DataSets zijn de onderdelen die de daadwerkelijke communicatie met de bron verzorgen.</p> <p>Waar Archetypes bepalen hoe iets getekend wordt, bepaalt een DataSet:</p> <ul> <li>hoe de data moet worden opgehaald</li> <li>welke protocollen worden gebruikt</li> <li>welke parameters gelden voor tilebeschikbaarheid, queries of filtering</li> <li>hoe de bron wordt vertaald naar de gestandaardiseerde tile-structuur van het Archetype</li> </ul> <p>Example</p> <p>Voorbeelden:</p> <ul> <li>Een WMS DataSet spreekt het WMS-protocol, bouwt requests op, doet de netwerkcommunicatie en ontvangt de   afbeeldingen. De uiteindelijke verwerking en visualisatie daarvan gebeurt in het RasterArchetype.</li> <li>Een 3D Tiles DataSet decodeert tilesets en b3dm/PNTS-content, maar het MeshArchetype bepaalt hoe die   geometrie als warm/hot tile verschijnt.</li> <li>Een GeoJSON DataSet haalt features op en vertaalt deze naar cold/warm data, maar het VectorArchetype bepaalt   hoe deze features worden getekend.</li> </ul> <p>DataSets verzorgen dus de glue-code tussen Tilekit en de buitenwereld, terwijl Archetypes de consistente visualisatielaag vormen.</p>"},{"location":"docs/developers/tilekit/architectuur-in-vogelvlucht/#4-besturing-van-de-levenscyclus","title":"4. Besturing van de levenscyclus","text":"<p>Elke DataSet beheert de lifecycle binnen zijn interessegebied:</p> <ul> <li>bepalen welk deel van de bron - en hoe - moet worden gematerialiseerd naar Cold Storage,</li> <li>bepalen welke tiles warm moeten worden,</li> <li>bepalen welke tiles hot moeten worden,</li> <li>bepalen wanneer resources moeten worden opgeruimd.</li> </ul> <p>De DataSet gebruikt dus het fundament van het Archetype om de lifecycle in goede banen te leiden.</p>"},{"location":"docs/developers/tilekit/architectuur-in-vogelvlucht/#5-extensiepunten-in-de-architectuur","title":"5. Extensiepunten in de architectuur","text":"<p>De architectuur is modulair opgebouwd en biedt uitbreidingsmogelijkheden op drie niveaus:</p> <ol> <li>Nieuwe Archetypes \u2192 nieuwe visualisatiefamilies</li> <li>Nieuwe DataSets \u2192 nieuwe protocollen en bronnen</li> <li>Nieuwe content loaders \u2192 nieuwe bestands- of streamformaten</li> </ol> <p>Deze scheiding voorkomt dat protocolcode zich vermengt met visualisatiecode, en maakt Tilekit geschikt voor zowel bestaande als toekomstige datastromen.</p>"},{"location":"docs/developers/tilekit/data-opslag/","title":"Dataopslag","text":"<p>Tilekit is gebouwd op een gelaagd opslagmodel waarin tegels zich in drie hoofdcondities kunnen bevinden: koud,  warm en heet. Deze drie lagen gebruiken hetzelfde tile-begrip, maar verschillen in hoeveel informatie er is  opgeslagen en welke resources zijn gekoppeld.</p> <p>Op hoog niveau kun je de opslaglagen zo zien:</p> <pre><code>flowchart LR\n    DataSource[Databron]\n    Cold[Cold storage tegels binnen interessegebied]\n    Warm[Warm data rond camera]\n    Hot[Hot data in frustum]\n    DataSource --&gt; Cold --&gt; Warm --&gt; Hot --&gt; Warm --&gt; Cold</code></pre> <ul> <li>Cold storage bevat de minimale gegevens om tegels te herkennen en te selecteren binnen een interessegebied.</li> <li>Warm data voegt verwijzingen naar inhoud toe, zoals textures of meshes, voor tegels rond de camera.</li> <li>Hot data zijn de tegels waarvan de inhoud daadwerkelijk gevisualiseerd wordt omdat ze in beeld zijn.</li> </ul> <p>De rest van dit hoofdstuk werkt deze drie lagen verder uit.</p>"},{"location":"docs/developers/tilekit/data-opslag/#ruimte-tijd-en-resolutie-waarom-tegels-vijf-dimensies-hebben","title":"Ruimte, Tijd en Resolutie: Waarom Tegels Vijf Dimensies Hebben","text":"<p>Voordat we verder gaan met de inhoud, eerst even een moment om wat context te geven over de selectie van ruimtelijke \"objecten\".</p> <p>Objecten \u2014 tegels \u00e9n features \u2014 hebben een \"omvang\" in vijf dimensies: </p> <ul> <li>de drie ruimtelijke dimensies (X, Y, Z), </li> <li>het tijdsbereik waarin ze bestaan, en </li> <li>het resolutiebereik waarin ze zichtbaar -of zinvol- zijn. </li> </ul> <p>Dat betekent dat elk object niet \u00e9\u00e9n punt is, maar een 5-dimensionale volume: op welke plek met welke breedte, diepte en hoogte,  wanneer het bestaat, en in welk detailniveau het betekenisvol is.</p> <p>De camera definieert een 4-dimensionaal zichtbaar gebied in de wereld: de ruimtelijke zone die via de viewport  zichtbaar is, plus het tijdstip waarin de gebruiker kijkt. Binnen dat zichtbare gebied geldt: elk punt bepaalt zijn eigen resolutiedimensie, omdat de benodigde resolutie voortkomt uit de screen space error van dat punt \u2014 een directe afgeleide van de afstand tussen het punt en de camera.</p> <p>Een voorbeeld maakt dit direct duidelijk: </p> <p>Voorbeeld: De Windmolen</p> <p>Stel je voor dat de camera op een vast punt in de wereld gericht is en er een windmolen als object is. Dan is deze  windmolen zichtbaar (in beeld) als zijn positie op de X-, Y- of Z-as binnen camerabeeld valt. Dat is zichtbaarheid  in 3 dimensies.</p> <p>Stel je nu voor dat tijd een factor is en het beeld van de camera genomen is op een specifieke datum. Dan is de  windmolen alleen zichtbaar als deze gebouwd is voor deze datum, en gesloopt is na deze datum. Dit is zichtbaarheid in  4 dimensies. Want de windmolen zijn bestaansduur moet overlap hebben met dat moment in tijd.</p> <p>Stel je nu voor dat we naar hetzelfde punt blijven kijken - maar dat we uitzoomen. Dan gaat er een moment zijn waarop de windmolen niet meer zichtbaar is omdat je zover bent uitgezoomd dat deze te klein is geworden. Dit is zichtbaarheid in  5 dimensies, waarbij de 5de dimensie resolutie is. Het object is onzichtbaar als de resolutie van het beeldpunt niet  meer binnen het resolutiebereik van die windmolen ligt.</p> <p>Zo bepaalt Tilekit voor elke tegel: is hij op deze plek, op dit moment, \u00e9n op deze resolutie relevant?</p>"},{"location":"docs/developers/tilekit/data-opslag/#cold-storage","title":"Cold storage","text":"<p>Cold storage is een gematerialiseerde view van de databron binnen een interessegebied.</p> <p>Info</p> <p>Het interessegebied is een tweedimensionaal ruimtelijk gebied (bijvoorbeeld een deel van Nederland in projectie)  dat:</p> <ul> <li>groter is dan de actuele cameraview,</li> <li>maar niet noodzakelijk de volledige dataset omvat.</li> </ul> <p>Dit interessegebied is een grotere regio waarin we de data van tegels beschikbaar willen hebben rondom het camera  punt omdat het materialiseren van de informatie een kostbare operatie is op de CPU.</p> <p>Binnen dit gebied worden alle tegels gematerialiseerd voor alle relevante dimensies:</p> <ul> <li>drie ruimtelijke dimensies</li> <li>resolutie, uitgedrukt als geometrische error</li> <li>de temporele dimensie</li> </ul> <p>Met andere woorden: de set koude tegels is de verzameling van alle tegels binnen het interessegebied valt, ongeacht  resolutieniveau of tijd.</p> <p>Cold storage slaat alleen de minimale gegevens op die nodig zijn om:</p> <ul> <li>een tegel ruimtelijk en structureel te identificeren,</li> <li>de resolutie en eventuele tijdsdimensie te kennen,</li> <li>naar children en inhoud te kunnen verwijzen.</li> </ul> <p>Er wordt g\u00e9\u00e9n daadwerkelijke content (zoals Texture2D of Mesh) opgeslagen in cold storage.</p> <p>Question</p> <p>Als het interessegebied de tweedimensionele representatie is met tegels van alle resoluties en tijdstippen - worden dat teveel tegels? Of moet er ook qua resolutie en tijdstippen een interessegebied zijn rondom de huidige resolutie en het huidige tijdstip. </p>"},{"location":"docs/developers/tilekit/data-opslag/#structuur-van-cold-storage","title":"Structuur van cold storage","text":"<p>Cold storage gebruikt een Structure of Arrays (SoA) benadering: elk  veld - met een vaste afmeting - van een tegel heeft zijn eigen lineaire array. Denk bijvoorbeeld aan:</p> <ul> <li><code>BoundingVolume[]</code> - Bounding Volume struct die een Region, Box of Sphere bounding volume representeert</li> <li><code>GeometricError[]</code> - een double waarde die de resolutie van de tegel representeert</li> <li><code>StartTime[]</code> - een 64-bits integer Unix Timestamp die het aantal microseconden sinds 1970-01-01 representeert in UTC.</li> <li><code>EndTime[]</code> - een 64-bits integer Unix Timestamp die het aantal microseconden sinds 1970-01-01 representeert in UTC.</li> <li><code>ChildrenStart[]</code>, <code>ChildrenCount[]</code> - een integer en shortint die beschrijft hoe kinderen uit de buffer te halen.</li> <li><code>ContentsStart[]</code>, <code>ContentsCount[]</code> - een integer en shortint die beschrijft hoe content informatie uit de buffer te halen.</li> </ul> <p>Wat bedoelen we met 'veld met vaste afmeting'?</p> <p>Denk aan een getal, boolean, struct, of ander type met een vaste grootte in geheugen. Ook een array met een vast  aantal elementen heeft een vaste afmeting. Strings, aantal kindertegels of een array met \"content\" is een dynamische structuur en zal in een buffer moeten worden opgeslagen waarbij de start en lengte in de buffer als veld in zijn  eigen lineair array moet worden opgeslagen.</p> <p>Elke tegel heeft een TileIndex (een integer). Die index wordt gebruikt om in al deze arrays de juiste rij op te  halen. Deze TileIndex is niet een opgeslagen waarde - maar is de index in elk lineair array. Dat betekent dus dat elk  van deze lineaire arrays een lengte hebben gelijk aan het maximale aantal tegels dat in de Cold Storage kan zitten. </p>"},{"location":"docs/developers/tilekit/data-opslag/#buckets-voor-children-en-contents","title":"Buckets voor children en contents","text":"<p>Niet elke tegel heeft evenveel children of content elementen. Cold storage gebruikt daarom \u00e9\u00e9n onderliggende lijst per  type, met daarboven een segmentindeling in buckets.</p> <ul> <li>De onderliggende lijst wordt bijvoorbeeld opgeslagen in een <code>NativeList&lt;int&gt;</code> met alle children indices achter elkaar.</li> <li> <p>Een bucket is dan een segment in deze lijst, gedefinieerd door:</p> <ul> <li>een startindex - zoals <code>ChildrenStart</code>.</li> <li>een lengte - zoals <code>ChildrenCount</code>.</li> </ul> </li> </ul> <p>Per tegel worden alleen de <code>start</code> en <code>count</code> opgeslagen; de daadwerkelijke entries staan in de gedeelde lijst.</p> <ul> <li>De bucket zelf is dus geen apart blok geheugen, maar een logische slice van een groter blok middels een    <code>NativeSlice</code> object in Unity/C#.</li> <li>Dit patroon wordt ook gebruikt voor contents of andere structuren met een variabele lengte.</li> </ul> <p>Door deze aanpak:</p> <ul> <li>blijven children en contents compact opgeslagen,</li> <li>zijn er geen reallocaties nodig als individuele tegels meer of minder children hebben,</li> <li>blijft de opslag pointer-vrij en index-gebaseerd.</li> </ul>"},{"location":"docs/developers/tilekit/data-opslag/#warm-data","title":"Warm data","text":"<p>Warm data vormt de tussenschakel tussen de minimale informatie in cold storage en de daadwerkelijke visualisatie in hot data.</p>"},{"location":"docs/developers/tilekit/data-opslag/#wat-is-warm-data","title":"Wat is warm data?","text":"<p>Zodra een tegel relevant wordt rondom de camera (maar nog niet in beeld is) wordt deze warm:</p> <ul> <li>de tegel blijft in cold storage bestaan met dezelfde TileIndex,</li> <li>er wordt aanvullende data -de content- geladen die nodig is om de tegel snel heet te kunnen maken,</li> <li> <p>deze aanvullende data bestaat uit bijvoorbeeld:</p> <ul> <li>Texture2D objecten voor rasterdata</li> <li>gedeelde meshstructuren of vertexbuffers</li> <li>voorbereide attributen of indices</li> </ul> </li> </ul> <p>In de warme laag wordt dus vooral een handle opgeslagen:</p> <ul> <li>een verwijzing naar een Texture2D in een pool,</li> <li>een index naar een meshbuffer,</li> <li>of een soortgelijke verwijzing naar content.</li> </ul> <p>De tegel in warm data kan worden gezien als:</p> <ul> <li>dezelfde TileIndex als in cold storage,</li> <li>plus een set handles naar content die extern beheerd wordt.</li> </ul> <p>Het doel hiervan is dat tegels snel gevisualiseerd kunnen worden door het \"preloaden\" van de content. Het binnenhalen van content, zoals een GLB of PNG bestand, kan wel tot enkele seconden duren. Door buiten beeld te doen is de gebruikers ervaring vloeiender, en verbruikt de applicatie minder bandbreedte.</p> <p>De verwachting is dat het downloaden van content bestanden ook in de browser cache wordt opgeslagen - dus zonder dat  daar WASM heap voor hoeft te worden ingenomen - en dat betekent dat her-downloaden van content dus potentieel sneller gaat dan de initi\u00eble download. De content die ingeladen is bij een warme tegel staat wel in de WASM heap.</p>"},{"location":"docs/developers/tilekit/data-opslag/#warm-regio-in-de-5d-ruimte","title":"Warm regio in de 5D ruimte","text":"<p>Warm data kun je zien als een 5-dimensionale bounding volume rondom de gebruiker:</p> <ul> <li>drie ruimtelijke dimensies (waar bevind ik me)</li> <li>resolutie (welke detailniveaus houden we in de buurt paraat)</li> <li>tijd (welke tijdslagen moeten rondom de gebruiker snel beschikbaar zijn)</li> </ul> <p>De set warme tegels is dus een subset van alle koude tegels, beperkt door een 5D-volume rond de gebruiker en de huidige situatie.</p> <p>De ruimte die de warm regio in beslag neemt is geheugen-intensief, door de grootte van deze regio dynamisch te  maken is het mogelijk om een stricter geheugen-budget toe te passen door de regio te verkleinen en daarmee minder tegels  warm te houden. Dit gaat ten kostte van de laadsnelheid van een laag, maar voorkomt problemen door geheugengebrek.</p>"},{"location":"docs/developers/tilekit/data-opslag/#hot-data","title":"Hot data","text":"<p>Hot data zijn de tegels die daadwerkelijk worden gevisualiseerd, omdat ze in de camera frustum liggen.</p>"},{"location":"docs/developers/tilekit/data-opslag/#wat-is-hot-data","title":"Wat is hot data?","text":"<p>Een tegel wordt heet zodra:</p> <ul> <li>zijn ruimtelijke projectie overlapt met het frustum,</li> <li>zijn temporele dimensie overeenkomt met de geselecteerde tijd,</li> <li>en zijn resolutie passend is bij de gewenste schermfout (screen space error).</li> </ul> <p>In de hot laag wordt de eerder voorbereidde content uit warm data daadwerkelijk gebruikt om de content te visualiseren  door bijvoorbeeld:</p> <ul> <li>middels de Graphics API de content te renderen</li> <li>of GameObjects / renderstructuren uit een pool te halen en te activeren.</li> </ul> <p>Hot data is daarmee het eindpunt in de keten:</p> <ol> <li>Cold: minimale metadata en structuur binnen interessegebied</li> <li>Warm: content-handles rond de camera</li> <li>Hot: directe visualisatie in het frustum</li> </ol>"},{"location":"docs/developers/tilekit/data-opslag/#hot-regio-in-de-4d-ruimte","title":"Hot regio in de 4D ruimte","text":"<p>De viewport van de gebruiker kun je zien als een 4-dimensionale ruimte:</p> <ul> <li>drie ruimtelijke dimensies</li> <li>\u00e9\u00e9n temporele dimensie</li> </ul> <p>Binnen deze ruimte bepaalt Tilekit aan de hand van screen space error welke resolutie van een tegel hot moet worden. Dat wil zeggen:</p> <ul> <li>een punt in het frustum heeft een bepaalde fout op schermniveau,</li> <li>op basis daarvan kiest Tilekit welke tegel hot moet worden middels de combinatie van ruimtelijke positie, resolutie    en tijd.</li> </ul>"},{"location":"docs/developers/tilekit/data-opslag/#samenvatting","title":"Samenvatting","text":"<p>In dit hoofdstuk hebben we de dataopslag van Tilekit beschreven als een gelaagd systeem:</p> <ul> <li> <p>Cold Storage</p> <ul> <li>gematerialiseerde view van de databron binnen een 2D interessegebied,</li> <li>alle resoluties en tijdslagen binnen het interessegebied.</li> <li>SoA-georganiseerde velden,</li> <li>dynamische-length structuren via segmenten in gedeelde lijsten,</li> </ul> </li> <li> <p>Warm data</p> <ul> <li>subset van koude tegels in een 5D-volume rond de gebruiker,</li> <li>content-handles vooraf geladen zodat tegels snel heet kunnen worden.</li> </ul> </li> <li> <p>Hot data</p> <ul> <li>tegels in een 4D viewport,</li> <li>met passende resolutie,</li> <li>waarvan de content daadwerkelijk wordt gerenderd.</li> </ul> </li> </ul> <p>Deze opslaglagen vormen samen de basis waarop later de selectie-algoritmen, prioritering en lifecycle-logica verder worden uitgewerkt.</p>"},{"location":"docs/developers/tilekit/features/","title":"Features","text":""},{"location":"docs/developers/tilekit/features/#features","title":"Features","text":""},{"location":"docs/developers/tilekit/features/#wat-is-een-feature","title":"Wat is een feature?","text":"<p>Een abstractie van re\u00eble wereldverschijnselen. Een digitale representatie van een echt bestaande entiteit of een abstractie van de re\u00eble wereld. Voorbeelden van features zijn bijna alles wat in tijd en ruimte geplaatst kan worden, waaronder bureaus, gebouwen, steden, bomen, bospercelen, ecosystemen, bezorgvoertuigen, sneeuwruimroutes, oliebronnen, oliepijpleidingen, olielekkage, enzovoort. De termen feature en object worden vaak door elkaar gebruikt.</p> <p>Bronnen:</p> <ul> <li>ISO-19101-1-2014 - Geographic information -- Reference model -- Part 1: Fundamentals</li> <li>W3C-SDW#feature</li> </ul> <p>Info</p> <p>Een van de beste vertalingen naar het Nederlands is het woord \"Kenmerk\"; hoewel een exacte vertaling van het woord Feature niet in het Nederlands voorkomt. Als gevolg daarvan zal in dit document het woord Feature gebruikt worden.</p>"},{"location":"docs/developers/tilekit/features/#doelen","title":"Doelen","text":"<ul> <li>Ondersteunt 3D en 2D data</li> <li>Gemakkelijk uit te breiden met ondersteuning voor nieuwe GIS formaten</li> <li>Vergemakkelijkt implementaties van WFS en OGC API : Features omdat deze formaten   feature-first zijn en niet tegel-first</li> <li>Spatial querying<ul> <li>Important: Datasets have features - real or not</li> <li>https://www.youtube.com/watch?v=vxZx_PXo-yo&amp;t=2s</li> <li>Jobs/Burst - een findAll doet een Depth First Search; elke branch in de tree kan in parallel; werkt mogelijk niet   in WebGL - experiment nodig</li> <li>Promise-based? Dat een search in basis asynchroon is en over frames uitgesmeerd kan worden in WebGL</li> <li>Search in this area - Google Maps zoekt op features in het huidige zoekgebied</li> <li>Querying kan als geheel - maar ook in een tile. Als het een tile is, dan kan een lijst gelooped worden<ul> <li>Of kunnen we bij het inlezen van een tile deze onderverdelen middels een grid of quadtree en de features   spatial onderverdelen zodat we hier ook een Depth First Search kunnen doen?</li> </ul> </li> <li>Map/Reduce patroon om te filteren?<ul> <li>https://www.youtube.com/watch?v=gX5nD2LeAvQ - ZLinq</li> </ul> </li> </ul> </li> <li>https://portal.ogc.org/files/96288 CQL</li> <li>Temporele ondersteuning - als de tijd wijzigt van de applicatie kan de URL beinvloed worden<ul> <li>WFS: Queryen op tijdgebaseerde attributen - Zie https://docs.ogc.org/is/17-069r4/17-069r4.html#_identifiers</li> <li>Hele URL, zoals Amsterdam Time Machine</li> <li>https://docs.ogc.org/is/20-057/20-057.html#toc52</li> </ul> </li> <li>Wat te doen met overlappende features, zoals gebouwen die kort op elkaar zitten? die kunnen dubbel voor gaan komen   of we moeten bijhouden op welke tegels (meervoud) een feature kan voorkomen. Die moet dan ook pas opgeruimd worden   zodra alle gerelateerde tegels uit beeld zijn. Maar hoe bepalen we of een feature dubbel is?</li> </ul>"},{"location":"docs/developers/tilekit/memory-management/","title":"Memory Management \u2013 Overzicht","text":"<p>Tilekit is ontworpen voor omgevingen waarin grote datasets effici\u00ebnt en voorspelbaar moeten worden verwerkt. Omdat Unity\u2014en met name WebGL\u2014met vaste geheugenmodellen werkt, hanteert Tilekit een geheugenstrategie die gericht is op stabiliteit, hergebruik en minimale fragmentatie. Dit geldt voor alle onderdelen van het systeem, van cold storage tot warm en hot tiles.</p> <p>De kernprincipes zijn:</p> <ul> <li>Structure of Arrays (SoA): Tilekit bewaart data in lineaire, gealigneerde blokken. Hierdoor blijft het geheugen   compact en kunnen tiles snel worden geselecteerd, gefilterd en ge\u00fcpdatet.</li> <li>Preallocatie en pools: Alle datastructuren die tijdens de levenscyclus van een tile nodig zijn, worden vooraf   gealloceerd of komen uit een pool. Dit voorkomt runtime-allocaties, piekbelasting en fragmentatie.</li> <li>Geen allocaties binnen tile-lifecycles: Zodra een tile cold, warm of hot is, worden er geen nieuwe structuren meer   aangemaakt. Materialisatie en dematerialisatie gebruiken uitsluitend vooraf voorbereide buffers of bestaande objecten.</li> <li>Voorspelbare geheugenblokken: Cold Storage, warm data en hot representaties gebruiken vaste patronen en blokken,   zodat Tilekit stabiel blijft bij grote aantallen tiles en meerdere datasets tegelijkertijd.</li> </ul> <p>Deze principes vormen de basis voor het gedrag van Archetypes en DataSets in de volgende hoofdstukken. Omdat memory management een breed en gedetailleerd onderwerp is, zijn de achterliggende motivaties, best practices en implementatierichtlijnen beschreven in een afzonderlijk document.</p>"},{"location":"docs/developers/tilekit/ophalen-van-data/","title":"Ophalen van data","text":""},{"location":"docs/developers/tilekit/ophalen-van-data/#ophalen-van-data","title":"Ophalen van data","text":"<ul> <li>Moet Asynchroon gebeuren</li> <li>Network requests moeten gethrottled kunnen worden opgehaald in de gehele applicatie - om geheugen te besparen mogen    er niet teveel downloads tegelijk gebeuren omdat elk resultaat in het geheugen komt. </li> <li>Er moet er een retry mechanisme in komen<ul> <li>Is dat iets voor Uxios? https://dev.to/scrapfly_dev/how-to-retry-in-axios-5e87</li> <li>Kijk naar https://cesium.com/learn/cesiumjs/ref-doc/Resource.html</li> </ul> </li> <li>Injecteren van een sjabloon-request (Uxios.Config) voor, bijv, authenticatie en custom headers.</li> <li>Zowel remote als bestanden uit de persistent data storage kan worden opgehaald op een eenduidige manier<ul> <li>middels de HTTP Client Uxios.</li> <li>Zie https://kind-men.github.io/uxios/guides/working-with-persistent-data/ voor bestanden in de Persistent Data Storage, en https://kind-men.github.io/uxios/guides/fetching-pokemon-using-get/ voor URLs.</li> </ul> </li> <li>Filesystem abstractie?<ul> <li>Kunnen we hergebruiken wat er al is in het projectsysteem en daar een systeem van maken?</li> <li>Dit zijn nu verschillende manieren; ik doel vooral op de <code>project://</code> prefix en het inladen daarvan</li> </ul> </li> <li>Als we hier een aparte adapter van maken, dan kunnen we itereren op dit stuk en hoeft bovenstaande niet in een keer.<ul> <li>Gaan we met <code>project://</code> werken, of met <code>unity+persistent://</code>? Die laatste is Uxios, die eerste is onze eigen manier. Met de laatste kunnen we ook bestanden openen die niet in het project zijn maar wel in de persistent storage; nadeel is dat je je bestandslokaties moet weten</li> </ul> </li> <li>Gaan we abstraheren, of juist op Uxios leunen? Dat eerste is flexibeler, dat tweede minder complex.</li> <li>TileContentLoader moet aan begin meegegeven worden</li> <li>Elke TileRenderer of de GameObject die geinstantieerd wordt wil toegang hebben tot de TileContentLoader? Of tot de TileContentData?</li> </ul>"},{"location":"docs/developers/tilekit/ophalen-van-data/#authenticatie-en-autorisatie","title":"Authenticatie en Autorisatie","text":"<p>Het bepalen van de juiste credentials voor een databron gebeurt v\u00f3\u00f3r het inladen van een laag met Tilekit. Tilekit voorziet hierin geen interactief login-mechanisme of eigen authenticatie flow.</p> <p>In plaats daarvan gaat Tilekit ervan uit dat credentials reeds bekend zijn. Deze credentials worden vervolgens ge\u00efnjecteerd in het sjabloon van alle HTTP-verzoeken die gebruikt worden om tegels op te halen.</p> <p>Deze aanpak biedt de volgende voordelen:</p> <ul> <li> <p>Scheidt verantwoordelijkheden: authenticatie wordt volledig uitbesteed aan een bovenliggende laag of reeds   bestaand authenticatiemechanisme zoals het <code>Netherlands3D.Credentials</code> systeem.</p> </li> <li> <p>Maakt Tilekit eenvoudiger en modulair: er is geen noodzaak voor ingebouwde ondersteuning van verschillende   authenticatieprotocollen binnen Tilekit zelf.</p> </li> <li> <p>Ondersteunt variabele autorisatie-eisen per databron: omdat elke laag zijn eigen verzoek-sjabloon kan   krijgen, kunnen per laag of bron andere headers, tokens of endpoints gebruikt worden.</p> </li> </ul> <p>Voorbeeld: een WFS-bron met een OAuth2-authenticatie kan door een aparte module een access token laten ophalen. Dit token wordt vervolgens in de Authorization-header geplaatst van het HTTP-sjabloon waarmee tegels worden opgehaald.  Tilekit is hier volledig agnostisch in \u2014 zolang het sjabloon correct is ingevuld, zal de bron benaderd worden met de juiste credentials.</p> <p>In situaties waarin authenticatie moet worden hernieuwd (zoals bij vervallen tokens), ligt de verantwoordelijkheid bij de bovenliggende laag om het sjabloon te vernieuwen of de TileContentLoader opnieuw te initialiseren met bijgewerkte credentials.</p>"},{"location":"docs/developers/tilekit/tegelsysteem/","title":"Tegelsysteem","text":"<ul> <li> <p>Co\u00f6rdinaten &amp; Projectie</p> <ul> <li>Abstract Coordinate System; projectie door developers configureerbaar.</li> <li>Aanbevolen: EPSG:4978 (XYZ)</li> <li>Ondersteuning voor EPSG:4979 (lat/lon/height) in bounding volumes</li> </ul> </li> <li> <p>Floating Origin</p> <ul> <li>Compatibel zonder directe koppeling</li> </ul> </li> </ul>"},{"location":"docs/developers/tilekit/tegelsysteem/#expliciete-en-impliciete-tilesets","title":"Expliciete en impliciete TileSets","text":"<p>Bij het ontwerpen van een tegelsysteem maken we onderscheid tussen expliciete en impliciete tegelsystemen. Beide benaderingen beschrijven hoe tegels binnen een (hi\u00ebrarchische) structuur worden georganiseerd en aangesproken, maar ze verschillen fundamenteel in hoe deze wordt gedefinieerd.</p>"},{"location":"docs/developers/tilekit/tegelsysteem/#expliciet-tegelsysteem","title":"Expliciet Tegelsysteem","text":"<p>Een expliciet tegelsysteem beschrijft elke tegel individueel, inclusief zijn positie, relatie tot andere tegels en metadata. Hierbij maken we gebruik van een vooraf gedefinieerde lijst van tegels in de TileSet. Elke tegel kent zijn kinderen expliciet, inclusief verwijzingen naar onderliggende tegels.</p> <p>Kenmerken</p> <ul> <li>Structuur is volledig gespecificeerd.</li> <li>Onderlinge relaties (ouder-kind) zijn expliciet gedefinieerd.</li> <li>Geschikt voor complexe hi\u00ebrarchie\u00ebn.</li> </ul> <p>Voordeel: Volledige controle en flexibiliteit over de positie, hi\u00ebrarchie en metadata per tegel. Nadeel: Grotere initi\u00eble payload en ongeschikt voor grootschalige datasets.</p>"},{"location":"docs/developers/tilekit/tegelsysteem/#impliciet-tegelsysteem","title":"Impliciet Tegelsysteem","text":"<p>Een impliciet tegelsysteem beschrijft geen individuele tegels, maar maakt gebruik van een algoritme om tegels af te leiden op basis van een vaste structuur. Dit systeem is schaalbaar en effici\u00ebnt, omdat de hi\u00ebrarchie en locatie van een tegel volledig kunnen worden afgeleid uit de tegel-ID.</p> <p>Netherlands3D ondersteunt binnen het impliciete systeem drie hoofdstructuren:</p> <p>1. Quadtree De quadtree-structuur deelt de ruimte op in vier gelijke kwadranten per niveau. Elke tegel heeft maximaal vier kinderen (NO, NW, ZO, ZW). Deze structuur is ideaal voor tweedimensionale datasets of geografische informatie.</p> <p>2. Octree De octree is de driedimensionale tegenhanger van de quadtree. Elke tegel wordt opgesplitst in acht kinderen, waarbij de ruimte langs de x-, y- en z-as wordt gehalveerd. Deze structuur is geschikt voor volumetrische datasets of 3D-sc\u00e8nes met LOD.</p> <p>3. Uniform Grid Bij een uniform grid worden tegels op een vlak verdeeld in een vast raster, zonder hi\u00ebrarchie. Dit type wordt meestal gebruikt wanneer elke tegel gelijkwaardig is en er geen behoefte is aan dynamische detaillering of LOD.</p> <p>Kenmerken van impliciete systemen:</p> <ul> <li>Hi\u00ebrarchie wordt bepaald door een patroon (bijv. depth en tile indices).</li> <li>Geen beschrijving van elke individuele tegel nodig: structuur is afleidbaar.</li> <li>Lichtgewicht en geschikt voor grote datasets.</li> <li>Relaties worden bepaald door index-berekening in plaats van expliciete verwijzingen.</li> </ul> <p>Voordeel: Hoge schaalbaarheid en lage overhead. Nadeel: Minder flexibiliteit voor per-tegel metadata of uitzonderingen.</p> <p>Zie https://github.com/CesiumGS/3d-tiles/blob/main/specification/ImplicitTiling/README.adoc voor details hoe de 3D Tiles specificatie omgaat met Impliciete Tiling, Tilekit zijn ontwerp is gebaseerd op deze principes met extra ondersteuning voor uniforme grids.</p>"},{"location":"docs/developers/tilekit/tegelsysteem/#levenscyclus-van-een-kaartlaag","title":"Levenscyclus van een kaartlaag","text":"<p>De levenscyclus van een kaartlaag bestaat uit de volgende stappen:</p> <ol> <li>Inladen van een laag: in dit stadium worden de capabilities opgehaald van de gekozen databron, en    omgezet in Tilekit zijn eigen tegelset definitie - de Cold Storage. Dit garandeert dat het klaarzetten van de     tegels en het bijwerken van de weergave altijd dezelfde informatie hebben, ongeacht de bron.</li> <li>Warm maken van tegels (verwarmen): </li> <li>Hot maken van de tegels (verhitten): </li> </ol>"},{"location":"docs/developers/tilekit/tegelsysteem/#inladen-van-een-tileset","title":"Inladen van een TileSet","text":"<p>In hoofdstuk 7.4. Datamodel is beschreven welke elementen de definitie van een TileSet heeft. Hiermee kan je flexibel een breed scala aan tegelsystemen mee weergeven.</p>"},{"location":"docs/developers/tilekit/tegelsysteem/#voorwaarden-voor-een-valide-tileset","title":"Voorwaarden voor een valide TileSet","text":"<p>Spatial Coherence</p> <p>Bij het omzetten van de data van een databron naar expliciete tegels is van belang dat de bounding volume van alle tegels Spatial Coherence hebben. Deze beperking zorgt ervoor dat tegels benaderd kunnen worden als een R-tree datastructuur en geeft optimalisatiemogelijkheden, zoals het volledig overslaan van een complete branch aan tegels als de applicatie niet eens in de buurt is.</p> <p>Voorbeeld</p> <p>Als we ergens in Nederland naar een lokatie kijken dan kunnen we alle tegels -van elk LOD niveau- overslaan buiten Nederland, zoals Duitsland of geheel Afrika. Dit kan alleen als de tegels in Nederland Spatial Coherence hebben.</p> <p>Aanwezigheid van een Geometrische Error</p> <p>Elke tegel moet een geometricError waarde bevatten. Deze waarde, uitgedrukt in meters, geeft aan hoeveel detail er verloren gaat als deze tegel wordt weergegeven in plaats van zijn fijnmazigere kindtegels. Zonder deze waarde is automatische LOD-switching niet mogelijk.</p> <p>Oplopende Detailniveaus (Geometrische Hi\u00ebrarchie)</p> <p>Kindtegels moeten altijd een lagere geometricError hebben dan hun ouder. Dit weerspiegelt de hi\u00ebrarchische structuur van het tegelsysteem, waarbij lagere niveaus (meer gedetailleerde tegels) nauwkeuriger zijn.</p> <p>Als deze relatie niet klopt, kan de applicatie verkeerde beslissingen nemen over welke tegel in beeld moet komen, met visuele artefacten of onnauwkeurigheden als gevolg. Het afdwingen van deze regel zorgt ervoor dat LOD-logica zoals Screen Space Error correct werkt.</p>"},{"location":"docs/developers/tilekit/tegelsysteem/#tegel-selectie","title":"Tegel selectie","text":"<p>De TileSelector is een service die bepaald welke tegels er in beeld zouden moeten zijn. Van de TileSelector kunnen meerdere strategieen zijn, degene die standaard toegepast wordt is de \"TilesInView\" tile selector.</p> <p>De TilesInView tile selector zal middels een \"Depth First Search\" de TileSet definitie doorlopen. Depth First Search is een recursief zoek algoritme waarbij je begint met een enkele \"root\" tegel, en vervolgens de volgende vragen stelt:</p> <ol> <li>Is deze tegel in beeld?<ol> <li>Als de tegel niet in beeld is, dan eindigt onze zoektocht. Deze tegel wordt niet geladen en we negeren zijn    kinderen,</li> <li>Anders:</li> </ol> </li> <li>Is het type van refinement \"Add\" of \"Replace\"?<ol> <li>is het type \"Replace\", dan starten we een serie van geselecteerde tegels</li> <li>is het type \"Add\", dan voegen we deze tegel toe aan de serie van geselecteerde tegels</li> </ol> </li> <li>Is dit het juiste LOD voor deze tegel?<ol> <li>Als de juiste LOD van een tegel gevonden dan onthouden we de serie aan geselecteerde tegels,</li> <li>Anders: herhaal deze stappen voor elke kind-tegel van deze tegel</li> </ol> </li> </ol> <p>Aan het einde van deze handeling zouden we een lijst moeten hebben van tegels die in beeld moeten gaan zijn. In stap 2 is dus van belang dat we niet altijd op zoek zijn naar 1 tegel in een aftakking van de R-tree. Het is ook mogelijk een reeks aan kinderen te verkrijgen omdat bij een ADD de kind tegel niet de ouder tegel vervangt, maar juist in combinatie met een ouder tegel wordt ingeladen.</p> <p>Todo</p> <p>Update schema, en controleer de exacte werking als afwisselend ADD en REPLACE door elkaar gebruikt worden</p> <p>Todo</p> <p>Onderzoeken of een BEAM of BFS search beter werkt.</p> <p>Wat is \"de juiste LOD\"?</p> <p>Tegels moeten een \"Geometric Error\" hebben. De geometric error is een maat (in meters) die zegt hoe \"grof\" een tegel is in vergelijking met zijn fijnere kinderen. Het komt neer op: hoeveel detail je mist als je deze tegel toont in plaats van zijn onderliggende (meer gedetailleerde) tegels.</p> <p>Tijdens het draaien van de app gebruiken we deze geometricError om te bepalen of een tegel voldoende detail geeft op het scherm. Dat doen we door het om te rekenen naar screen space error (SSE) \u2013 dat is de fout uitgedrukt in pixels op je scherm.</p> <p>Bijvoorbeeld:</p> <ul> <li>Stel: een tegel heeft een geometricError van 50 meter.</li> <li>Als die 50 meter visueel overeenkomt met 10 pixels op het scherm, dan is de SSE = 10.</li> <li>Als je een maximum SSE van bijvoorbeeld 8 pixels hanteert, dan weet je: deze tegel moet worden vervangen door zijn   kinderen, want hij is niet precies genoeg.</li> </ul> <p>Bepalen van de juiste LOD</p> <p>De <code>TileSelector</code> gebruikt onderstaande logica om te bepalen of een tegel voldoende detail biedt:</p> <ol> <li>Bepaal het dichtstbijzijnde punt van de bounding volume van de tegel ten opzichte van de camera.</li> <li>Bereken de afstand van de camera tot dit punt, aangeduid als <code>distanceToCamera</code>.</li> <li>Bereken de screen space error (SSE) met de formule:</li> </ol> <pre><code>SSE = (geometricError / distanceToCamera) * schermProjectieFactor\n</code></pre> <p>In ons systeem is de <code>schermProjectieFactor</code> altijd 1. Dit betekent dat deze vermenigvuldiging in de praktijk kan    worden weggelaten, waardoor de vereenvoudigde formule in code vaak als volgt wordt gebruikt:</p> <pre><code>SSE = geometricError / distanceToCamera\n</code></pre> <ol> <li>Vergelijk met de ingestelde drempelwaarde <code>maximumScreenSpaceError</code>:<ul> <li>Als <code>SSE &gt; maximumScreenSpaceError</code>: de tegel is niet gedetailleerd genoeg \u2192 zoom in naar kindtegels.</li> <li>Als <code>SSE &lt;= maximumScreenSpaceError</code>: deze tegel is voldoende \u2192 toon deze en stop het inzoomen.</li> </ul> </li> </ol> <p>Let op: als <code>distanceToCamera</code> bijna nul is (bijvoorbeeld als de camera zich binnen de bounding volume van een tegel bevindt), dan wordt de SSE oneindig groot. In dat geval wordt de SSE behandeld als <code>float.MaxValue</code>.</p>"},{"location":"docs/developers/tilekit/tegelsysteem/#verversen-van-tegels","title":"Verversen van tegels","text":"<p>Externe factoren, zoals styling of filtering, kunnen reeds ingeladen tegels be\u00efnvloeden. Wanneer dit gebeurd is het nodig om tegels te kunnen verversen.</p> <p>Om dit te kunnen doen, is het nodig dat een tegel gemarkeerd kan worden als Dirty. Dit geeft aan dat een tegel zijn staat moet terugbrengen naar de \"primaire staat\" - zoals deze ontvangen was van de brondata - en dan opnieuw alle aanpassingen toepast, zoals Styling of Filtering.</p> <p>De volgende voorwaarden zijn hierbij van belang:</p> <ul> <li>Dit gebeurt niet onmiddellijk, maar op zijn minst 1 frame later -of zelfs langer- zodat niet   onnodig bewerkingen uitgevoerd worden.</li> <li>Het verversen van een enkele tegel is een synchroon proces zodat er geen verstoring voor de gebruikersbeleving.</li> </ul>"},{"location":"docs/developers/tilekit/tegelsysteem/#datamodel","title":"Datamodel","text":"<p>In het datamodel maken we onderscheid tussen drie niveau's:</p> <ul> <li>Ondersteunende data objecten, zoals Buckets in Memory management - deze objecten zijn bedoeld om in een schrijfmodel   gebruikt te worden maar representeren technische concepten, in tegenstelling tot domein concepten in de    applicatie.</li> <li>Schrijf-model, zoals de Cold Storage - deze objecten vormen de geheugen-geoptimaliseerde maar complexe SoA kern van    Tilekit. Aanpassingen in deze classes zijn gevoelig en moeten goed geprofiled worden.</li> <li>Lees-model, zoals de Tile klasse of de BoundingVolume - dit is een laag bovenop het schrijf-model dat op een meer    begrijpelijke manier toegang geeft en meer lijkt op een Object Oriented Programming manier van omgaan met data. Wat   hier van belang is, is dat het leesmodel zelf geen data heeft maar alleen verwijzingen naar waar de data in het    schrijf-model verkregen kan worden.</li> </ul> <p>Todo</p> <p>Kijk naar https://github.com/CesiumGS/3d-tiles/blob/main/specification/ImplicitTiling/README.adoc#availability om na te gaan of er een betere manier is om de ID van een tegel te bepalen middels de Morton Z-order curve.</p>"},{"location":"docs/developers/tilekit/tegelsysteem/#memory-management","title":"Memory management","text":"<p>In Tilekit wordt geheugenbeheer geoptimaliseerd door gebruik te maken van compacte, vooraf gealloceerde buffers\u2014ook wel buckets genoemd. In plaats van traditionele dynamische datastructuren, die leiden tot frequente allocaties en geheugenfragmentatie, werken deze buckets met ranges die verwijzen naar delen van een vaste buffer. Hierdoor kan het systeem toch dynamische data opslaan en uitbreiden, zonder dat het onderliggende geheugen beweegt of opnieuw gealloceerd hoeft te worden.</p> <p>Deze aanpak vermindert fragmentatie, verhoogt cache-effici\u00ebntie, en maakt het mogelijk om grote hoeveelheden tegels en tile-metadata te beheren binnen strikte geheugenlimieten. Het klassediagram hieronder toont hoe de belangrijkste  geheugenbeheer-klassen samenwerken om dit model te ondersteunen.</p> <pre><code>classDiagram\n    class Buckets~T~ {\n        - NativeList~BucketRange~ ranges;\n        + NativeList~BucketRange~ Ranges;\n        - NativeList~T~ flat;\n        + NativeList~T~ Flat;\n        + int Length\n        + int Capacity\n        + T this[int index];\n\n        + Add(ReadOnlySpan&lt;T&gt; items) int\n        + GetBucket(int rangeIndex) Bucket~T~\n        + Clear() void\n    }\n\n    class BucketRange {\n        + int Offset;\n        + int Count;\n    }\n\n    class Bucket~T~ {\n        - NativeSlice~T~ s;\n        + int Count\n        + T this[int index];\n\n        + NativeSlice~T~.Enumerator GetEnumerator()\n        + void Replace(NativeArray~T~ replacement)\n    }\n\n    Buckets~T~ --&gt; BucketRange\n    Buckets~T~ -- Bucket~T~</code></pre>"},{"location":"docs/developers/tilekit/tegelsysteem/#buckets","title":"Buckets","text":"<p>De <code>Buckets</code>-class fungeert als een effici\u00ebnte wrapper rond twee NativeList-structuren:</p> <ol> <li>Flat \u2013 een lineaire NativeList waarin alle data compact achter elkaar wordt opgeslagen. <li>Ranges \u2013 een NativeList waarin per bucket wordt bijgehouden waar in de Flat-buffer de data staat    (startindex + lengte). <p>Met deze combinatie kunnen we dynamische datasets opslaan zonder dynamische datastructuren te hoeven gebruiken. Nieuwe of groeiende datasets worden simpelweg achteraan de Flat-buffer geplaatst, en de bijbehorende BucketRange wijst naar het relevante segment.</p> <p>Dankzij deze ranges kan het systeem zeer snel een slice ophalen\u2014een \u201cbucket\u201d\u2014zonder kopi\u00ebren of extra allocaties. De Flat blijft compact en fragmentatie wordt voorkomen.</p>"},{"location":"docs/developers/tilekit/tegelsysteem/#bucket","title":"Bucket","text":"<p>De <code>Bucket</code>-klasse is een dunne wrapper rond een <code>NativeSlice&lt;T&gt;</code>. Een <code>NativeSlice</code> verwijst rechtstreeks naar een deel  van een onderliggende buffer \u2014 in dit geval het Flat-array van de <code>Buckets</code>-class \u2014 zonder eigen geheugen te bezitten.</p> <p>Omdat een <code>Bucket</code> dus slechts een view is op bestaande data:</p> <ul> <li>Kan data direct worden gelezen alsof het een kleine, zelfstandige collectie is.</li> <li>Kan data ook worden overschreven of gemodificeerd, waarbij de wijzigingen meteen in het oorspronkelijke Flat-array   terechtkomen.</li> <li>Hoeft er nooit een kopie gemaakt te worden, wat zowel allocaties als geheugenfragmentatie voorkomt.</li> </ul>"},{"location":"docs/developers/tilekit/tegelsysteem/#schrijf-model","title":"Schrijf-model","text":"<p>Het schrijf-model is een geheugen-geoptimaliseerde Structure of Array (SoA) opzet waarbij tegels niet als  tegel-objecten, maar als arrays van velden worden opgeslagen - zie de ColdStorage klasse. Elk array representeert een  veld van een tegel - zoals de geometrische error - en de index van elk array is gelijk aan de tegel index.</p> <p>Example</p> <p>Stel dat je een tegel met id 42 hebt, dan kan van elk van deze arrays index 42 bevraagd worden en dan heb je de  data voor die tegel.</p> <p>Om het gebruik te vergemakkelijken hiervan is een lees-model ingericht (zie volgende hoofdstuk) waar middels handles, of referenties, een wrapper is gemaakt om een meer object-georienteerde, en daarmee herkenbare, manier van bevragen aan te bieden.</p> <p>De centrale klasse hierin is de <code>ColdStorage</code> klasse, deze bevat de data voor een verzameling tegels; veelal gebruikt  voor een enkele laag in de applicatie.</p> <p>Dit deel van Tilekit is heftig geoptimaliseerd voor geheugen (her)gebruik, en dit is ook te zien in hoe de data  structuren zijn gemaakt. Elk van deze arrays is een NativeList met een vooraf ingestelde capaciteit die groot genoeg  moet zijn om in 90% van de situaties niet te hoeven resizen. Hierdoor krijg je bij het toevoegen van een laag 1x  meerdere allocaties maar vervolgens tijdens de levensduur van de laag geen nieuwe allocaties van tegel-data.</p> <p>Het kan wel gebeuren dat bij het laden van <code>Content</code> allocaties plaatsvindt. Dit kan gemitigeerd worden door middel van object pooling maar niet 100% voorkomen.</p> <p>Voor het wijzigen van het schrijf-model gelden de volgende regels:</p> <ul> <li>Allocatie van tegel-data mag alleen tijdens het aanmaken van een laag, hiermee heb je een vast geheugenbudget om mee    te werken en beperkt fragmentatie.<ul> <li>Uitzondering: het resizen van een laag als blijkt dat er meer data nodig is, tune de applicatie dat dit nooit of    zelden gebeurd, en resize in vaste blokgroottes voor optimaal hergebruik van de geheugenruimte als een laag    gedisposed wordt.</li> </ul> </li> <li>Werk alleen met NativeLists of NativeArrays van data met een vooraf ingestelde grootte. Door het gebruik van unmanaged   memory verminder je de druk op de garbage collector en kan Unity bepaalde caching trucs uitvoeren die helpen.</li> <li>Vermijd reference types zoveel mogelijk - reference types kunnen niet gebruikt worden in NativeLists en NativeArrays    en kunnen een complete value type toch de managed heap in trekken.</li> <li>Gebruik de kleinst mogelijke data structuren, inclusief het voorzien van een <code>byte</code> type aan enums als deze een kleine   set elementen gebruiken.</li> <li>Over enums gesproken - alle enums in de write model moeten value-backed zijn, dus een expliciete numerieke waarde toe-   gewezen hebben. Dit maakt het gebruik hiervan voorspelbaarder.</li> <li>Inheritance van objecten is niet mogelijk, door het gebruik van structs kan je geen inheritance gebruiken en    inheritance nodigt boxing uit, waardoor extra allocaties plaatsvinden tijdens uitvoering.</li> </ul> <p>Hieronder zie je een overzicht van de klassen die in de kern van het schrijf-model gebruikt worden:</p> <pre><code>classDiagram\n    class ColdStorage {\n        + BoxBoundingVolume AreaOfInterest\n        + BoundingVolumeStore BoundingVolumes\n        + NativeList~double~ GeometricError;\n        + NativeList~MethodOfRefinement~ Refine;\n        + NativeList~float4x4~ Transform;\n\n        + Buckets~int~ Children;\n        + Buckets~TileContentData~ Contents;\n        + StringTable Strings;\n    }\n\n    class MethodOfRefinement {\n        Add = 0,\n        Replace = 1\n    }\n    &lt;&lt;Enumeration&gt;&gt; MethodOfRefinement\n\n    class BoundingVolumeType {\n        Uninitialized = 0,\n        Region = 1,\n        Sphere = 2,\n        Box = 3\n    }\n    &lt;&lt;Enumeration&gt;&gt; BoundingVolumeType\n\n    class BoundingVolumeRef {\n        + BoundingVolumeType Type;\n        + int Index;\n    }\n\n    class BoundingVolumeStore {\n        + NativeList~BoundingVolumeRef~ BoundingVolumeRefs;\n        + NativeList~BoxBoundingVolume~ Boxes;\n        + NativeList~RegionBoundingVolume~ Regions;\n        + NativeList~SphereBoundingVolume~ Spheres;\n    }\n\n    class BoxBoundingVolume {\n        + double3 Center;\n        + double3 HalfAxisX;\n        + double3 HalfAxisY;\n        + double3 HalfAxisZ;\n    }\n\n    class RegionBoundingVolume {\n        + double West;\n        + double South;\n        + double East;\n        + double North;\n        + double MinHeight;\n        + double MaxHeight;\n    }\n\n    class SphereBoundingVolume {\n        + double3 Center\n        + double Radius\n    }\n\n    class TileContentData {\n        + int UriIndex;\n        + BoundingVolumeRef BoundingVolume;\n    }\n\n    ColdStorage --&gt; BoxBoundingVolume\n    ColdStorage --&gt; BoundingVolumeStore\n    ColdStorage --&gt; TileContentData\n    MethodOfRefinement &lt;-- ColdStorage \n    TileContentData --&gt; BoundingVolumeRef\n    BoundingVolumeRef --&gt; BoundingVolumeType\n    BoundingVolumeStore --&gt; BoundingVolumeRef\n    BoundingVolumeStore --&gt; BoxBoundingVolume\n    BoundingVolumeStore --&gt; SphereBoundingVolume\n    BoundingVolumeStore --&gt; RegionBoundingVolume</code></pre>"},{"location":"docs/developers/tilekit/tegelsysteem/#cold-storage","title":"Cold Storage","text":"<p>ColdStorage vormt de laagste trede in de tegel hi\u00ebrarchie en is het minimale opslagpunt voor alle tegels. Waar warm en  hot tiles daadwerkelijk materiaal, geometrie of rendering-gerelateerde data bevatten, bewaart ColdStorage uitsluitend de  structurele en ruimtelijke metadata die nodig is om een tile te identificeren, selecteren en prioriteren.</p>"},{"location":"docs/developers/tilekit/tegelsysteem/#doel-van-de-coldstorage","title":"Doel van de ColdStorage","text":"<p>Het doel van ColdStorage is om een volledig overzicht van alle potenti\u00eble tegels in een dataset te behouden, zonder kostbare resources zoals texturen, meshes of decoded payloads in het geheugen te laden. </p> <p>Hierdoor kan Tilekit:</p> <ul> <li>grote tegelpiramides en diepe hi\u00ebrarchie\u00ebn ondersteunen</li> <li>snel bepalen welke tegels relevant zijn voor de camera</li> <li>soepele overgang naar warm/hot states realiseren (lifecycle-beheer)</li> <li>memory-fragmentatie minimaliseren door SoA-opslag</li> </ul> <p>ColdStorage is ontworpen voor schaalbaarheid, vooral richting provinciale of nationale datasets, waarvele tiles in  metadata-vorm beschikbaar moeten zijn.</p>"},{"location":"docs/developers/tilekit/tegelsysteem/#inhoud-van-coldstorage","title":"Inhoud van ColdStorage","text":"<p>Een ColdStorage bevat voor elke tile:</p> <ul> <li>BoundingVolume \u2014 box, region of sphere</li> <li>Geometric error (of resolutiebereik)</li> <li>Tijdsbereik (optioneel, voor spatiotemporele datasets)</li> <li>Verwijzingen naar kinderen of informatie uit het tiling scheme</li> <li>Contentinformatie (zoals URL of index naar content mapping)</li> </ul> <p>Cruciaal is dat deze data blittable en SoA-geori\u00ebnteerd is opgeslagen in NativeArrays of NativeLists, zodat iteratie, culling en selectie extreem goedkoop blijven \u2014 ook in WebGL.</p>"},{"location":"docs/developers/tilekit/tegelsysteem/#het-interessegebied","title":"Het interessegebied","text":"<p>ColdStorage wordt altijd gecre\u00eberd voor een specifiek interessegebied (area of interest). Dit gebied bepaalt hoeveel van de tile piramide wordt gematerialiseerd.</p> <p>Het interessegebied:</p> <ul> <li>Bepaalt welke tiles geselecteerd worden bij ingestie - wanneer een dataset wordt ingelezen (bijvoorbeeld WMS, WMTS,    3D Tiles of GeoJSON), worden alleen die tiles opgenomen waarvan het bounding volume snijdt met het interessegebied.    Dit voorkomt dat ColdStorage onnodig groot wordt.</li> <li>Vermindert de diepte van de piramide - omdat tegels die volledig buiten het interessegebied vallen worden uitgesloten,    bevat ColdStorage alleen de relevante delen van de hi\u00ebrarchie.</li> </ul>"},{"location":"docs/developers/tilekit/tegelsysteem/#bounding-volumes","title":"Bounding Volumes","text":"<p>Een tegel of content element, heeft een locatie en afmeting in de wereld. Dit wordt middels een bounding volume geduid. De bounding volume komt in drie vormen (box, sphere en region) en worden in meer detail beschreven in de 3D Tiles  specificatie.</p> <p>Doordat het schrijf-model geheugen-geoptimaliseerd werkt, is het niet mogelijk om middels polymorfisme een abstracte  bounding volume toe te wijzen aan een tegel en dan een kind-klasse daarvan op die plek te zetten. Dit breekt met  geheugen alignment en zal fragmentatie en allocaties door boxing veroorzaken.</p> <p>Als gevolg hiervan is er de <code>BoundingVolumeStore</code>, wat een Structure of Arrays is speciaal voor bounding volumes. Elk element dat een bounding volume nodig heeft, heeft eigenlijk een <code>BoundingVolumeRef</code>. De <code>BoundingVolumeRef</code> is een  verwijzing binnen de <code>BoundingVolumeStore</code> naar de juiste array en index in die array van het type bounding volume die  je wil toepassen.</p> <p>De impact hiervan is dat je 'teveel' geheugen gebruikt omdat voor elk type bounding volume een versie onthouden wordt, dit is voor de complexiteit een acceptabele trade-off.</p> <p>Todo</p> <p>We willen onderzoeken of de huidige bounding-volume opslag geoptimaliseerd kan worden. Momenteel slaan we voor elke  tile drie varianten op (box, sphere, region) terwijl er maar \u00e9\u00e9n actief is, wat onnodig veel geheugen kost.</p> <p>Voorstel om te onderzoeken:</p> <ul> <li>Gebruik \u00e9\u00e9n platte NativeArray als opslag voor alle bounding-volume data. <li>Gebruik daarnaast een NativeArray met:<ul> <li>Kind (Box/Sphere/Region)</li> <li>Offset naar de juiste positie in de double-array.</li> </ul> <li>Definieer per volume-type een vaste lengte in doubles (bijv. Box = 12, Sphere = 4, Region = 6).</li> <li>Maak read-model \u201cviews\u201d (BoxView, SphereView, RegionView) die via offset + values het volume exposen, i.p.v.    volledige structs op te slaan.</li> <li>Onderzoek of NativeSlice of offset-gebaseerde toegang het meest effici\u00ebnt is in jobs. <li>Centraliseer de allocatie en het wegschrijven van volumes in \u00e9\u00e9n API, zodat type-lengtes en offsets foutloos blijven.</li>"},{"location":"docs/developers/tilekit/tegelsysteem/#tilecontentdata","title":"TileContentData","text":"<p>Elke tegel kent een of meer content elementen, de tile content data is een structuur waarin we bijhouden welke content in welk deel van de tegel beschikbaar is.</p> <p>Example</p> <p>Een voorbeeld is een omgevingsmodel waarbij elke tegel een maaiveld mesh heeft, een mesh met bomen en een mesh met  gebouwen. Dit zijn drie content elementen op dezelfde tegel. Zie de 3D Tiles specificatie voor meer informatie.</p> <p>Content, in deze context, is data die gevisualiseerd kan worden als onderdeel van de tegel. Voorbeelden zijn textures  en meshes. In de Cold Storage wordt niet de content zelf opgeslagen, maar alleen verwijzingen daarnaar middels de  <code>UriIndex</code> - hetgeen een referentie is naar een element in een speciale string table.</p> <p>Todo</p> <p>De string table voor het opslaan van uri's kan op verschillende manieren geoptimaliseerd worden, het is aan te raden om niet naar 1 op 1 string storage te kijken maar om de-duping mogelijk te maken van onderdelen in de url. Door een URL te splitsen op scheme, host, pad-segmenten en query parameters en elk van deze als losse strings met integer referenties op te slaan kan de hoeveelheid string, of character, data geoptimaliseerd worden.</p> <p>Content in de tile content data kan ook beperkt zijn tot een bepaald gebied, of middels een bounding volume geplaatst  zijn op een specifieke plek - hierbij is van belang dat spatial coherence gerespecteerd moet blijven en de bounding  volume van de content spatially coherent is met die van de tegel.</p>"},{"location":"docs/developers/tilekit/tijdsafhandeling/","title":"Tijdsafhandeling","text":"<p>Tijd is een volwaardige dimensie in Tilekit. Net als ruimte en resolutie bepaalt tijd w\u00e9lke tegels of features zichtbaar mogen zijn, welke vervangen moeten worden, en hoe het systeem tile-lifecycle-beslissingen neemt.</p>"},{"location":"docs/developers/tilekit/tijdsafhandeling/#tijd-als-soa-vriendelijke-numerieke-dimensie","title":"Tijd als SoA-vriendelijke, numerieke dimensie","text":"<p>Binnen Tilekit wordt tijd uitsluitend gerepresenteerd als een 64-bit Unix-timestamp in milliseconden (UTC).  Dit betekent dat elk tijdstip een <code>long</code> is met \u201chet aantal milliseconden sinds 1 januari 1970, 00:00 UTC\u201d. Deze representatie is:</p> <ul> <li>Blittable en vast in grootte \u2014 ideaal voor SoA-structuren, NativeArray/NativeList, en low-level CPU-loops.</li> <li>Exact en ordelijk \u2014 vergelijkingen zijn simpele integer-vergelijkingen, zonder floating-point afrondingsfouten.</li> <li>Breed ondersteund \u2014 externe standaarden zoals 3D Tiles en JSON-gebaseerde APIs gebruiken Unix-tijd als   gemeenschappelijke noemer.</li> </ul> <p>Warning</p> <p>Tijd is in UTC. Dat betekent dat als een databron geen tijdzone informatie bij zijn datum/tijd notaties heeft, dat aangenomen moet worden dat de tijd ook in UTC is, of dat er een tijdzone opgegeven moet kunnen worden bij het importeren. Door tijd te normaliseren naar UTC voorkom je problemen als gevolg van wintertijd/zomertijd wisselingen of conversies van en naar verschillende tijdzones. Dit betekent wel dat bij het weergeven van tijdsinformatie deze tijden geconverteerd moeten worden naar de Europe/Amsterdam tijdzone, of CET cq. CEST.</p> <p>Door alle tijd in Tilekit terug te brengen tot een enkel numeriek domein, blijven Tilekit-componenten eenvoudig te combineren zonder conversieproblemen of verlies van precisie.</p>"},{"location":"docs/developers/tilekit/tijdsafhandeling/#tijd-als-geldigheidsbereik","title":"Tijd als geldigheidsbereik","text":"<p>Een tegel of feature heeft zelden \u00e9\u00e9n enkel tijdstip; meestal kent het een geldigheidsinterval. Tilekit gebruikt daarom een compacte, SoA-geschikte vorm:</p> <pre><code>public struct TimeRange\n{\n    public long Start; // inclusief\n    public long End;   // exclusief\n}\n</code></pre> <p>Deze keuze maakt tijdsselectie eenvoudig:</p> <ul> <li>Een tegel is zichtbaar indien: <code>Start &lt;= huidigeTijd &amp;&amp; huidigeTijd &lt; End</code></li> <li>Een tegel overlapt een tijdsvenster indien: <code>End &gt; vensterStart &amp;&amp; Start &lt; vensterEinde</code></li> </ul> <p>Deze checks zijn extreem snel en vragen geen enkele conversie tijdens runtime.</p>"},{"location":"docs/developers/tilekit/tijdsafhandeling/#tijd-en-externe-interfaces","title":"Tijd en externe interfaces","text":"<p>Aan de randen van Tilekit \u2014 in API-clients, readers voor WMS/3D Tiles/GeoJSON, of UI-elementen \u2014 mag tijd in prettige vormen bestaan zoals <code>DateTime</code>, <code>DateTimeOffset</code>, ISO-8601 strings, of server-specifieke formats. Binnenkomende waarden worden direct geconverteerd naar Unix-milliseconden.</p>"},{"location":"docs/developers/tilekit/tijdsafhandeling/#waarom-tilekit-deze-aanpak-gebruikt","title":"Waarom Tilekit deze aanpak gebruikt","text":"<p>De combinatie van integer-vergelijkingen en expliciete tijdsintervallen biedt:</p> <ul> <li>Maximale performance in tile selection en change planning</li> <li>Minimale geheugenvoetafdruk per tile</li> <li>Voorspelbaar gedrag bij overlap, geldigheid en vervanging</li> </ul>"},{"location":"docs/developers/ui/introduction/","title":"Introduction","text":"<p>Welcome to the foundational section of our technical documentation, where we introduce the user interface (UI) design system of Netherlands3D. This documentation is crafted to guide developers, designers, and contributors through the  design architecture that shapes the user experience within our digital twin environment.</p>"},{"location":"docs/developers/ui/introduction/#purpose-of-the-design-system","title":"Purpose of the Design System","text":"<p>The design system serves as a comprehensive framework that harmonizes UI design and development, ensuring consistency, scalability, and efficiency across the application. It is the blueprint that orchestrates the visual and interactive elements, making the digital twin not only a technological marvel but also an intuitive and engaging experience for users.</p>"},{"location":"docs/developers/ui/introduction/#overview-of-the-ui-design-system","title":"Overview of the UI Design System","text":"<p>At the heart of our UI design system are two fundamental concepts: Blocks and Components. These elements are the building blocks of our application's interface, structured to offer clarity and flexibility in design and implementation. Inspired by the BEM (Block, Element, Modifier) methodology, our system disambiguates between blocks and components to streamline the development process and enhance the UI's modularity and reusability.</p>"},{"location":"docs/developers/ui/introduction/#blocks","title":"Blocks","text":"<p>Blocks are the larger, more general sections of the UI that function as the containers for components. They define the structural layout and set the stage for the detailed elements within. Blocks can be as broad as the entire application window or as specific as a user interaction panel.</p>"},{"location":"docs/developers/ui/introduction/#components","title":"Components","text":"<p>Components, on the other hand, are the more granular, reusable elements that reside within blocks. They are the nuts and bolts of the UI, encompassing buttons, sliders, text fields, and other interactive elements. Components are designed with flexibility in mind, allowing them to be adapted and reused across different blocks.</p>"},{"location":"docs/developers/ui/introduction/#objectives-of-this-documentation","title":"Objectives of This Documentation","text":"<p>The subsequent chapters of this documentation are dedicated to diving deeper into the specifics of blocks and components, outlining their characteristics, how they are designed, and how they interact within the UI framework of our digital twin platform. Our goals are to:</p> <ul> <li>Clarify the distinction between blocks and components, providing a clear understanding of their roles within the   UI design system.</li> <li>Guide the design and development process, offering insights into best practices for creating and integrating   blocks and components.</li> <li>Facilitate scalability and customization, enabling developers and designers to extend the UI efficiently and   creatively.</li> </ul> <p>As we proceed, this documentation will serve as a reference for enhancing and expanding the user interface of  Netherlands3D, ensuring that the developers and designers within the ecosystem are aligned.</p> <p>In the next chapter, we will explore the concept of blocks in detail, examining their structure, functionality, and how they contribute to the overall user experience of the application.</p>"},{"location":"docs/developers/ui/understanding-blocks/","title":"Understanding Blocks","text":"<p>In the Netherlands3D platform, our design system is structured for clear organization and effective scaling. Blocks form the fundamental part of this structure, acting as the primary containers for the interface's elements. This chapter focuses on blocks, explaining their purpose, features, and their role in creating a unified user experience in Netherlands3D.</p>"},{"location":"docs/developers/ui/understanding-blocks/#what-are-blocks","title":"What Are Blocks?","text":"<p>Blocks are the large-scale elements of our UI design system. They serve as the main sections that organize and contain various components. Think of blocks as the framework of a building, providing structure and defining the layout within our digital environment. In Netherlands3D, blocks have specific functions, such as guiding navigation, displaying information, facilitating user interactions, or showcasing data visually.</p>"},{"location":"docs/developers/ui/understanding-blocks/#features-of-blocks","title":"Features of Blocks","text":"<ul> <li> <p>Modular: Blocks are designed as self-contained units that can be mixed and matched in different layouts, offering   flexibility and reuse across the platform.</p> </li> <li> <p>Scalable: They are built to support the platform's growth, making it easy to add new features or adapt to changing   user needs without disrupting the existing design.</p> </li> <li> <p>Consistent: Despite their variety, blocks maintain a unified design language and user experience across   Netherlands3D.</p> </li> </ul>"},{"location":"docs/developers/ui/understanding-blocks/#designing-blocks","title":"Designing Blocks","text":"<p>Creating blocks for Netherlands3D requires attention to:</p> <ul> <li> <p>User Needs: Design each block with the user's requirements in mind, ensuring it fulfills its intended purpose   effectively.</p> </li> <li> <p>Adaptability: Make blocks adaptable for different types of content and scenarios within the platform.</p> </li> </ul>"},{"location":"docs/developers/ui/understanding-blocks/#conclusion","title":"Conclusion","text":"<p>Blocks are foundational to the Netherlands3D UI design system, offering the structural basis for our digital twin platform. By leveraging blocks effectively, we can ensure a robust, user-friendly interface that reflects the innovative spirit of digital twin technology.</p> <p>The following chapter will detail the components within these blocks, including their design and role in enhancing the interactive experience of Netherlands3D.</p>"},{"location":"docs/developers/ui/understanding-components/","title":"Understanding Components","text":"<p>In this chapter, we delve deeper into the essence of components\u2014the dynamic and interactive elements that enable users to engage with the Netherlands3D platform effectively. Components are the individual pieces of the user interface, such as buttons, sliders, dropdown menus, and data visualization charts, which users interact with directly.</p>"},{"location":"docs/developers/ui/understanding-components/#what-are-components","title":"What Are Components?","text":"<p>Components are the versatile and interactive building blocks housed within the UI's structural blocks. They range from  input fields (where users can enter data), buttons (like 'Submit' or 'Cancel'), sliders (for adjusting settings or zoom levels), to more complex elements such as the minimap (allowing users to explore).</p>"},{"location":"docs/developers/ui/understanding-components/#features-of-components","title":"Features of Components","text":"<ul> <li> <p>Reusability: Designed for reuse, components like toggle switches for on/off settings ensure consistency and    streamline development across Netherlands3D.</p> </li> <li> <p>Customization: Components can be tailored for different informational purposes to adhere to the specific aesthetic    of the platform.</p> </li> <li> <p>Interactivity: Interactive components, such as accordions, for customization features or detailed content    display, to engage users directly, offering a dynamic experience.</p> </li> </ul>"},{"location":"docs/developers/ui/understanding-components/#designing-components","title":"Designing Components","text":"<p>The design of components focuses on the user's needs, aiming for clarity, efficiency, and aesthetic harmony:</p> <ul> <li> <p>User-Centric Design: Components are crafted to be intuitive and accessible for easy   navigation or with validation to guide user input.</p> </li> <li> <p>Aesthetic Consistency: Despite their diversity, components maintain the Netherlands3D's cohesive design language, </p> </li> <li>reinforcing brand identity.</li> </ul>"},{"location":"docs/developers/ui/understanding-components/#managing-components","title":"Managing Components","text":"<p>The lifecycle of components in Netherlands3D involves continuous evaluation and refinement:</p> <ol> <li> <p>Identification of Needs: New functionalities might require the development of novel components interaction with     the 3D environment or its data.</p> </li> <li> <p>Rigorous Testing: Components undergo extensive testing.</p> </li> <li> <p>Iterative Improvement: Feedback might lead to the evolution of components, such as enhancing them    for better data visualization or for improved usability.</p> </li> </ol>"},{"location":"docs/developers/ui/understanding-components/#conclusion","title":"Conclusion","text":"<p>Components are vital for the interactive and functional richness of the Netherlands3D platform. Each component plays a  crucial role in engaging users and facilitating a smooth experience. Through careful design and management, components  ensure Netherlands3D remains an intuitive, efficient, and visually appealing platform.</p>"},{"location":"docs/developers/ui/blocks/property-panel-and-sections/","title":"Properties","text":""},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#design","title":"Design","text":""},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#usage","title":"Usage","text":"<p>The \"Properties\" block in Netherlands3D serves as a critical interface element, allowing users to interact with and modify the attributes of various layers within the application. This documentation provides insights into the design considerations and implementation strategies for this block, ensuring a seamless integration within the Netherlands3D platform.</p> <p>This block enables users to access and adjust the transformation properties (position, rotation, scale) of selected 3D objects or layers. Additionally, it provides access to specific attributes for certain objects, such as Windmills, which may include properties like axis height or rotor diameter.</p> A screenshot of a windmill with an open properties panel"},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#anatomy","title":"Anatomy","text":"Anatomical breakdown of the properties block <p>The Properties panel is constructed using a Card component, organized into several key areas for intuitive user interaction:</p> <ol> <li>Card: The overarching container for the Properties panel, designed for clarity and    cohesion.</li> <li>Card Header: Displays the Properties icon and the term \"Eigenschappen,\" indicating the    panel's purpose.</li> <li>Section: Each layer or object type, such as Windmills, has its dedicated section within the card.</li> <li>Section Header: Identifies the specific layer or object type, e.g., \"Windmolen\" for Windmills, guiding users to the    relevant properties.</li> <li>Section Content: Contains form elements for adjusting the specific properties of the selected layer or object. This    area is designed for direct interaction, allowing users to modify attributes like axis height or rotor diameter.</li> </ol>"},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#design-principles","title":"Design Principles","text":"<ul> <li>Clarity: The use of a card-based layout ensures that the Properties panel is easily navigable and understandable,   with distinct sections for different layers or objects.</li> <li>Consistency: Maintaining a uniform structure across different sections ensures that users have a cohesive   experience, regardless of the variety of objects or layers they interact with.</li> <li>Immediate Feedback: Interactions within the Properties panel are designed to provide immediate visual feedback in   the Netherlands3D environment, emphasizing the panel's role in direct manipulation of objects and layers.</li> </ul>"},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#interaction","title":"Interaction","text":"<p>Users interact with the Properties panel by selecting an object or layer within the Netherlands3D platform, and clicking on the properties button with that layer.</p> <p>Upon opening, the panel updates to display the relevant sections for the chosen item. Adjustments made within the form elements of a section are immediately applied, allowing users to see the effects of their changes in real-time. This design supports a tactile and intuitive experience, encouraging exploration and modification within the digital twin environment.</p>"},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#implementation","title":"Implementation","text":""},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#overview","title":"Overview","text":"<p>The Properties panel's functionality in the Netherlands3D platform is achieved through a combination of Unity prefabs and scripting. This implementation ensures dynamic interaction within the UI, allowing for the seamless addition of properties sections based on the selected layer or object.</p>"},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#prefab-structure","title":"Prefab Structure","text":"<ul> <li> <p>Main Properties Prefab: The core of the Properties panel, this prefab is a part of the default canvas and acts as   the container for all dynamically added sections.</p> </li> <li> <p>Section Prefabs: Individual prefabs for each type of section (e.g., Windmill properties) that can be instantiated   within the main Properties panel.</p> </li> </ul>"},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#scripting-and-interfaces","title":"Scripting and Interfaces","text":""},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#ipropertysection-interface","title":"IPropertySection Interface","text":"<p>An essential element in the dynamic nature of the Properties panel is the <code>IPropertySection</code> interface. This interface allows for the detection and instantiation of properties sections based on the presence of specific MonoBehaviours within a layer's prefab.</p> <ul> <li> <p>Detection and Instantiation: A script running in the layer system detects MonoBehaviours that implement   the <code>IPropertySection</code> interface on a layer's prefab being added to the scene. Upon detection, the <code>AddToProperties</code>   method of the interface is called.</p> </li> <li> <p>Factory Behavior: Implementations of the <code>IPropertySection</code> can act as factories, instantiating the appropriate   section prefab and adding it to the Properties panel as a \"slot\". The <code>AddToProperties</code> method is being provided with   the properties content area to which the section can be added.</p> </li> </ul>"},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#addtoproperties-method","title":"AddToProperties Method","text":"<p>The <code>AddToProperties</code> method is where the logic for instantiating the section prefab and integrating it into the Properties panel is defined. This method allows for flexibility in the UI, permitting custom designs per section while adhering to the overall design guidelines.</p> <p>Example</p>"},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#example-windmill-property-section","title":"Example: Windmill Property Section","text":"<p>The Windmolen prefab, used for the Windmill implementation in the Object Library, includes a MonoBehaviour named <code>WindmillPropertySectionInstantiator</code> that demonstrates this system in action.</p> <ul> <li> <p>Functionality: The <code>WindmillPropertySectionInstantiator</code> responds to the addition of a Windmill object and   instantiates a dedicated section within the Properties panel. This section is specifically designed to bind and   display the properties of the windmill, such as axis height or rotor diameter.</p> </li> <li> <p>Binding: The script binds the windmill's data to the instantiated section, ensuring that any adjustments made     within the Properties panel are immediately reflected in the windmill's properties within the scene.</p> </li> </ul>"},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#implementation-steps","title":"Implementation Steps","text":"<p>Given an existing layer's prefab:</p> <p>Implement the IPropertySection interface: For each layer requiring a properties section, create a MonoBehaviour  that implements <code>IPropertySection</code> and defines how its section prefab should be instantiated and added to the  Properties panel.</p>"},{"location":"docs/developers/ui/blocks/property-panel-and-sections/#design-adherence","title":"Design Adherence","text":"<p>While implementing sections, it's crucial to adhere to the established design rules to maintain consistency across the Properties panel. However, the flexibility of this system allows for the introduction of unique UI elements where necessary to better represent specific properties.</p>"},{"location":"docs/developers/ui/components/accordion/","title":"Accordion","text":""},{"location":"docs/developers/ui/components/accordion/#design","title":"Design","text":""},{"location":"docs/developers/ui/components/accordion/#usage","title":"Usage","text":"<p>The Accordion component in the Netherlands3D platform is a versatile UI element designed to efficiently manage and display hierarchical content in a compact form. Featuring a title, an optional label, and a toggle mechanism indicated by a chevron, the Accordion allows for an organized presentation of content sections, each with its dedicated header to signify its integration within the Accordion. This component is ideal for:</p> <ul> <li> <p>Settings Menus: Grouping related settings or options to streamline user navigation, such as layer property sections.</p> </li> <li> <p>Grouping Content: Grouping related content to focus on related information, such as quality indicator dossiers.</p> </li> <li> <p>Interactive FAQs: Presenting frequently asked questions in a concise, expandable format.</p> </li> </ul>"},{"location":"docs/developers/ui/components/accordion/#modes-of-operation","title":"Modes of Operation","text":"<ol> <li> <p>Fixed Mode: This mode locks the Accordion in an always-open state, without the option to collapse or expand. The    absence of a chevron signifies its static nature.</p> </li> <li> <p>Multiple Open Mode: Allows for multiple Accordions within a group to be opened or closed independently. The chevron    points up when opened, indicating a \"roll-up\" action, and down when closed, suggesting a \"roll-down\" action.</p> </li> <li> <p>Single Open Mode: In a group of Accordions, only one can be open at a time. Opening another Accordion automatically    closes the previously open one. This mode features a chevron pointing down when closed; and when open, the chevron is    hidden, supplemented by an additional outline to highlight the Accordion is considered to be an active -or selected-    Accordion.</p> </li> </ol>"},{"location":"docs/developers/ui/components/accordion/#anatomy","title":"Anatomy","text":"Anatomical breakdown of the Accordion component <ol> <li> <p>Title: A text representative of the Accordion's content.</p> </li> <li> <p>Icon (Optional): Provides additional context or classification.</p> </li> <li> <p>Expand/Contract Toggle (Optional): A chevron-based toggle mechanism indicating the Accordion's state and     possible actions.</p> </li> <li> <p>Content Section: The expandable area containing detailed content or components.</p> </li> <li> <p>Content Header: A header within the content section styled specifically to emphasize its connection to the     Accordion.</p> </li> </ol>"},{"location":"docs/developers/ui/components/accordion/#design-principles","title":"Design Principles","text":""},{"location":"docs/developers/ui/components/accordion/#title-and-icon","title":"Title and Icon","text":"<p>The title provides a succinct summary of the content contained within the Accordion, while the optional icon offers  additional context or categorization.</p> <p>Both elements are designed to be immediately visible to enhance usability and guide the user's navigation through the  content sections.</p>"},{"location":"docs/developers/ui/components/accordion/#expandcontract-toggle","title":"Expand/Contract Toggle","text":"<p>The Expand/Contract Toggle includes a chevron symbol that visually communicates the Accordion's state and possible  actions to the user. The direction of the chevron indicates the effect of the interaction (down for roll-down, up for  roll-up).</p> <p>The toggle may be absent when there is no action available, as can be the case for the fixed mode of operation or when no roll-up is provided because one element always needs to be open.</p>"},{"location":"docs/developers/ui/components/accordion/#content-section","title":"Content Section","text":"<p>The content section beneath each Accordion title is designed for expandability, housing detailed information or  additional UI components.</p> <p>Optionally, a specific header within the content section further emphasizes its association with the Accordion.</p>"},{"location":"docs/developers/ui/components/accordion/#best-practices","title":"Best Practices","text":"<ul> <li> <p>Clarity: Ensure the title and label (if used) are clear and informative, guiding the user's understanding of the   content within.</p> </li> <li> <p>Intuitive Interaction: Design the Expand Toggle for easy recognition and interaction, with chevron icons that   intuitively indicate the possible actions.</p> </li> <li> <p>Consistency: Maintain visual and functional consistency across all Accordion components, especially within groups   operating in multiple or single open modes.</p> </li> </ul>"},{"location":"docs/developers/ui/components/accordion/#implementation","title":"Implementation","text":"<p>Info</p> <p>As of writing, there is no component in Unity available to provide the Accordion component. This part of the  documentation should be updated as soon as one is available.</p>"},{"location":"docs/developers/ui/components/cards/","title":"Cards","text":""},{"location":"docs/developers/ui/components/cards/#usage","title":"Usage","text":"<p>Cards are surfaces that display content and actions on a single topic.</p> <p>They should be easy to scan for relevant and actionable information. Elements, like text and images, should be placed on them in a way that clearly indicates hierarchy.</p>"},{"location":"docs/developers/ui/components/cards/#anatomy","title":"Anatomy","text":"<p>Info</p> <p>The contents of this chapter need to be written </p>"},{"location":"docs/developers/ui/components/double-sliders/","title":"Double Slider","text":""},{"location":"docs/developers/ui/components/double-sliders/#design","title":"Design","text":""},{"location":"docs/developers/ui/components/double-sliders/#usage","title":"Usage","text":"<p>Similar to the slider component, the double slider component in the Netherlands3D platform provides  a graphical interface element enabling users to select a range between two values from a predefined scale.  Accompanied by two Text Fields, this component allows for both graphical adjustment and direct numerical input, ensuring a versatile and user-friendly experience. The main difference between the double slider and the regular slider is that the double slider has two handles and input fields, defining the minimum and maximum value of the range.</p>"},{"location":"docs/developers/ui/components/double-sliders/#immediate-effects","title":"Immediate effects","text":"<p>Changes made with double sliders are immediate, allowing the user to make slider adjustments while determining a selection. Sliders shouldn\u2019t be used to adjust settings with any delay in providing user feedback.</p>"},{"location":"docs/developers/ui/components/double-sliders/#current-state","title":"Current state","text":"<p>Sliders reflect the current state of the settings they control.</p>"},{"location":"docs/developers/ui/components/double-sliders/#anatomy","title":"Anatomy","text":"Anatomical breakdown of the double slider component <ol> <li>Slider Track: The horizontal line along which the double slider thumb moves, representing the range of possible values.</li> <li>Minimum Slider Thumb: The circular control that users drag to select the minimum value on the slider track.</li> <li>Minimum Text Field (Optional): Adjacent to the double slider, this field displays the currently selected minimum value and allows for manual    entry. It can be configured as readonly or omitted based on specific requirements.</li> <li>Maximum Slider Thumb: The circular control that users drag to select the maximum value on the slider track.</li> <li>Maximum Text Field (Optional): Adjacent to the double slider, this field displays the currently selected maximum value and allows for manual    entry. It can be configured as readonly or omitted based on specific requirements.</li> </ol>"},{"location":"docs/developers/ui/components/double-sliders/#implementation","title":"Implementation","text":"<p>This chapter guides you through adding the double slider prefab to your scene, configuring its behavior, and responding to user input.</p>"},{"location":"docs/developers/ui/components/double-sliders/#adding-the-slider-to-your-scene","title":"Adding the Slider to Your Scene","text":"<ol> <li> <p>Prefab Placement: Locate the double slider prefab in the project's asset directory. Drag and drop the prefab into your    scene or hierarchy where you need the slider component to appear.</p> </li> <li> <p>Initial Setup: By default, the double slider comes with linked Text Fields for numerical input. Together, they provide    a cohesive component for value selection.</p> </li> </ol>"},{"location":"docs/developers/ui/components/double-sliders/#configuring-the-slider","title":"Configuring the Slider","text":""},{"location":"docs/developers/ui/components/double-sliders/#listening-to-value-changes","title":"Listening to Value Changes","text":"<p>Use the Unity Editor to attach a listener function to the slider's <code>onMinValueChanged</code> and <code>onMaxValueChanged</code> events. These functions will be called whenever the slider's minimum or maximum value changes, respectively, whether through direct manipulation of the double slider or numerical entry in the Text Fields.</p>"},{"location":"docs/developers/ui/components/double-sliders/#customizing-the-text-field","title":"Customizing the Text Field","text":"<ul> <li> <p>Readonly Option: The <code>DoubleSlider</code> MonoBehaviour includes a <code>readonly</code> boolean. When set to true, the Text   Fields becomes readonly, allowing users to see the value but preventing manual entry. This is useful in situations   where you want to restrict input to slider manipulation only.</p> </li> <li> <p>Omitting the Text Field: If your use case does not require numerical input, you can deactivate the Text Fields   entirely. Simply set the Text Field GameObjects to inactive, and the double slider will automatically expand to fill the   space, maintaining the UI's visual continuity.</p> </li> </ul>"},{"location":"docs/developers/ui/components/sliders/","title":"Slider","text":""},{"location":"docs/developers/ui/components/sliders/#design","title":"Design","text":""},{"location":"docs/developers/ui/components/sliders/#usage","title":"Usage","text":"<p>The slider component in the Netherlands3D platform provides a graphical interface element enabling users to select a value or range from a predefined scale. Accompanied by a Text Field, this component allows for both graphical adjustment and direct numerical input, ensuring a versatile and user-friendly experience.</p>"},{"location":"docs/developers/ui/components/sliders/#immediate-effects","title":"Immediate effects","text":"<p>Changes made with sliders are immediate, allowing the user to make slider adjustments while determining a selection. Sliders shouldn\u2019t be used to adjust settings with any delay in providing user feedback.</p>"},{"location":"docs/developers/ui/components/sliders/#current-state","title":"Current state","text":"<p>Sliders reflect the current state of the settings they control.</p>"},{"location":"docs/developers/ui/components/sliders/#anatomy","title":"Anatomy","text":"Anatomical breakdown of the slider component <ol> <li>Slider Track: The horizontal line along which the slider thumb moves, representing the range of possible values.</li> <li>Slider Thumb: The circular control that users drag to select a value on the slider track.</li> <li>Text Field (Optional): Adjacent to the slider, this field displays the currently selected value and allows for manual    entry. It can be configured as readonly or omitted based on specific requirements.</li> </ol>"},{"location":"docs/developers/ui/components/sliders/#implementation","title":"Implementation","text":"<p>This chapter guides you through adding the slider prefab to your scene, configuring its behavior, and responding to user input.</p>"},{"location":"docs/developers/ui/components/sliders/#adding-the-slider-to-your-scene","title":"Adding the Slider to Your Scene","text":"<ol> <li> <p>Prefab Placement: Locate the slider prefab in the project's asset directory. Drag and drop the prefab into your    scene or hierarchy where you need the slider component to appear.</p> </li> <li> <p>Initial Setup: By default, the slider comes with a linked Text Field for numerical input. Together, they provide    a cohesive component for value selection.</p> </li> </ol>"},{"location":"docs/developers/ui/components/sliders/#configuring-the-slider","title":"Configuring the Slider","text":""},{"location":"docs/developers/ui/components/sliders/#listening-to-value-changes","title":"Listening to Value Changes","text":"<p>Use the Unity Editor to attach a listener function to the slider's <code>onValueChanged</code> event. This function will be called whenever the slider's value changes, whether through direct manipulation of the slider or numerical entry in the Text Field.</p>"},{"location":"docs/developers/ui/components/sliders/#customizing-the-text-field","title":"Customizing the Text Field","text":"<ul> <li> <p>Readonly Option: The <code>PropertySlider</code> MonoBehaviour includes a <code>readonly</code> boolean. When set to true, the Text   Field becomes readonly, allowing users to see the value but preventing manual entry. This is useful in situations   where you want to restrict input to slider manipulation only.</p> </li> <li> <p>Omitting the Text Field: If your use case does not require numerical input, you can deactivate the Text Field   entirely. Simply set the Text Field GameObject to inactive, and the slider will automatically expand to fill the   space, maintaining the UI's visual continuity.</p> </li> </ul>"},{"location":"docs/developers/ui/components/text-fields/","title":"Text Field","text":""},{"location":"docs/developers/ui/components/text-fields/#design","title":"Design","text":""},{"location":"docs/developers/ui/components/text-fields/#usage","title":"Usage","text":"<p>\"Text Fields\" in the Netherlands3D platform allow users to input or modify text information. They can be used singularly or in combination with other components like a Slider or Form Label in the Properties block. They're an essential part of Netherlands3D's user interface, providing users with interactive fields to enter or manipulate various properties.</p>"},{"location":"docs/developers/ui/components/text-fields/#parts","title":"Parts","text":"<p>The Text Field component comprises two main parts:</p> <ol> <li> <p>Form Label: The descriptive text associated with the Text Field, explaining what value is being manipulated. This    is a reusable part and can be shared with other components like the Slider.</p> </li> <li> <p>Form Field: It serves as the component for user text input or changing text information. It is styled to account    for different states like Idle, Focus, Pressing, and Read-Only.</p> </li> </ol>"},{"location":"docs/developers/ui/components/text-fields/#anatomy","title":"Anatomy","text":"<p>Note</p> <p>Add an image to showcase the anatomy of a form field and elaborate some more on this in the text</p> <ol> <li> <p>Form Label: Positioned above or adjacent to the Form Field, providing a textual description of the information    required or displayed.</p> </li> <li> <p>Form Field: The interactive text input area where users can enter or modify data. It transitions between various    states (Idle, Focus, Pressed, Read-only) to visually communicate its current mode of interaction.</p> </li> </ol>"},{"location":"docs/developers/ui/components/text-fields/#design-principles","title":"Design Principles","text":"<ul> <li> <p>Clarity: Labels are clear and informative, ensuring users understand what information is required.</p> </li> <li> <p>Feedback: Built-in states (Idle, Focused, Pressed, and Read-Only) provide immediate visual feedback to users,   aiding an interactive experience.</p> </li> </ul>"},{"location":"docs/developers/ui/components/text-fields/#implementation","title":"Implementation","text":"<p>The Text Field is modeled using Unity prefabs and scripting, offering dynamic interaction within the user interface, allowing for adaptive properties adjustment based on user input.</p>"},{"location":"docs/developers/ui/components/text-fields/#adding-a-text-field-to-your-scene","title":"Adding a Text Field to Your Scene","text":"<ul> <li>Prefab Placement: Locate the Text Field prefab in the project's asset directory. Drag and drop the prefab into your   scene where you need the Text Field component to appear.</li> </ul>"},{"location":"docs/developers/ui/components/text-fields/#configuring-the-text-field","title":"Configuring the Text Field","text":"<p>You can utilize the Unity Editor to add listener functions that get triggered on text value change events, enabling you to manipulate and use the user-input text as per application needs.</p>"},{"location":"docs/functionaliteiten/functionaliteiten-overzicht/","title":"Overzicht functies","text":"<p>Deze pagina bevat het overzicht van alle functies van de 3D-Viewer van Netherlands3D. Door op de functies te klikken kom je bij de gedetailleerde beschrijving en handleiding.</p>"},{"location":"docs/functionaliteiten/functionaliteiten-overzicht/#algemeen","title":"Algemeen","text":"<p>Gebied downloaden Locatie bepalen Object informatie Ondergrond doorzicht  Project openen/opslaan  Schermafbeelding maken Transformatietool Zonnestand simuleren </p>"},{"location":"docs/functionaliteiten/functionaliteiten-overzicht/#navigeren","title":"Navigeren","text":"<p>Minimap Orthografisch/perspectief Positie Weergave naar noorden draaien First Person Viewer</p>"},{"location":"docs/functionaliteiten/functionaliteiten-overzicht/#toevoegen","title":"Toevoegen","text":"<p>3D Tiles Google foto-realistische wereld Importeren - bestand via URL Importeren - eigen bestand Objecten bibliotheek Tekengebied - Lijn  Tekengebied - Polygoon  UrbanReLeaf Sensor Data Verspreid objecten in tekengebied Polygoon  </p>"},{"location":"docs/functionaliteiten/functionaliteiten-overzicht/#instellingen","title":"Instellingen","text":"<p>Bomen en bospercelen Buurtnamen Gebouwen - 3D BAG Gebouwen kleuren Indicatoren Kwaliteit Limiteer scroll gevoeligheid Straatnamen Terrein - kadaster Wijknamen </p>"},{"location":"docs/functionaliteiten/wat-is-netherlands3d/","title":"Wat is Netherlands3D?","text":"<p>Netherlands3D is een interactieve 3D-omgeving waarmee je de fysieke wereld digitaal kunt verkennen. Of je nu een stad, een projectgebied of een specifiek object wilt bekijken, de viewer biedt een intu\u00eftieve manier om ruimtelijke gegevens te ontdekken en te combineren.</p> <p>Met Netherlands3D kun je:</p> <ul> <li>Gedetailleerde 3D-modellen bekijken van gebouwen, infrastructuur en landschap.</li> <li>Je eigen gegevens toevoegen, zoals kaarten, lagen of modellen.</li> <li>De uitslagen van metingen en analyses inladen en combineren met andere databronnen voor een compleet en   ge\u00efntegreerd beeld.</li> <li>Complexe informatie begrijpelijk presenteren, door verschillende databronnen visueel te combineren in een   toegankelijke 3D-weergave.</li> </ul> <p>Wat Netherlands3D uniek maakt, is dat jij als gebruiker bepaalt welke data je visualiseert en welke functionaliteiten je inzet. Geen vaste lijsten met vooraf gedefinieerde kaartlagen, maar flexibele koppelingen naar databronnen en applicaties die aansluiten op jouw project. Denk aan gegevens van je eigen organisatie, het landelijke dataloket PDOK of dataportalen van gemeenten en provincies.</p> <p>De viewer is ontworpen voor professionals \u00e9n nieuwsgierige gebruikers die meer willen weten over hun omgeving. Alles werkt direct in je browser, zonder dat je extra software hoeft te installeren.</p> <p>Wil je aan de slag? Bekijk de handleiding en ontdek de mogelijkheden van Netherlands3D!</p>"},{"location":"docs/handleiding/","title":"Overzicht van de functionaliteiten","text":"<p>Op de homepage is algemene informatie over het Netherlands 3D project te vinden. Naast de handleiding bieden we specifiek voor twee doelgroepen informatie aan: voor organisaties/gebruikers en ontwikkelaars. Op deze pagina vind je de belangrijkste functionaliteiten van de homepage en de gebruikersinterface.    </p>"},{"location":"docs/handleiding/#overzicht-van-functionaliteiten","title":"Overzicht van functionaliteiten","text":"<p>De homepage van Netherlands3d.eu biedt toegang tot de verschillende hoofdstukken en functionaliteiten. </p>"},{"location":"docs/handleiding/#gedetailleerde-beschrijving-van-de-functionaliteiten","title":"Gedetailleerde beschrijving van de functionaliteiten","text":""},{"location":"docs/handleiding/#hoofdmenubalk","title":"Hoofdmenubalk","text":"<p> (Afbeelding) Hoofdmenubalk</p>"},{"location":"docs/handleiding/#functionaliteiten","title":"Functionaliteiten","text":"<p> (Afbeelding) Dark/Light modus</p>"},{"location":"docs/handleiding/#voor-organisaties","title":"Voor organisaties","text":"<p>Dit hoofdstuk is onder ontwikkeling en bevat straks een uitgebreide bron van informatie. Het doel is om organisaties te ondersteunen met gidsen, best practices en antwoorden op veel gestelde vragen die essentieel zijn voor het gebruik van het Netherlands3D platform. </p>"},{"location":"docs/handleiding/#voor-ontwikkelaars","title":"Voor ontwikkelaars","text":"<p>Ben je een ontwikkelaar en wil je bijvoorbeeld eigen functionaliteiten binnen Netherlands 3D ontwikkelen? Dan vindt je in dit hoofdstuk de benodigde technische documentatie. Deze documentatie is bedoeld voor ontwikkelaars die willen begrijpen hoe het platform werkt, de architectuur willen verkennen en nieuwe modules of functionaliteiten willen bijdragen.</p>"},{"location":"docs/handleiding/#handleiding","title":"Handleiding","text":"<p>In het hoofdstuk Handleiding vind je een gedetailleerde beschrijving van alle functionaliteiten ondersteund met afbeeldingen en/of filmpjes. </p>"},{"location":"docs/handleiding/#schermmodus","title":"Schermmodus","text":"<p>Door op het <code>Schermmodus-icoon</code> te klikken kan de interface kan de modus veranderd worden in <code>Dark</code>; lichte tekst op een donkere achtergrond of <code>Light</code>; donkere tekst op een lichte achtergrond. In de Dark modus gebruikt het systeem minder energie en hoeft het systeem in het geval van een laptop minder snel te worden opgeladen.</p>"},{"location":"docs/handleiding/#zoeken","title":"Zoeken","text":"Deze zoekfunctie biedt de mogelijkheid om naar trefwoorden te zoeken binnen Netherlands3D.eu. Vul de zoekterm(en) in bij <code>Zoeken</code> en de lijst met klikbare resultaten wordt in de context (hoofdstuk en alinea) getoond."},{"location":"docs/handleiding/#headline","title":"Headline","text":"<p> (Afbeelding) Headline</p>"},{"location":"docs/handleiding/#bekijk-de-viewer","title":"Bekijk de viewer","text":"<p>Met de knop <code>Bekijk de viewer</code> in de headline wordt de 3D-viewer functionaliteit gestart. (Zie 3D-viewer functionaliteit  voor de beschrijving.)  </p>"},{"location":"docs/handleiding/#wat-is-het","title":"Wat is het","text":"<p>Met de knop <code>Wat is het?</code> wordt de tekst \u2019Wat is Netherlands3D?\u2019 onder het overlay scherm naar boven gehaald.</p>"},{"location":"docs/handleiding/#content","title":"Content","text":"<p> (Afbeelding) Content</p> <p>De content bevat een algemene beschrijving van Netherlands3D.eu.</p>"},{"location":"docs/handleiding/#footer","title":"Footer","text":"<p> (Afbeelding)  Footer</p> <p>Deze laag bevat de logo's van de bij Netherlds3D.eu betrokken provincies en de mogelijkheid om door de hoofdstukken van het hoofdmenu in de hoofdbalk te bladeren.</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/","title":"Functionaliteiten","text":"<p>Stel je eigen Netherlands3D.eu samen!  Met het submenu <code>Functionaliteiten</code> krijgt de gebruiker toegang tot het aan-/uitzetten van de standaard datalagen en (menu)functies die in de basis versie van Netherlands3d.eu wordt aangeboden.    </p> <p> (Afbeelding) Functionaliteiten - submenu   Klik in het <code>selectievakje</code> om de laag of functie aan of uit te zetten.   </p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#functies","title":"Functies","text":""},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#terrein","title":"Terrein","text":"<p>Met maaiveld, ofwel het 'oppervlak waarop we lopen' is weergegeven als 3D terrein.  Voor het tonen van dit terrein is gebruik gemaakt van de 3D Basisvoorziening van het Kadaster.  Visueel onderscheiden zijn gebouwen, terreinonderdelen (zoals wegen, groenvlakken en water) en bruggen, waarbij de  gebouwen niet als 3D objecten worden getoond in deze laag. Op enkele onderdelen is een geometrische versimpeling    toegepast om het maaiveld sneller in de viewer te tonen. Bron: 3D Basisvoorziening, datum: 2019</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#gebouwen","title":"Gebouwen","text":"<p>Alle objecten op de laag 'Gebouwen' komen uit de 3D BAG, een jaarlijks geactualiseerde dataset van alle gebouwen in     Nederland. De set is ontwikkeld door de de 3D geoinformatie onderzoeksgroep van de Technische Universiteit Delft. Aan   het gebruik van de 3D BAG zitten. Bron: 3DBAG, datum: 2024, actualisatie: Jaarlijks</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#bomen-en-bospercelen","title":"Bomen en bospercelen","text":"<p>Deze kaartlaag toont alle individuele bomen en bospercelen van Nederland voor zover ze in de Basiskaart Grootschalige   Topografie (BGT) zijn opgenomen. Binnen bospercelen wordt onderscheid gemaakt in loofbossen, naaldbossen en gemengde    bossen, welke met een willekeurige hoogte en locatie zijn geplaatst. Bomen worden als 2D objecten op 3 vlakken  geprojecteerd, waardoor het lijkt alsof ze 3D objecten zijn.  Bron: Basiskaart Grootschalige Topografie (BGT), datum: december 2023</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#straatnamen","title":"Straatnamen","text":"<p>Deze kaartlaag toont alle straatnamen van Nederland. Afhankelijk van het zoomniveau worden straatnamen weergegeven. Bron: Nationaal Wegen Bestand (NWB)</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#buurtnamen","title":"Buurtnamen","text":"<p>Deze kaartlaag toont alle buurtnamen van Nederland. Afhankelijk van het zoomniveau worden buurtnamen weergegeven. Bron: PDOK</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#wijknamen","title":"Wijknamen","text":"<p>Deze kaartlaag toont alle wijknamen van Nederland. Afhankelijk van het zoomniveau worden wijknamen weergegeven. Bron: PDOK</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#gebouw-informatie","title":"Gebouw informatie","text":"<p>Maakt een koppeling tussen pandobjecten in de 3D viewer en administratieve data uit de Basisadministratie Adressen en Gebouwen (BAG) waardoor het mogelijk is gedetailleerde informatie over het pand, enkele pandkenmerken en de adressen daarbinnen op te vragen. Bron: Kadaster</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#downloaden-3d-gebied-collada-en-dxf","title":"Downloaden 3D gebied (Collada en DXF)","text":"<p>Maakt het mogelijk alle 3D modellen uit de viewer te downloaden als een los 3D Collada (.dae) bestand of DXF (.dxf). Downloaden kan per tegel van 100x100m met een maximum van 16 tegels tegelijk.</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#maak-screenshots","title":"Maak screenshots","text":"<p>Maakt het mogelijk om van elke willekeurige camerapositie die actief is een schermafbeelding te maken, deze wordt opgeslagen als .png bestand.</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#objectenbibliotheek","title":"Objectenbibliotheek","text":"<p>Een aantal voorgedefinieerde objecten kunnen in de viewer worden geladen. Denk aan windmolens of verschillende type bomen. Objecten kunnen op willekeurige locaties geplaatst worden en bij sommige objecten zijn extra instellingen mogelijk.</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#minimap","title":"Minimap","text":"<p>Er wordt een minimap getoond waarin je als gebruiker snel naar een andere locatie kunt navigeren. Binnen de minimap geeft een selectiegebied of 'field of sight' aan welk deel van Nederland in het hoofdscherm in 3D wordt weergegeven.</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#3d-tiles","title":"3D tiles","text":"<p>Maakt het mogelijk om gebouwen en maaiveld 3D Tiles lagen toe te voegen. Bron: PDOK</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#google-realitymesh","title":"Google RealityMesh","text":"<p>Toont voor delen van Nederland een foto-realistisch beeld van de omgeving. Met de kaartlaag 'Google Reality Mesh' komt een fotorealistische laag beschikbaar in de 3D viewer. Voor grote delen van Nederland heeft Google een 3D model beschikbaar gesteld waar objecten in 3D herkenbaar worden weergegeven. Deze laag, die in 3D Tiles formaat wordt aangeboden, maakt het mogelijk om nog beter inzicht te krijgen in de werkelijke situatie.</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#zonnestand-simuleren","title":"Zonnestand simuleren","text":"<p>Hiermee kan je de Zonnestand simuleren door tijd en datum aan te passen, of de zon in de slider op te pakken en te bewegen. Daarnaast kan je een schaduwstudie maken die de dan actieve camerapositie en geladen lagen opneemt in 12 png bestanden.</p>"},{"location":"docs/handleiding/3D-viewer-functionaliteiten/#urbanreleaf-sensor-data-beta-voor-stad-utrecht","title":"UrbanReLeaf Sensor Data (BETA voor stad Utrecht)","text":"<p>Deze kaartlaag toont alle UrbanReLeaf sensor temperatuur data. Bron: PDOK</p>"},{"location":"docs/handleiding/3D-viewer-instellingen-sub/","title":"Applicatie instellingen","text":"<p>(Afbeelding) Applicatie instellingen </p>"},{"location":"docs/handleiding/3D-viewer-instellingen-sub/#beeldkwaliteit","title":"(Beeld)kwaliteit","text":"<p>Als standaard wordt de ingesteld op basis van de gebruikte computer. Daarnaast kan je in dit menu  de performance van de 3D viewer handmatig afstemmen op je persoonlijke situatie (snelheid internet, etc.). Door te kiezen voor <code>Hoog</code>, <code>Middel</code> of <code>Laag</code>, kan de (beeld)kwaliteit worden aangepast van resp. hoge, middelmatige of lage kwaliteit. De optie <code>laag</code> biedt de snelste performance, maar geeft de minste grafische kwaliteit.</p>"},{"location":"docs/handleiding/3D-viewer-instellingen-sub/#limiteer-scroll-gevoeligheid","title":"Limiteer scroll gevoeligheid","text":"<p>In sommige gevallen reageert de 3D-viewer niet optimaal op de muisbewegingen van de gebruiker. Door de optie <code>Limiteer scroll gevoeligheid</code> aan te vinken kan dit worden verbeterd.</p>"},{"location":"docs/handleiding/3D-viewer-instellingen-sub/#frames-per-seconde","title":"Frames per seconde","text":"<p>Als je deze instelling aanvinkt dan zie je rechtsboven in je scherm het aantal frames per seconde van de viewer. Dit kan helpen te bepalen welke beeldkwaliteits instelling te kiezen</p> <p>Klik op <code>x</code> (rechtsboven) om het instellingenmenu af te sluiten. Hierna toont de 3D-viewer het [default] startpunt; het centrum van Amersfoort (kadastraal nulpunt van Nederland).</p>"},{"location":"docs/handleiding/3D-viewer-instellingen/","title":"3D viewer instellingen","text":"<p> (Afbeelding) 3D-Viewer startscherm</p> <p>Het instellingenmenu is onderverdeeld in de functies;  </p> <ul> <li>Locatie bepalen (Link) </li> <li>Functionaliteiten (Link) </li> <li>Instellingen-submenu (Link) </li> </ul>"},{"location":"docs/handleiding/3D-viewer-locatie-bepalen/","title":"Locatie bepalen","text":"<p> (Afbeelding) Locatie bepalen - submenu  Met deze functie kun je de locatie invoeren. Dit kan op drie manieren;</p> <ol> <li>Door met de muis op een locatie in de map te klikken</li> <li>Door het invoeren van een plaats-, straatnaam en/of postcode</li> <li>Door bij X, Y een co\u00f6rdinaat* in te voeren</li> </ol> <p>Waarom kan ik geen gps-co\u00f6rdinaten invoeren?</p> <p>(*) Het co\u00f6rdinatenstelsel van Netherlands3d.eu is gebaseerd op het RD-co\u00f6rdinatenstelsel. Lees hier (externe link) meer over het RD-co\u00f6rdinatenstelsel.</p>"},{"location":"docs/handleiding/3D-viewer/","title":"3D-viewer","text":"<p>De 3D-viewer is de hoofdfunctionaliteit van Netherlands3D. De interface biedt toegang tot de verschillende functies. De 3D-viewer wordt geactiveerd na het klikken op de knop Bekijk de viewer op de voorpagina.</p> <p>Dit hoofdstuk beschrijft de belangrijkste functies van de 3D-viewer en de instellingen.</p>"},{"location":"docs/handleiding/3D-viewer/#beschrijving-van-het-instellingenmenu","title":"Beschrijving van het instellingenmenu","text":""},{"location":"docs/handleiding/3D-viewer/#startscherm","title":"Startscherm","text":"<p> (Afbeelding) 3D-Viewer startscherm</p> <p>Na het opstarten van de 3D viewer is het instellingen menu actief. In het instellingenmenu zijn de volgende onderdelen beschikbaar;</p> <ul> <li>Locatie bepalen (Link)</li> <li>Functionaliteiten (Link)</li> <li>Instellingen-submenu (Link)</li> </ul>"},{"location":"docs/handleiding/3D-viewer/#werkruimte","title":"Werkruimte","text":"<p> (Afbeelding) 3D-Viewer interface</p> <p>De interface is opgedeeld in het 3D-scherm met daaromheen de knoppen van de interface gegroepeerd in vier menu's:</p> <ol> <li>Werkbalk \u2013 linksboven  </li> <li>Project openen/opslaan - linksonder  </li> <li>Applicatiebalk \u2013 rechtsboven  </li> <li>Camerahoogte slider - rechts</li> <li>Informatie - onder </li> </ol>"},{"location":"docs/handleiding/3D-viewer/#werkbalk","title":"Werkbalk","text":"<p>Het hoofdmenu (linksboven) bevat de volgende functies (van boven naar onder);</p> <ul> <li>Zoekfunctie (Link)</li> <li>Object informatie (Link)</li> <li>Ondergrond doorzicht (Link)</li> <li>Lagen (Link)</li> <li>Toevoegen (link)</li> <li>Zonnestand (Link)</li> <li>Downloaden (Link) </li> </ul>"},{"location":"docs/handleiding/3D-viewer/#project-openenopslaan","title":"Project openen/opslaan","text":"<p>Het Project opslaan/openen-menu bevindt zich in de linkeronderhoek en bevat de volgende functies;</p> <ul> <li>Project opslaan (Link)</li> <li>Project openen (Link)</li> </ul>"},{"location":"docs/handleiding/3D-viewer/#applicatiebalk","title":"Applicatiebalk","text":"<p>De Applicatiebalk rechtsbovenin bevat de volgende functies (van links naar rechts):</p> <p>Schermafbeelding maken, Instellingen en Informatie.</p>"},{"location":"docs/handleiding/3D-viewer/#schermafbeelding-maken","title":"Schermafbeelding maken","text":"<p>Klik op <code>Schermafbeelding</code> om automatisch een afdruk van de 3D viewer als .png-bestand te downloaden. Bekijk de afbeelding door naar de map <code>C:\\Users\\Gebruikersnaam\\Downloads</code> te gaan`.</p>"},{"location":"docs/handleiding/3D-viewer/#instellingen","title":"Instellingen","text":"<p>Zie Instellingen</p>"},{"location":"docs/handleiding/3D-viewer/#informatie","title":"Informatie","text":"<p>De knop <code>Informatie</code> opent de Homepage in een apart browser-venster.</p>"},{"location":"docs/handleiding/3D-viewer/#camerahoogteslider","title":"Camerahoogteslider","text":"<p>Met de camerahoogteslider kan (door het blauwe cameraatje te slepen) de hoogte van de camera ingesteld worden.</p>"},{"location":"docs/handleiding/3D-viewer/#informatie_1","title":"Informatie","text":"<p>Het menu bevat de volgende functies:</p> <p> </p>"},{"location":"docs/handleiding/3D-viewer/#weergave-naar-noorden-draaien","title":"Weergave naar noorden draaien","text":"<p>Klik op <code>Weergave naar noorden draaien</code> om de kijkrichting automatisch naar het noorden te richten.   </p> <p> </p>"},{"location":"docs/handleiding/3D-viewer/#orthografischperspectief","title":"Orthografisch/perspectief","text":"<p>Klik op <code>Wissel tussen Orthografisch/perspectief</code> om de kijkrichting automatisch in loodrecht naar beneden en zonder perspectief te wijziggen. Klik nogmaals om het beeld terug te brengen naar de oorspronkelijke toestand.</p> <p></p>"},{"location":"docs/handleiding/3D-viewer/#mini-map","title":"Mini-map","text":"<p>De minimap is de kleine versie van de map bij instellingen zie 2. Instellingen Beweeg met de muis over de minimap om deze te vergroten. Door op een locatie in de minimap te klikken wordt in de 3D viewer bijbehorende locatie weergegeven.</p> <p>Met de knoppen <code>+/-</code> of met je scroll-wiel kan worden in-/uitgezoomd.</p>"},{"location":"docs/handleiding/3D-viewer/#positie","title":"Positie","text":"<p>In de onderbalk van de viewer staan (rechts) de co\u00f6rdinaten van de positie van de viewer. </p> <p>Waarom zie ik x,y,z-co\u00f6rdinaten en geen gps-co\u00f6rdinaten?</p> <p>Het co\u00f6rdinatenstelsel van Netherlands3D is gebaseerd op het rijksdriehoeksstelsel. Lees hier meer over het rijksdriehoeksstelsel.</p>"},{"location":"docs/handleiding/3D-viewer/#navigeren","title":"Navigeren","text":"<p>Het scherm toont de locatie die in het instellingenmenu is ingevoerd of \u2013 als er geen invoer is gedaan - de default-locatie (het kadastrale nulpunt van Nederland in het centrum van Amersfoort). Het beeld is in perspectief, onder een lichte hoek en vanaf een hoogte van 300 meter.</p>"},{"location":"docs/handleiding/3D-viewer/#besturen-en-navigeren","title":"Besturen en navigeren","text":"<p><code>Verplaats de muis</code> al dan niet in <code>combinatie met muisknoppen en/of toetsenbordknoppen</code> om door de 3D wereld in de viewer te navigeren.</p> <p>Dit kan op verschillende manieren;</p>"},{"location":"docs/handleiding/3D-viewer/#scrollzoom","title":"[Scroll/Zoom]","text":"<p><code>Verdraai het muiswiel</code> om naar voren of naar achteren te bewegen in de kijkrichting.</p> <p>standaard of snel zoomen</p> <p>Standaard scrollen geeft een normale snelheid van in- uitzoomen. Met de SHIFT-knop ingedrukt kan je 2x zo snel in- uitzoomen. Wel zo handig!</p> <p>(Video) Scroll/Zoom</p>"},{"location":"docs/handleiding/3D-viewer/#panning","title":"[Panning]","text":"<p>Door met de <code>muis \u00e9n de ingedrukte linkermuisknop</code> over het scherm <code>omhoog of omlaag</code> of <code>naar links of naar rechts te bewegen</code>, kan de kijker zich resp. omhoog of omlaag of resp. naar links of naar rechts in de 3D wereld verplaatsen.</p> <p>(Video) Panning</p>"},{"location":"docs/handleiding/3D-viewer/#draaien-manier-a","title":"[Draaien manier A.]","text":"<p>Door met de <code>muis en de ingedrukte middelste muisknop</code> over het scherm te <code>bewegen</code>, kan de kijker <code>om het kijkpunt heen draaien</code>. Alternatief; Dit kan ook met de <code>linkermuisknop in combinatie met de alt-toets</code>.</p> <p>(Video) Draaien manier A.</p>"},{"location":"docs/handleiding/3D-viewer/#draaien-manier-b","title":"[Draaien manier B.]","text":"<p>Door met de <code>muis en de ingedrukte linkermuisknop</code> in <code>combinatie met de ctrl-toets</code> over het scherm te <code>bewegen</code>, kan de kijker het beeld <code>naar links of naar rechts en/of naar boven of naar beneden draaien</code>.</p> <p>(Video) Draaien manier B.</p>"},{"location":"docs/handleiding/bibliotheek-basis/","title":"Bibliotheek","text":"<p>Functies, Lagen, submenu.  </p> <p> Activeren Bibliotheek</p>"},{"location":"docs/handleiding/bibliotheek-basis/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":""},{"location":"docs/handleiding/bibliotheek-basis/#menu","title":"Menu","text":"<p>Met de functie Bibliotheek zijn alle objecten uit de objectenbibliotheek, het toevoegen van Fotorealistische wereld (Google realitymesh), basislagen, tekengebieden, 3D-Tiles, Urban Releaf lagen, objecten en catalogi onder \u00e9\u00e9n knop gebundeld.</p> <p> opzet Bibliotheek</p>"},{"location":"docs/handleiding/bibliotheek-basis/#fotorealistische-wereld","title":"Fotorealistische Wereld","text":"<p>Met de functie Fotorealistische Wereld kan je de 3D tiles van Google Earth koppelen en visualiseren in Netherlands3D.eu. Voor gedetailleerde informatie over de werking klik op deze link: Toevoegen Fotorealistische wereld</p>"},{"location":"docs/handleiding/bibliotheek-basis/#basislagen","title":"Basislagen","text":"<p>Met de functie Basislagen kan je de 4 beschikbare basislagen (opnieuw) koppelen in Netherlands3D.eu. Voor gedetailleerde informatie over de werking klik op deze link: Toevoegen basislagen</p>"},{"location":"docs/handleiding/bibliotheek-basis/#tekengebied","title":"Tekengebied","text":"<p>Met de functie Basislagen kan je Tekengebieden toevoegen in Netherlands3D.eu. Voor gedetailleerde informatie over de werking klik op deze link: Toevoegen tekengebied</p>"},{"location":"docs/handleiding/bibliotheek-basis/#3d-tiles","title":"3D Tiles","text":"<p>Met de functie 3D Tiles kan je basis 3D Tiles lagen toevoegen in Netherlands3D.eu. Voor gedetailleerde informatie over de werking klik op deze link: Toevoegen 3D Tiles</p>"},{"location":"docs/handleiding/bibliotheek-basis/#urban-releaf","title":"Urban Releaf","text":"<p>Met de functie Urban Releaf kan je de Urban Releaf lagen toevoegen in Netherlands3D.eu. (zijn alleen actief binnen Utrecht) Voor gedetailleerde informatie over de werking klik op deze link: Toevoegen Urban Releaf</p>"},{"location":"docs/handleiding/bibliotheek-basis/#objecten","title":"Objecten","text":"<p>Met de functie Objecten kan je de objecten uit de objectenbibliotheek toevoegen in Netherlands3D.eu. Voor gedetailleerde informatie over de werking klik op deze link: Toevoegen objecten bibliotheek</p> <p>Je vindt de Bibliotheek op 2 manieren</p> <p>Naast dat je de bibliotheek vindt in het linksondermenu, kan je de bibliotheek ook vinden door op het <code>+</code> teken te klikken en vervolgens op de knop <code>Vanuit bibliotheek</code> te klikken. Je komt dan ook direct in de bibliotheek.</p>"},{"location":"docs/handleiding/first-person-viewer/","title":"First Person Viewer","text":"<p>De First Person Viewer maakt het mogelijk voor gebruikers om zich op realistische ooghoogte door de 3D-wereld te bewegen. Zo kan je ervaren hoe een aangepaste omgeving te beleven is vanaf ooghoogte.</p>"},{"location":"docs/handleiding/first-person-viewer/#beginnen","title":"Beginnen","text":"<p>Om de First Person Viewer te starten, volg je de onderstaande stappen:</p> <ol> <li>Zet de functionaliteit aan via Instellingen \u2192 Functionaliteiten \u2192 First Person Viewer.</li> <li>Er verschijnt een First Person Viewer-knop rechtsonder in beeld, naast de noordpijl.</li> <li>Sleep het poppetje uit de knop naar de gewenste locatie in de wereld waar je wilt rondlopen. Vanaf hier opent de First Person Viewer.</li> </ol> <p></p> <p> </p>"},{"location":"docs/handleiding/first-person-viewer/#verlaten","title":"Verlaten","text":"<p>Je kunt de first person viewer verlaten door rechtsboven op de knop \u2018verlaat first-person-viewer\u2019 te klikken. Ook kun je de Backspace toets twee seconden vasthouden om de first person viewer te verlaten. Als muisvergrendeling aanstaat, kun je de muis loslaten door \u00e9\u00e9nmaal op Backspace te drukken.</p> <ul> <li>Houd de Backspace-toets 2 seconden ingedrukt. Linksboven in het scherm verschijnt een voortgangsbalk zien die aangeeft hoe lang je backspace nog moet indrukken voordat je de first person viewer verlaat.</li> <li>Druk \u00e9\u00e9n keer op Backspace om de muis vrij te geven, en klik vervolgens rechtsboven op de 'verlaten' knop om de First Person Viewer te verlaten. </li> </ul> <p> </p>"},{"location":"docs/handleiding/first-person-viewer/#muisvergrendeling","title":"Muisvergrendeling","text":"<p>Om je muis automatisch te vergrendelen kun je muisvergrendeling aanzetten in de instellingen. </p> <p>Deze instelling zorgt ervoor dat je de muis niet ingedrukt hoeft te houden tijdens het bewegen, wat aan te raden is bij het opnemen van video\u2019s of tijdens een showcase. Om de muis los te ontgrendelen druk je eenmaal op Backspace. </p>"},{"location":"docs/handleiding/first-person-viewer/#besturing","title":"Besturing","text":"<p>Er zijn verschillende manieren van bewegen in de first person viewer. Je kunt lopen, vliegen, fietsen en autorijden, in aparte bewegingsmodi.</p> <p>Besturing kan op drie manieren, kies de methode die voor jou het prettigst werkt.</p> Pijltjestoetsen <p>Met de pijltjestoetsen kun je rondbewegen in de First Person Viewer. Door te klikken en je muis te bewegen, verander je je kijkrichting. De pijltjestoetsen bewegen je vervolgens in die richting. Op dit onderstaande kaartje is zichtbaar welke knoppen waarvoor dienen:</p> <p> </p> <p>Bewegingsmodi:</p> <ul> <li>Versnellen: houdt Shift ingedrukt.</li> </ul> <p>Loopmodus:</p> <ul> <li>Springen: druk op Spatiebalk.</li> </ul> <p>Vliegmodus:</p> <ul> <li>Omhoog vliegen: Spatiebalk of PageUp.</li> <li>Omlaag vliegen: PageDown.</li> </ul> <p>Automodus en fietsmodus:</p> <ul> <li>Sturen: Gebruik pijltjes naar links en rechts om het voertuig te sturen. In deze modi kun je vrij rondkijken zonder de voertuigen te draaien met de camera.</li> <li>Handrem: Spatie</li> </ul> Wasd <p>Je kunt ook kiezen om rond te bewegen door de knoppen 'W, A, S en D' te gebruiken. </p> <ul> <li>Vooruit: W.</li> <li>Achteruit: S.</li> <li>Links: A.</li> <li>Rechts: D.</li> </ul> <p>Deze knoppen zijn bepaald met respect tot hun positie op het toetsenbord, net als de pijltjestoetsen.  Door te klikken en je muis te bewegen, verander je je kijkrichting. De knoppen 'W, A, S, en D' zullen jou bewegen in de gekozen kijkrichting.</p> <p>Onderstaand kaartje toont de knoppenindeling:</p> <p> </p> <p>Bewegingsmodi</p> <ul> <li>Versnellen: houdt Shift ingedrukt.</li> </ul> <p>Loopmodus:</p> <ul> <li>Springen: druk op Spatiebalk.</li> </ul> <p>Vliegmodus:</p> <ul> <li>Omhoog vliegen: Spatiebalk of Q.</li> <li>Omlaag vliegen: E.</li> </ul> <p>Automodus en fietsmodus:</p> <ul> <li>Sturen: Gebruik \"A\" en \"D\" om het voertuig te sturen. In deze modi kun je vrij rondkijken zonder de voertuigen te draaien met de camera.</li> <li>Handrem: Spatie</li> </ul> Controller <p>Met een game-controller kun je de FPV makkelijk besturen met exacte controle. Op dit onderstaande kaartje is zichtbaar welke knoppen waarvoor dienen:</p> <p> </p> <ul> <li>Bewegen: Linker stick</li> <li>Camera draaien: Rechter stick</li> <li>Springen: Knop-Zuid</li> <li>Omhoog vliegen: Knop-Zuid, R2 (ligt aan soort controller.)</li> <li>Omlaag vliegen: L2</li> <li>Switch movement Modus: Left &amp; Right</li> </ul>"},{"location":"docs/handleiding/first-person-viewer/#algemene-besturing","title":"Algemene besturing:","text":"<p>Wisselen tussen bewegingsmodi: Tab of Enter.</p> <p>De camera te draaien zonder de muis: </p> <ul> <li>Omhoog draaien: I.</li> <li>Omlaag draaien: K.</li> <li>Naar links draaien: J.</li> <li>Naar rechts draaien: L.</li> </ul> <p>Handige sneltoetsen:</p> <ul> <li>Schermafbeelding: C en Option/Start</li> <li>\"Snap\" naar het hoogste niveau: R en Controller-Up.</li> <li>Presentatiemodus: H en Controller-Down*.</li> </ul>"},{"location":"docs/handleiding/first-person-viewer/#movement-modus","title":"Movement Modus","text":"<p>De first person viewer heeft vier bewegings-modi, lopen en vliegen. Je kunt van modus wisselen door:</p> <ul> <li>In het instellingenpaneel een andere modus aan te klikken.</li> <li>De toetsen Tab en Enter te gebruiken.</li> </ul> <p>In het instellingenpaneel kun je de instellingen van de huidige modus aanpassen. Typ zelf de gewenste waardes in en klik vervolgens uit het veld om de waardes vast te leggen.</p> <p> </p>"},{"location":"docs/handleiding/first-person-viewer/#functionaliteiten","title":"Functionaliteiten","text":"<p>De first person viewer heeft enkele functionaliteiten die in de beta versie beschikbaar zijn voor gebruik:</p> Gebouwen-informatie <p>Klik met de muis op het betreffende gebouw. Als u muisvergrendeling gebruikt, verschijnt er een cursor in het midden van uw scherm. Richt deze cursor  op het gewenste gebouw en klik.  In de interface verschijnt gebouwinformatie, uit de Basisadministratie Adressen en Gebouwen (BAG). Let op, houd voor deze functionaliteit uw muis stil wanneer u klikt, bewegende selectie wordt meestal niet gedetecteerd.</p> <p> </p> Ondergronds-kijken <p>Bij het activeren van deze functie verschijnt een cirkel op het grondvlak, waarmee je ondergronds kunt kijken. In de interface die opent, kun je de grootte van de circel, en de lagen die gebruikt worden aanpassen. </p> <p> </p> Zonnestand-simuleren <p>Hiermee kan je de Zonnestand simuleren door tijd en datum aan te passen, of de zon in de slider op te pakken en te bewegen.</p> <p> </p> Lagenpaneel-simpel <p>In dit paneel kun je lagen aan en uit zetten. Dit paneel is ontworpen om situaties te vergelijken, aanpassingen kunnen alleen buiten de first person viewer gemaakt worden.  Je kunt ook een first-person-positie opslaan door de knop onderaan de interface te klikken. Door dubbel te klikken op de laag, kun je de positie weer innemen, met alle gegevens van beweging opgeslagen. De first-person positie kan je ook intreden buiten de first person viewer. Deze posities kan je in het standaard lagenpaneel bewerken. Een first-person positie kan ook worden aangemaakt vanuit de bibliotheek.</p> <p> </p> Meet-tool <p>Meet afstanden snel op. </p> <p>Open het paneel. Klik in de wereld om een meetpunt aan te maken. Klik nogmaals elders om een tweede punt aan te maken. Hiertussen zal automatisch een lijn komen met daarbij de afstand tussen de twee punten. Je kunt meerdere punten maken, waar elk opvolgende punt een nieuwe lijn maakt. Klik op het kruisje in een meting in de interface om een lijn te verwijderen. Let op: deze afmetingen zijn benaderingen, de afstanden zijn niet exact. </p> <p> </p> <ul> <li> <p>Noordpijl. Klik om camera naar het noorden te draaien.</p> </li> <li> <p>Reset to start: Deze button hersteld de beginpositie van de first person viewer.</p> </li> <li> <p>Snap up: Verplaatst je naar de hoogste positie boven je. (Handig voor als je onder het maaiveld of een gebouw bent gekomen).</p> </li> </ul> <p> </p>"},{"location":"docs/handleiding/gebied-downloaden/","title":"Gebied downloaden","text":"<p>Functie, hoofdmenu.  </p> <p></p> <p>Met de functie Gebied Downloaden kunnen delen van een gebied als bestand worden gedownload (in de formaten .DAE en .DXF). Deze functie bevordert de aansluiting en uitwisseling met andere visualisatie- en CAD programma's.  Dit hoofdstuk beschrijft de belangrijkste functies van Gebied Downloaden en geeft uitleg over de interface en essenti\u00eble functies.  </p>"},{"location":"docs/handleiding/gebied-downloaden/#beschrijving","title":"Beschrijving","text":"<p>Met Gebied downloaden kunnen delen van een gebied worden opgeslagen en in andere software worden ingeladen. </p> <p>(Video) Gebied downloaden</p>"},{"location":"docs/handleiding/gebied-downloaden/#menu","title":"Menu","text":"<p>Door met de muis op het <code>Gebied downloaden-icoon</code> in het hoofdmenu te klikken wordt de tool actief. Het menu klapt open en de instellingen worden zichtbaar.</p> <p> (Afbeelding) Gebied downloaden-menu</p>"},{"location":"docs/handleiding/gebied-downloaden/#werking","title":"Werking","text":"<p> (Afbeelding) Gebied downloaden, 100x100 sectie</p> <p> (Afbeelding) Meerdere secties van 100x100 geselecteerd.</p> <p>Waarom kan ik het selectiegebied niet roteren?</p> <p>Het selectiegebied is altijd loodrecht op de horizontale-as/op het noorden geori\u00ebnteerd.</p>"},{"location":"docs/handleiding/gebied-downloaden/#gebied-downloaden_1","title":"Gebied downloaden","text":"Na het activeren van de functionaliteit wordt het menu actief en kun je met de muis meerdere secties van 100x100 meter selecteren."},{"location":"docs/handleiding/gebied-downloaden/#selecteer-gebied","title":"Selecteer gebied","text":"Door met de muis, in combinatie met de linkermuisknop en shift-toets te slepen kun je het selectiegebied vergroten."},{"location":"docs/handleiding/gebied-downloaden/#export-format-kiezen","title":"Export format kiezen","text":"(Afbeelding) Keuze voor export format."},{"location":"docs/handleiding/gebied-downloaden/#coordinaten-huidige-selectie","title":"Co\u00f6rdinaten huidige selectie","text":"<p>Met deze functie kun je de co\u00f6rdinaten van het hoekpunt zuidwest en het hoekpunt noordoost naar het klembord kopi\u00ebren.</p>"},{"location":"docs/handleiding/gebied-downloaden/#voorwaarden","title":"Voorwaarden","text":"<p>NB! Voordat je het geselecteerde gebied kunt downloaden, dien je akkoord te gaan met de voorwaarden door <code>Ik ga akkoord met de voorwaarden</code>. Je vindt de link onder; <code>Rechtenbeleid 3D basisvoorziening</code> &amp;  <code>Gebruiksvoorwaarden 3DBag</code>.</p>"},{"location":"docs/handleiding/gebied-downloaden/#downloaden","title":"Downloaden","text":"<p>Klik op <code>download</code> om een .DAE (Collada) of .DXF (CAD) bestand te downloaden. Het bestand kun je in een 3D modelleerprogramma zoals bijvoorbeeld Blender, Sketchup of CAD software importeren en bewerken.</p>"},{"location":"docs/handleiding/homepage/","title":"Homepage","text":"<p>Op de homepage is algemene informatie over het Netherlands3D project te vinden. Naast de functionaliteiten bieden we specifiek voor twee doelgroepen informatie aan: voor organisaties/gebruikers en Voor ontwikkelaars.</p>"},{"location":"docs/handleiding/homepage/#hoofdstukken","title":"Hoofdstukken","text":"<p>(Afbeelding) Hoofdmenubalk</p>"},{"location":"docs/handleiding/homepage/#functionaliteiten-en-functies","title":"Functionaliteiten en functies","text":"<p>In het hoofdstuk Handleiding vind je een gedetailleerde beschrijving van alle functionaliteiten en functies ondersteund met afbeeldingen en/of filmpjes.</p>"},{"location":"docs/handleiding/homepage/#voor-organisaties","title":"Voor organisaties","text":"<p>Dit hoofdstuk is onder ontwikkeling en bevat straks een uitgebreide bron van informatie. Het doel is om organisaties te ondersteunen met gidsen, best practices en antwoorden op veel gestelde vragen die essentieel zijn voor het gebruik van het Netherlands3D platform.</p>"},{"location":"docs/handleiding/homepage/#voor-ontwikkelaars","title":"Voor ontwikkelaars","text":"<p>Ben je een ontwikkelaar en wil je bijvoorbeeld eigen functie binnen Netherlands3D ontwikkelen? Dan vind je in dit hoofdstuk de benodigde technische documentatie. Deze documentatie is bedoeld voor ontwikkelaars die willen begrijpen hoe het platform werkt, de architectuur willen verkennen en nieuwe modules of functie willen bijdragen.</p>"},{"location":"docs/handleiding/homepage/#schermmodus","title":"Schermmodus","text":"<p>Door op het <code>Schermmodus-icoon</code> te klikken kan de interface kan de modus veranderd worden in <code>Dark</code>; lichte tekst op een donkere achtergrond of <code>Light</code>; donkere tekst op een lichte achtergrond. In de Dark modus gebruikt het systeem minder energie en hoeft het systeem in het geval van een laptop minder snel te worden opgeladen.</p> <p> (Afbeelding) Dark/Light modus</p>"},{"location":"docs/handleiding/homepage/#zoeken","title":"Zoeken","text":"<p>Deze zoekfunctie biedt de mogelijkheid om naar trefwoorden te zoeken binnen Netherlands3D. Vul de zoekterm(en) in bij <code>Zoeken</code> en de lijst met klikbare resultaten wordt in de context (hoofdstuk en alinea) getoond.</p>"},{"location":"docs/handleiding/homepage/#headline","title":"Headline","text":"<p>(Afbeelding) Headline</p>"},{"location":"docs/handleiding/homepage/#bekijk-de-viewer","title":"Bekijk de viewer","text":"<p>Klik op <code>Bekijk de viewer</code> in de headline om de 3D-viewer functionaliteit te starten. (Zie 3D-viewer functionaliteit  voor de beschrijving.)  </p>"},{"location":"docs/handleiding/homepage/#wat-is-het","title":"Wat is het","text":"<p>Met de knop <code>Wat is het?</code> wordt de tekst \u2019Wat is Netherlands3D?\u2019 onder het overlay scherm naar boven gehaald.</p>"},{"location":"docs/handleiding/homepage/#content","title":"Content","text":"<p>(Afbeelding) Content</p> <p>De content bevat een algemene beschrijving van Netherlands3D.</p>"},{"location":"docs/handleiding/homepage/#footer","title":"Footer","text":"<p>(Afbeelding) Footer</p> <p>Deze laag bevat de logo's van de bij Netherlands3D betrokken provincies en de mogelijkheid om door de hoofdstukken van het hoofdmenu in de hoofdbalk te bladeren.</p>"},{"location":"docs/handleiding/lagen-toevoegen/","title":"Lagen toevoegen","text":"<p>Basisfunctie, hoofdmenu.</p> <p></p> <p>Lagen is onderdeel van de basisfuncties van Netherlands3d.eu. Deze functie biedt de mogelijkheden om datalagen en objecten uit verschillende bronnen te (ont)koppelen en de zichtbaarheid hiervan aan te passen.   Dit hoofdstuk beschrijft de belangrijkste functies van Lagen en geeft uitleg over de gebruikersinterface en essenti\u00eble functies. Voor meer informatie kijk bij Lagen importeren</p>"},{"location":"docs/handleiding/lagen-toevoegen/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":""},{"location":"docs/handleiding/lagen-toevoegen/#menu-linksonder","title":"Menu (linksonder)","text":"<p>Door met de muis op het <code>Lagen-icoon</code> in het hoofdmenu te klikken wordt de tool actief. en het <code>toevoegen-menu</code> klapt open en de functies worden zichtbaar.</p> <p> Overzicht</p>"},{"location":"docs/handleiding/lagen-toevoegen/#functies","title":"Functies","text":""},{"location":"docs/handleiding/lagen-toevoegen/#organiseren","title":"Organiseren","text":"<p>Met het <code>Map-icoon</code> wordt een folder aangemaakt waarvan de naam kan worden aangepast (dubbelklikken) en waarin de gekoppelde lagen of objecten kunnen worden gesleept. Dit helpt bij het organiseren en overzichtelijk houden van de gekoppelde lagen en/of objecten.</p> <p> toevoegen folder-menu</p>"},{"location":"docs/handleiding/lagen-toevoegen/#verwijderen","title":"Verwijderen","text":"<p>Met het <code>Prullenbak-icoon</code> wordt de geselecteerde laag of object verwijderd. Dit kan ook met de <code>del/delete-toets</code> van het toetsenbord. NB! Sla voor het verwijderen alle instellingen op met <code>Project Opslaan</code>. </p> <p> verwijderen-menu</p> <p>Waar is de undo-functie?</p> <p>Sla na toevoegingen en/of aanpassingen het project regelmatig op. Er is geen UNDO-functie in Netherlands3D.eu.</p>"},{"location":"docs/handleiding/lagen-toevoegen/#toevoegen","title":"Toevoegen","text":"<p>Het toevoegen van lagen gebeurt via de bibliotheek. Voor meer informatie klik hier  Bibliotheek</p>"},{"location":"docs/handleiding/lagen/","title":"Lagen","text":"<p>Basisfunctie, hoofdmenu.  </p> <p></p> <p>Lagen is onderdeel van de basisfuncties van Netherlands3d.eu. Deze functie biedt de mogelijkheden om datalagen en objecten uit verschillende bronnen te (ont)koppelen en de zichtbaarheid hiervan aan te passen.   Dit hoofdstuk beschrijft de belangrijkste functies van lagen en geeft uitleg over de gebruikersinterface en essenti\u00eble functies.  </p>"},{"location":"docs/handleiding/lagen/#overzicht-van-de-functies","title":"Overzicht van de functies","text":"<p>Door het uit-/aanvinken van datalagen worden deze verborgen of getoond.  Met behulp van links en/of het importeren van bestanden worden datalagen en objecten gekoppeld.</p> <p>(Video) gebruik van Lagen</p>"},{"location":"docs/handleiding/lagen/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":""},{"location":"docs/handleiding/lagen/#menu-linksboven","title":"Menu (linksboven)","text":"<p>Door met de muis op het <code>Lagen-icoon</code> in het hoofdmenu te klikken wordt de tool actief. Het menu klapt open en de basislagen worden zichtbaar.</p> <p> (Afbeelding) lagen-menu</p>"},{"location":"docs/handleiding/lagen/#functies","title":"functies","text":"<p> (Afbeelding) Rangschikken van lagen</p> <p>Waarom zie ik geen effect bij het verslepen van de lagen?</p> <p>Het verplaatsen van lagen heeft alleen een zichtbaar effect bij lagen waarin WMS-data gekoppeld is. zie Voorbeeld koppelen bestand met URL.</p> <p> (Afbeelding) Transformatie tool geactiveerd door selectie in Lagen </p> <p> (Afbeelding) Instellingen actief</p> <p>Bij het laden van .OBJ, .GLB, WFS en GeoJSON lagen is er de mogelijkheid om de kleuren van de geladen data te  wijzigen. Dat geldt ook de standaard terreinlaag. De gebouwenlaag volgt later en ook de mogelijkheid om kleuren te herstellen volgt later. Hoe je de kleuren wijzigt, lees je hieronder.</p> <p></p> <p>Door op het instellingen icoon te klikken open je het instellingenvenster waar, wanneer van toepassing, het kleurenpaneel zichtbaar wordt.</p> <p></p> <p>Met het kleurenpaneel kan je kleuren en transparantie van basis en toegevoegde lagen aanpassen (deze kunnen materiaal kleuren uit een .mtl bestand overrulen). Door op een kleur in de cirkel te klikken, of door op het rondje in de kleurenwaaier te klikken en te verslepen, kan je jouw gewenste kleur kiezen. De saturatie is dan nog aanpasbaar via de meest rechtse horizontale balk. Daarnaast kan de transparantie van de kleur worden aangepast (werkt voorlopig alleen voor WFS/GeoJSON). Ook kan je een Hexadecimale Kleurcode invullen in het onderste veld.</p> <p>De kleur van de geladen en geselecteerde laag zal nu wijzigen naar de gekozen kleur.</p>"},{"location":"docs/handleiding/lagen/#standaardlagen","title":"Standaardlagen","text":"<p>De lagen Bomen, Bossen, Gebouwen en Maaiveld zijn in de basisversie standaard gekoppeld.</p>"},{"location":"docs/handleiding/lagen/#laagvolgorde","title":"Laagvolgorde","text":"<p>Met de muis en linkermuisknop kan de volgorde van de lagen worden gewijzigd. <code>Klik</code> op een laag en <code>sleep</code> de laag naar de gewenste plek door de <code>linkermuisknop</code> ingedrukt te houden. Door de laag op een andere laag te slepen wordt deze onder die laag gekoppeld. Sleep je de laag tussen twee lagen, Dan wordt deze er tussen geplaatst na het <code>loslaten</code> van de <code>linkermuisknop</code>. Met deze functie kunnen lagen op- of juist onder elkaar worden gesorteerd.</p>"},{"location":"docs/handleiding/lagen/#tonenverbergen","title":"Tonen/verbergen","text":"<p>Klik op het <code>oog</code> voor het verbergen of tonen van de inhoud van de datalagen in de 3D-Viewer.</p>"},{"location":"docs/handleiding/lagen/#transformatie-tool","title":"Transformatie tool","text":"<p>De locatie, ori\u00ebntatie en schaal van toegevoegde objecten wordt met de transformatie tool aangepast.</p>"},{"location":"docs/handleiding/lagen/#eigenschappen","title":"Eigenschappen","text":"Van toegevoegde objecten en sommige lagen kunnen eigenschappen zoals b.v. de locatie, ori\u00ebntatie en schaal maar ook object/laag specifieke eigenschappen worden aangepast. Klik op het <code>Eigenschappen-icoon</code> om het eigenschappenmenu te openen."},{"location":"docs/handleiding/lagen/#kleurenpaneel","title":"Kleurenpaneel","text":""},{"location":"docs/handleiding/lagen/#afgeschermde-bronnen","title":"Afgeschermde bronnen","text":""},{"location":"docs/handleiding/lagen/#invullen-gebruikersnaam-en-wachtwoord","title":"Invullen gebruikersnaam en wachtwoord","text":"<p>Als er een laag van een afgeschermde bron wordt geladen (via het importeren menu), krijg je bovenstaande venster in beeld. Dit kunnen WMS/WFS/GeoJSON en 3D-Tiles lagen zijn, welke je via een bestand of url koppelt. In dit venster vul je gebruikersnaam en wachtwoord in.</p>"},{"location":"docs/handleiding/lagen/#switchen-tussen-gebruikersnaamwachtwoord-en-code","title":"Switchen tussen gebruikersnaam/wachtwoord en code","text":"<p>Wanneer je geen gebruikersnaam en wachtwoord hebt, maar alleen een code (bijvoorbeeld een API-key) dan kan je via bovenstaande knop switchen tussen gebruikersnaam/wachtwoord en code.</p>"},{"location":"docs/handleiding/lagen/#invullen-code","title":"Invullen Code","text":"<p>In dit venster vul je alleen de code in.</p> <p>Als je de gegevens hebt ingevuld, wordt de laag gemaakt en de gegevens uit bestand of bron geladen.</p>"},{"location":"docs/handleiding/object-informatie/","title":"Object Informatie","text":"<p>Functie, hoofdmenu.</p> <p></p> <p>Met de BAG Object Informatie tool kan de gebruiker schematische 3D modellen van alle objecten in Nederland bekijken en gedetailleerde object (gebouw) informatie opvragen. BAG Object Informatie is onderdeel van de basisfuncties in Netherlands3D.eu. Alle objecten op de laag 'Gebouwen' komen uit de 3DBAG. Dit is een up-to-date land dekkende dataset met 3D gebouwmodellen van Nederland. Dit hoofdstuk beschrijft de belangrijkste functies van BAG Object Informatie en geeft uitleg over de interface en essenti\u00eble functies.</p>"},{"location":"docs/handleiding/object-informatie/#overzicht-van-functies","title":"Overzicht van functies","text":"<p>Door een object te selecteren kan gedetailleerde object informatie worden opgevraagd.</p> <p>(Video) Object informatie</p>"},{"location":"docs/handleiding/object-informatie/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":""},{"location":"docs/handleiding/object-informatie/#menu","title":"Menu","text":"<p>Na het klikken op de het (bovenste) <code>BAG Informatie-icoon</code> van het hoofdmenu, klapt het Object informatie-menu open en verschijnt onderstaande tekst in beeld.</p> <p> </p> <p>(Afbeelding) Object informatie-toelichting</p>"},{"location":"docs/handleiding/object-informatie/#object-selectie","title":"Object selectie","text":"<p>Klik op een <code>gebouw in de 3D-Viewer</code> om de Basisregistratie Adressen en Gebouwen (BAG) informatie te bekijken. Het geselecteerde object wordt blauw en de offici\u00eble object informatie verschijnt.</p> <p></p> <p>(Afbeelding) Object informatie-paneel</p>"},{"location":"docs/handleiding/object-informatie/#object-informatie_1","title":"Object informatie","text":"<p>De Object informatie bevat de volgende data.</p> <p>Praktische informatie</p> <ul> <li>BAG ID    0000000000000000   </li> <li>Status   </li> <li>Bouwjaar  [Jaartal]  </li> </ul> <p>(Adress(en))</p> <ul> <li>Adres en Huisnummer  </li> </ul> <p>Kan ik meer BAG informatie krijgen?</p> <p>Ja dat kan zeker, door op het BAG ID te klikken van het pand wat is geselecteerd, wordt je doorgestuurd naar de BAG-viewer van het kadaster en ingezoomd op het geselecteerde pand in de 3D-Viewer. </p>"},{"location":"docs/handleiding/object-informatie/#aanvullende-technische-details","title":"Aanvullende technische details","text":"<p>De 3DBAG is een up-to-date landsdekkende dataset met 3D gebouwmodellen van Nederland. De 3DBAG is open data. Het bevat 3D modellen op verscheidene detailniveaus welke zijn gegenereerd door de combinatie van twee open datasets: de pand-gegevens uit de BAG en de hoogtegegevens uit de AHN. De 3DBAG wordt regelmatig ge\u00fcpdatet met de meest recente openlijk beschikbare pand- en hoogtegegevens.</p> <p>Via Netherlands3d.eu is het mogelijk vierkante tegels van 100x100 meter te downloaden.</p> <p>Ga hiervoor naar de optie Gebied downloaden in het hoofdmenu.</p>"},{"location":"docs/handleiding/object-informatie/#referenties","title":"Referenties","text":"<p>Link naar de API van het Kadaster</p>"},{"location":"docs/handleiding/ondergrond-doorzicht/","title":"Ondergrond doorzicht","text":"<p>Functie, hoofdmenu.  </p> <p></p> <p>Ondergrond doorzicht is onderdeel van de basisfuncties in Netherlands3D.eu. Ondergrond doorzicht is een functie die is ontworpen om gebruikers een uitgebreid beeld te geven van de ondergrondse omgeving. Door ondergrondse structuren te visualiseren, kunnen professionals op verschillende gebieden weloverwogen beslissingen nemen en hun operationele effici\u00ebntie verbeteren.  Dit hoofdstuk beschrijft de werking van ondergrond doorzicht en geeft uitleg over de interface en essenti\u00eble onderdelen. Daarnaast is er een overzicht van de mogelijkheden en toepassingen van de functie en laat zien hoe ondergrond doorzicht dient als een essenti\u00eble bron voor het verkennen van wat er onder de oppervlakte ligt.</p>"},{"location":"docs/handleiding/ondergrond-doorzicht/#overzicht","title":"Overzicht","text":"<p>Met het doorzicht koepelvenster worden delen van datalagen en/of objecten welke zich onder het maaiveld en binnen de straal van het venster bevinden zichtbaar gemaakt. Met de muis kan het venster verplaatst worden waardoor andere ondergrondse delen zichtbaar worden.</p> <p>(Video) Ondergrond doorzicht </p>"},{"location":"docs/handleiding/ondergrond-doorzicht/#gedetailleerde-beschrijving-van-de-functie","title":"Gedetailleerde beschrijving van de functie","text":""},{"location":"docs/handleiding/ondergrond-doorzicht/#menu","title":"Menu","text":"<p>Door met de muis op het <code>Ondergrond doorzicht-icoon</code> in het hoofdmenu te klikken wordt de tool actief. Het doorzicht koepelvenster is nu aan de locatie/beweging van de muis gekoppeld.</p> <p> (Afbeelding) Ondergrond doorzicht</p>"},{"location":"docs/handleiding/ondergrond-doorzicht/#werking","title":"Werking","text":"<p> (Afbeelding) Aanpassen diameter koepelvenster</p>"},{"location":"docs/handleiding/ondergrond-doorzicht/#gebruikverplaatsen","title":"Gebruik/verplaatsen","text":"<p>De koepel beweegt mee met de muis over het gebied waarvan de ondergrond zichtbaar moet worden gemaakt.</p>"},{"location":"docs/handleiding/ondergrond-doorzicht/#aanpassen-grootte-diameter","title":"Aanpassen grootte diameter","text":"<p>Door met de muis over het witte vierkant te bewegen verschijnt een hand waarmee na het <code>[klikken en vasthouden van de linkermuisknop]</code> en het slepen van de muis de grootte van het doorzicht koepelvenster kan worden aangepast. Hiermee wordt een groter c.q. kleiner gebied onder het maaiveld zichtbaar.</p>"},{"location":"docs/handleiding/project-openen-opslaan/","title":"Project openen/opslaan","text":"<p>Het Project opslaan/openen-menu bevindt zich in de linker onder hoek en bevat de volgende functies;</p> <ul> <li><code>Project openen</code> </li> <li><code>Project opslaan</code> </li> </ul>"},{"location":"docs/handleiding/project-openen-opslaan/#project-opslaan","title":"Project opslaan","text":"<p>Met <code>Project opslaan</code> worden alle nieuwe instellingen, locatie, lagen etc. van de viewer opgeslagen. Met de knop <code>Project opslaan</code> wordt een venster geopend met aanvullende uitleg en de knop Bestand opslaan.</p> <p></p> <p>Met de knop <code>Bestand opslaan</code> worden de instellingen automatisch in een .nl3d bestand gedownload in de map <code>C:\\Users\\Gebruikersnaam\\Downloads</code>. </p>"},{"location":"docs/handleiding/project-openen-opslaan/#project-openen","title":"Project openen","text":"<p>Met de knop <code>Project openen</code> wordt een venster geopend met aanvullende uitleg en de knop <code>Bestand openen</code>. Hiermee wordt de Verkenner (Windows) of Finder (MacOS) geopend en kan een eerder gemaakt .nl3d-bestand worden geopend. Hierna zijn de in-het-.nl3d-bestand-opgeslagen instellingen, datalagen, locatie etc. weer actief. </p> <p></p> <p>Klik en sleep</p> <p>Projecten openen kan ook door ze vanuit de Verkenner/Finder te klikken en slepen naar de 3D Viewer. Best handig!</p> <p> </p>"},{"location":"docs/handleiding/toevoegen-3d-tiles/","title":"3D Tiles","text":"<p>Functies, Lagen, submenu.  </p> <p> 3D Tiles toevoegen</p>"},{"location":"docs/handleiding/toevoegen-3d-tiles/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":""},{"location":"docs/handleiding/toevoegen-3d-tiles/#menu","title":"Menu","text":"<p>Met de functie 3D Tiles kan je basis 3D Tiles lagen uit twee voorgedefinieerde lagen koppelen.</p> <p> Toevoegen / 3D Tiles</p>"},{"location":"docs/handleiding/toevoegen-3d-tiles/#gebouwen-3d-tiles","title":"Gebouwen (3D tiles)","text":"<p>Met <code>Gebouwen (3D tiles)</code> worden gebouwen uit de  3D Basisvoorziening van het Kadaster gekoppeld.  </p> <p> Gebouwen (3D Tiles)</p>"},{"location":"docs/handleiding/toevoegen-3d-tiles/#maaiveld-3d-tiles","title":"Maaiveld (3D tiles)","text":"<p>Met <code>Maaiveld (3D tiles)</code> wordt het maaiveld uit de  3D Basisvoorziening van het Kadaster gekoppeld.</p> <p> Maaiveld en Gebouwen (3D Tiles)</p>"},{"location":"docs/handleiding/toevoegen-3d-tiles/#referentiehoogte-aanpassen","title":"Referentiehoogte aanpassen","text":"<p>3D-Tile lagen kunnen op een verkeerde hoogte liggen. We hebben daarvoor een instelling gemaakt die je bij het eigenschappenpaneel kan activeren. Als standaard staat deze ingesteld op Ellipso\u00efde. Heb je een laag die op een verkeerde hoogte ligt, klik dan op \u00e9\u00e9n van de 2 mogelijkheden. </p> <p> Referentiehoogte op Ellipso\u00efde </p> <p> Referentiehoogte op Geo\u00efde </p> <p>Uitleg Referentiehoogte</p> <p>De hoogte van een 3D-tiles laag kan op twee manieren gemeten worden, ten opzichte van de ellipso\u00efde of de geo\u00efde. De referentiehoogte van de geo\u00efde ligt (voor Nederland) tussen de 41 en 44 meter boven de ellipso\u00efde. Voor meer informatie, zie deze site Uitleg Geo\u00efde/ellipso\u00efde</p>"},{"location":"docs/handleiding/toevoegen-basislagen/","title":"Basislagen","text":"<p>Functies, Lagen, submenu.  </p> <p> Basislagen activeren</p>"},{"location":"docs/handleiding/toevoegen-basislagen/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":""},{"location":"docs/handleiding/toevoegen-basislagen/#basislagen_1","title":"Basislagen","text":"<p>Met de functie Basislagen kan je de vier basislagen welke in de standaard/basisversie zijn gekoppeld opnieuw  toegevoegen. Het verwijderen van lagen kan gewoon in het lagenpaneel zelf, door de laag te selecteren en op de <code>prullebak</code> te klikken, of door de laag te selecteren en op <code>del</code> te drukken.</p> <p> de vier basislagen </p> <p> gekozen laag </p> <p>Als je \u00e9\u00e9n van de lagen aanklikt, voeg je die toe aan het lagenpaneel. Deze zijn zichtbaar als je de bibliotheek functie uitzet door op het <code>X</code> teken rechtsbovenin te klikken.</p>"},{"location":"docs/handleiding/toevoegen-fotorealistische-wereld/","title":"Fotorealistische Wereld","text":"<p>Functies, Lagen, Bibliotheek.  </p> <p> Fotorealistische Wereld activeren</p>"},{"location":"docs/handleiding/toevoegen-fotorealistische-wereld/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":"<p>Met de functie Fotorealistische Wereld kunnen de 3D tiles van Google Earth worden gekoppeld en gevisualiseerd in Netherlands3D.eu.</p>"},{"location":"docs/handleiding/toevoegen-fotorealistische-wereld/#toevoegen","title":"Toevoegen","text":"<p>Klik op <code>Fotorealistische Wereld</code> en de laag RealityMesh (3D Tiles) wordt toegevoegd. De laag is in het lagenpaneel te zien door het bibliotheekvenster weg te klikken (kruisje bovenaan). Klik dan op het Eigenschappenmenu en deze opent rechtsboven in het scherm. </p> <p> Utrecht CS in 3DBAG </p> <p>Waarom is de deze functie beschermd?</p> <p>NB! Aangezien de 3D Google Earth Tiles een betaalde (bij overschrijden van een maximaal gebruik per maand) service van Google is, kan deze functie niet zonder inlogcode of sleutel worden vrijgegeven.  </p> <p>  Klik op <code>Update</code> om verder te gaan.  </p>"},{"location":"docs/handleiding/toevoegen-fotorealistische-wereld/#met-gebruikersnaam-en-wachtwoord","title":"Met Gebruikersnaam en Wachtwoord","text":"<p>Toegangsscherm met Gebruikersnaam en Wachtwoord:  Toegangsscherm met gebruikersnaam en wachtwoord </p> <p>Bij andere datasets met Gebruikersnaam en wachtwoord kan je die hier invullen, maar bij de Fotorealistische wereld is alleen een API-key voldoende. </p>"},{"location":"docs/handleiding/toevoegen-fotorealistische-wereld/#met-api-key","title":"Met API-key","text":"<p>Klik op het vinkje in het <code>pull-down-menu</code> met het slotje naast Toegang bescherm... en het volgende menu verschijnt;  Toegangsscherm met Google-sleutel </p> <p>Plak de sleutel in het veld <code>Typen</code> en klik op <code>Bevestigen</code>. De 3D Tiles worden direct geladen. </p> <p>Ik heb geen toegangscode of sleutel. Wat kan ik doen?</p> <p>Indien er geen gebruikersnaam/wachtwoord beschikbaar is; Ga naar Google en maak via een eigen Google-account een 'sleutel\u2019 aan. Hoe je dat doet lees je hier (externe link); Aanmaken Google-sleutel. Check ook vooral de voorwaarden, in de meeste gevallen is het gebruik gratis (hangt af van hoeveelheid gebruik)</p> <p> Utrecht CS in Google Earth 3D Tiles </p> <p>Ik zie na het inloggen geen 3D Tiles in de viewer?</p> <p>NB! De Google Earth Tiles zijn (nog) niet voor heel Nederland zichtbaar/beschikbaar. Voor grote delen van Nederland geldt dat er alleen een \"platte\" satellietfoto beschikbaar is.  </p>"},{"location":"docs/handleiding/toevoegen-importeren/","title":"Importeren","text":"<p>Functies, Lagen, submenu.  </p> <p> Toevoegen / Importeren</p>"},{"location":"docs/handleiding/toevoegen-importeren/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":""},{"location":"docs/handleiding/toevoegen-importeren/#importeren-eigen-bestand","title":"Importeren Eigen bestand","text":"<p>De functie <code>Importeren</code> biedt de mogelijkheid om lagen en Objecten via het importeren van bestanden of via weblinks te koppelen.  Importeren Eigen bestand </p> <p>Met <code>Eigen bestand</code> kunnen .OBJ, .CSV, .JSON, .GEOJSON en .GLB bestanden worden gekoppeld. Na klikken op <code>Eigen bestand</code> opent de Verkenner (Windows)/Finder (MacOs) en kan het bestand worden geladen.  </p> <p>Drag and Drop</p> <p>Met klik en slepen van een bestand vanuit verkenner of Finder in het viewervenster, worden bovenstaande formaten ook ingeladen. LET OP: Dit kan niet met meerdere bestanden tegelijk.</p>"},{"location":"docs/handleiding/toevoegen-importeren/#importeren-bestand-via-url","title":"Importeren bestand via URL","text":"<p> Importeren bestand via URL </p> <p>Met Importeren bestand via URL kan je databronnen (WFS, WMS, GeoJSON, 3D-Tiles) via een weblink koppelen. Klik op <code>Bestand via URL</code>. Het menu; Laag toevoegen via URL wordt geopend.   Kopie\u00ebr en plak de link van het bestand in het vakje [URL link].  In de nabije toekomst is hier een link naar veelgebruikte WFS/WMS-lagen te vinden.</p> <p>Na <code>Toevoegen</code> is de link gekoppeld en de data zichtbaar in de 3D-Viewer.  </p>"},{"location":"docs/handleiding/toevoegen-importeren/#voorbeelden","title":"Voorbeelden","text":""},{"location":"docs/handleiding/toevoegen-importeren/#bestand-importeren-met-obj","title":"Bestand Importeren met .OBJ","text":"<p>Stap1. Klik op <code>Eigen bestand</code> en importeer het .OBJ-bestand.  Gedetailleerde Domtoren middels .OBJ ge\u00efmporteerd </p> <p>Na het importeren wordt het Object in de 3D omgeving en in de lijst onder Lagen zichtbaar.  </p> <p>Waarom heeft het geimporteerde Object niet de juiste afmetingen?</p> <p>De viewer neemt automatisch de ori\u00ebntatie en schaal van het Object (3D-model) zoals het is gemaakt over. Met de transformatie-tools kunnen de schaal en/of ori\u00ebntatie van het Object worden aangepast. Het is ook mogelijk om de schaal van het Object en/of ori\u00ebntatie in een extern 3D-programma zoals Blender aan te passen en opnieuw te importeren.   </p> <p>Stap 2a. Het geselecteerde Object kan met de transformatie-tools op de juiste locatie of aangepaste ori\u00ebntatie en schaal worden gebracht. Klik op het gekoppelde <code>Object</code> in Lagen en de transformatie-tool is geactiveerd.  Verplaatsen, roteren en verschalen met de transformatie-tool</p> <p>Stap 2b. Met de <code>Eigenschappen</code> -functie kan de locatie, ori\u00ebntatie en schaal van het geimporteerde Object handmatig worden ingevoerd.  </p> <p> Handmatig invoeren van locatie, ori\u00ebntatie en schaal. </p> <p>Stap 3. Met Bestand toevoegen kan het .mtl-bestand dat bij het .OBJ-bestand behoord aan het 3D-model gekoppeld. Hiermee wordt kleur- en textuur-informatie meegeladen met het 3D-model. Klik op <code>Bestand toevoegen</code> in het Eigenschappen-menu en selecteer het .mtl-bestand in de Verkenner/Finder.</p>"},{"location":"docs/handleiding/toevoegen-importeren/#bestand-bestand-via-url","title":"Bestand bestand via URL","text":"<p>Klik op Bestand via URL en koppel de link.  Voorbeeld 1;  Luchtfoto's van Nederland gekoppeld met WMS-link </p> <p> Voorbeeld 2;  Landelijke BRT kaart gekoppeld met WMS-link</p>"},{"location":"docs/handleiding/toevoegen-objecten-biep/","title":"Objecten bibliotheek","text":"<p>Functies, Lagen, submenu.  </p> <p> (Afbeelding) Toevoegen / Objecten bibliotheek</p>"},{"location":"docs/handleiding/toevoegen-objecten-biep/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":"<p>Met de functie Objecten bibliotheek kunnen verschillende standaard objecten worden toegevoegd.</p> <p>Je kunt kiezen uit:</p> <ul> <li>Annotatie</li> <li>Bomen / folder</li> <li>Camera Positie</li> <li>Kubus</li> <li>NAP Vlak</li> <li>Ontwikkeling Zuidoost</li> <li>Reuzenrad</li> <li>Windmolen</li> </ul> <p> Toevoegen objecten uit de Objecten bibliotheek</p>"},{"location":"docs/handleiding/toevoegen-objecten-biep/#annotatie","title":"Annotatie","text":"<p>Klik op <code>Annotatie</code> om een opmerking in de viewer te plaatsen. De annotatie start blanco. Door er op te dubbelklikken kan je deze met tekst vullen. Je kan er ook meerdere maken, zodat je notities of opmerkingen bij kan houden.</p> <p> Annotatie toevoegen</p> <p> Annotatie toegevoegd en ingevuld</p>"},{"location":"docs/handleiding/toevoegen-objecten-biep/#bomen","title":"Bomen","text":"<p>Klik op <code>Bomen</code> om in het submenu van bomen te komen.</p> <p> Bomen menu activeren</p> <p> Bomenkeuze; Amerikaanse Linde, Berk, Beuk of Canadapopulier</p> <p>Door te klikken op de verschillende bomen wordt een boom geplaatst in de viewer.</p> <p> Bomen; vlnr Amerikaanse Linde, Berk, Beuk of Canadapopulier</p>"},{"location":"docs/handleiding/toevoegen-objecten-biep/#camera-positie","title":"Camera Positie","text":"<p>Klik op <code>Camera Positie</code> om een camera in de viewer te plaatsen. Je plaatst de  camera met de op dat moment ingestelde hoogte en kijkhoek. Op deze manier kan je verschillende camera standpunten maken en bewaren in een project, om zo makkelijk een \"view-path\" naar keuze te kunnen maken. </p> <p> Camera Positie toevoegen</p> <p> Camera Positie</p>"},{"location":"docs/handleiding/toevoegen-objecten-biep/#kubus","title":"Kubus","text":"<p>Klik op <code>Kubus</code> om een kubus in de viewer zichtbaar te maken. De kubus heeft een standaardafmeting van 10x10x10 meter.</p> <p> Kubus toevoegen</p> <p> Kubus ObjectenBibliotheek</p>"},{"location":"docs/handleiding/toevoegen-objecten-biep/#nap-vlak","title":"NAP Vlak","text":"<p>Klik op <code>NAP Vlak</code> om een (horizontaal)vlak in de viewer zichtbaar te maken. Met dit vlak kun je de NAP hoogte van een terrein of gebouw bepalen of eenvoudig laten zien welke gebieden in Nederland kunnen overstromen als de dijken doorbreken.</p> <p> NAP Vlak toevoegen</p> <p> NAP Vlak</p>"},{"location":"docs/handleiding/toevoegen-objecten-biep/#ontwikkeling-zuidoost","title":"Ontwikkeling Zuidoost","text":"<p>De functie Ontwikkeling Zuidoost is een bijzonder onderdeel van de Objecten Bibliotheek. Met deze functie worden de Nieuwbouwontwikkelingen in het gebied Amsterdam-Zuidoost in de viewer gekoppeld. Klik op <code>Ontwikkeling Zuidoost</code> om deze te activeren.</p> <p> Ontwikkeling Amsterdam-Zuidoost toevoegen</p> <p> Ontwikkeling Amsterdam-Zuidoost</p>"},{"location":"docs/handleiding/toevoegen-objecten-biep/#reuzenrad","title":"Reuzenrad","text":"<p>Klik op <code>Reuzenrad</code> om een draaiend Reuzenrad in de viewer zichtbaar te maken.  </p> <p> Reuzenrad ObjectenBibliotheek</p> <p> Reuzenrad ObjectenBibliotheek</p>"},{"location":"docs/handleiding/toevoegen-objecten-biep/#windmolen","title":"Windmolen","text":"<p>Klik op <code>Windmolen</code> om een Windmolen met draaiende rotor in de viewer zichtbaar te maken. De Windmolen heeft een standaardhoogte van 70 meter met een Rotordiameter van 54.50 meter. De afmetingen zijn aanpasbaar in het Instellingen menu van de Windmolen.</p> <p> Windmolen toevoegen</p> <p> Windmolen</p>"},{"location":"docs/handleiding/toevoegen-selectiegebied/","title":"Tekengebied","text":"<p>Functies, Lagen, submenu.  </p> <p> Tekengebied activeren</p>"},{"location":"docs/handleiding/toevoegen-selectiegebied/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":"<p>Met deze functie kan je \u00e9\u00e9n of meerdere polygonen (gebieden),  lijnen of grids intekenen.  drie keuzes polygoon, lijn of grid</p> <p>Klik op <code>Tekengebied</code> om te kiezen tussen het tekenen van een Polygoon, lijn of grid in de 3D-Viewer.</p>"},{"location":"docs/handleiding/toevoegen-selectiegebied/#polygoon","title":"Polygoon","text":"<p>Klik op <code>Polygoon</code> en een kleine witte bol verschijnt bij de muisaanwijzer in het 3D scherm. Klik en teken hiermee het volledige veelvlak of polygoon. Sluit het vlak door na het aanbrengen van meerdere punten op de laatste punt te klikken. Hierdoor wordt het vlak ingekleurd. Door op een van de punten te klikken kan je het vlak aanpassen. </p> <p> Intekenen polygoon </p> <p>Je kan meerdere Tekengebieden intekenen.  </p>"},{"location":"docs/handleiding/toevoegen-selectiegebied/#verspreid-objecten-in-gebied","title":"Verspreid objecten in gebied","text":"<p>Door een object zoals bijvoorbeeld een boom uit de Objectenbibliotheek toe te voegen aan de laag polygoon, activeert de functie Verspreid objecten in gebied </p> <p> Activeren functie Verspreid objecten in gebied. </p> <p>Doorloop de volgende stappen;  </p> <ul> <li>Voeg een object (boom) toe uit de Objectenbibliotheek,  </li> <li>Sleep het object in Lagen op het polygoon,  </li> <li>klik op <code>eigenschappen</code> van het object,  </li> <li>vink <code>Verspreid objecten in gebied</code> aan,  </li> <li>pas eventueel de Eigenschappen van Verspreiden object aan.  </li> </ul>"},{"location":"docs/handleiding/toevoegen-selectiegebied/#lijn","title":"Lijn","text":"<p>Klik op <code>Lijn</code> en een kleine witte bol verschijnt bij de muisaanwijzer in het 3D scherm. Klik in het scherm en teken hiermee de lijn door het eindpunt op de gewenste plek te plaatsen. [Kleuren aanpassen?] Door op \u00e9\u00e9n van de eindpunten te klikken kan je de lijn aanpassen.  </p> <p> Intekenen lijn </p> <p>De lijndikte kan worden aangepast door op het <code>instellingen-icoon</code> te klikken. Het Eigenschappenmenu verschijnt waarmee de lijndikte van 1.00 tot 200.00 meter kan worden aangepast. Standaard is de dikte 10.00 meter.  </p> <p> Eigenschappen </p> <p>Je kan meerdere lijnen intekenen.  </p>"},{"location":"docs/handleiding/toevoegen-selectiegebied/#grid","title":"Grid","text":"<p>Klik op <code>Grid</code> en je kan met de muis, in combinatie met de linkermuisknop en shift-toets een selectiegebied selecteren.  </p> <p> Meerdere secties van 100x100 geselecteerd. </p> <p> Gridlaag toegevoegd. </p> <p> Eigenschappen gridlaag. </p> <p> Gebied uitsnijden in gridlaag. </p> <p> Uitgesneden gebied omdraaien. </p> <p>Je kan meerdere grids intekenen.</p> <p>Masking and Clipping</p> <p>Bovenstaande handelingen kan je met alle selectiemogelijkheden uitvoeren. Dus ook met een polygoon en een lijn. Zo kan je meerdere gebieden uitsnijden of highlighten. </p> <p>Achteraf kan je de geselecteerde lijn(en), gebied(en) en grid(s) ook aanpassen. Bij lijnen en gebieden kan je de laag selecteren en de zichtbare punten oppakken en verplaatsen en bij een grid kan je een nieuwe selectie maken.</p> <p> Mogelijkheden uitgesneden gebieden.</p>"},{"location":"docs/handleiding/toevoegen-urban-releaf/","title":"Urban ReLeaf","text":"<p>Functies, Lagen, submenu.  </p> <p> Urban ReLeaf activeren</p>"},{"location":"docs/handleiding/toevoegen-urban-releaf/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":"<p>Met de functie Urban ReLeaf kan je de resultaten van het Klimaatonderzoek dat van 1 juli tot en met 31 augustus 2024 is uitgevoerd in de Provincie Utrecht koppelen en visualiseren.  </p> <p>Het klimaat is op drie factoren gemeten in de zones die als hexagoon worden weergegeven;</p> <ul> <li>Temperatuur  </li> <li>Vochtigheid  </li> <li>Thermisch ongemak  </li> </ul> <p>De kleur van de hexagoon vertegenwoordigd een gemiddelde van de gemeten waarden het gebied.</p> <p>Als je op een hexagoon klikt, zie je de gemeten waarde in de ingestelde periode en het aantal metingen. Hoe meer metingen, hoe hoger de hexagoon omhoog komt.</p>"},{"location":"docs/handleiding/toevoegen-urban-releaf/#toevoegen","title":"Toevoegen","text":"<p>Klik op <code>Temperatuur</code>, <code>Vochtigheid</code> en/of <code>Thermisch ongemak</code> en de bijbehorende laag wordt toegevoegd en de hexagonen geladen.  </p> <p> Toevoegen / Urban ReLeaf</p>"},{"location":"docs/handleiding/toevoegen-urban-releaf/#instellingen","title":"Instellingen","text":"<p>Klik bij de Lagen op het <code>instellingen-icoon</code> en je kan de eigenschappen van de (temperatuur) weergave aanpassen.  </p> <p> Eigenschappen van de hexagon-weergave </p> <p>Datum  Met het aanpassen van de <code>Start datum</code> en/of de <code>Eind datum</code> kunnen de uitkomsten van een in \u2013te-stellen periode worden weergegeven. Standaard zijn de uitkomsten van de start tot het eind van het onderzoek weergegeven.  </p> <p>Waarden Met het aanpassen van <code>Minimum waarde</code> en/of <code>Maximum waarde</code> \u2013 door de schuif naar links of naar rechts te verplaatsen - worden de gebieden die binnen de in-te-stellen bandbreedte vallen weergegeven. Met de <code>kleuren-tool</code> kan het kleurenverloop van minimum- naar maximumwaarde worden aangepast. Weergave uitkomsten Temperatuurmeting Urban ReLeaf   Kijk op https://urbanreleaf.eu/ voor meer informatie.  </p>"},{"location":"docs/handleiding/zoeken/","title":"Zoekfunctie","text":"<p>Functie, hoofdmenu.</p> <p></p> <p>     Met de zoekfunctie kan je, naast de zoekfunctie in het instellingenmenu,      ook binnen de 3D Viewer direct zoeken naar een adres of locatie.   </p>"},{"location":"docs/handleiding/zoeken/#gedetailleerde-beschrijving-van-de-functie","title":"Gedetailleerde beschrijving van de functie","text":""},{"location":"docs/handleiding/zoeken/#zoekbalk","title":"Zoekbalk","text":"<p>Na het klikken op het vergrootglas opent de zoekbalk.</p> <p></p> <p>(Afbeelding) Zoekbalk geopend </p>"},{"location":"docs/handleiding/zoeken/#zoekresultaat","title":"Zoekresultaat","text":"<p>Tijdens het invullen van een plaats of adres, vindt het systeem al de eerste resultaten. Staat de gewenste plaats of adres er al tussen, dan kan je direct op het resultaat klikken om deze te activeren. De camera springt dan direct naar de gekozen locatie.</p> <p></p> <p>(Afbeelding) Zoekbalk resultaat </p>"},{"location":"docs/handleiding/zonnestand/","title":"Zonnestand","text":"<p>Functies, hoofdmenu. </p> <p></p> <p>Zonnestand is een zon- en schaduw-simulatie tool die is ontwikkeld om gebruikers te helpen de impact van zonlicht en schaduwen in datalagen en ontwerpen op een specifieke locatie eenvoudig te visualiseren. Door gebruikers in staat te stellen basisparameters in te voeren, zoals tijd en datum, genereert Zonnestand real-time schaduwprojecties, waardoor het toegankelijk is voor data-specialisten, ontwerpers, docenten en hobbyisten.  Dit hoofdstuk beschrijft de belangrijkste functies van Zonnestand geeft uitleg over de interface en essenti\u00eble functies. Daarnaast is het mogelijk om een schaduwstudie te maken met de functie Schaduwstudie. Hiermee is het mogelijk om van de standaard 12 momenten in het jaar een schermafbeelding te maken en deze te downloaden via een .zip bestand. Deze afbeelding zijn bijvoorbeeld te gebruiken in stedenbouwkundige rapporten.</p>"},{"location":"docs/handleiding/zonnestand/#overzicht-van-functies","title":"Overzicht van functies","text":"<p>Door het aanpassen van datum en tijd wordt de zonnestand realistisch weergegeven voor de gekozen locatie en het gekozen moment. Met animatie tijdverloop wordt het verloop van de schaduw gedurende de dag en nacht realistisch weergegeven. De snelheid van het verloop is instelbaar. </p> <p>(Video) functie Zonnestand</p>"},{"location":"docs/handleiding/zonnestand/#gedetailleerde-beschrijving-van-de-functies","title":"Gedetailleerde beschrijving van de functies","text":""},{"location":"docs/handleiding/zonnestand/#menu","title":"Menu","text":"<p>Door met de muis op het <code>Zonnestand-icoon</code> in het hoofdmenu te klikken wordt de tool actief. Het menu klapt open en de instellingen worden zichtbaar.</p> <p> (Afbeelding) Zonnestand-menu</p>"},{"location":"docs/handleiding/zonnestand/#werking","title":"Werking","text":"<ul> <li>Pull down    Door op de <code>pijl</code> te klikken wordt het menu <code>Tijd en datum aanpassen</code> ingeklapt. Door vervolgens weer op de <code>pijl</code> te klikken klapt het menu <code>Tijd en datum aanpassen</code> uit.</li> </ul> <ul> <li>Tijd en Datum 1    Vul het gewenste tijdstip bij <code>Tijd</code>    in <code>uur:minuut</code> en de gewenste datum bij <code>Datum</code> in <code>dag:maand;jaaren</code> en druk op <code>enter</code>.</li> </ul> <p>Het effect van de nieuwe zonnestand en bijbehorende schaduwval zijn direct zichtbaar.</p> <ul> <li>Tijd en Datum 2    Door het <code>Zon-icoon</code> handmatig over de gestippelde boog te verslepen wordt de zonnestand en bijbehorend tijdstip aangepast. Zonnestand houdt hierbij automatisch rekening met zonsopgang en \u2013ondergang. Zodra het tijdstip zich tussen zonsondergang en \u2013opgang bevindt, verandert het icoon in een maan. </li> </ul> <p></p> <p>In het geval het tijdstip zich tussen zonsondergang en \u2013opgang bevindt, is er geen schaduw zichtbaar.</p> <ul> <li>Tijd en Datum (herstel)   Door op het icoon <code>Herstel tijd en datum</code> te klikken wordt de actuele datum en tijd van het computersysteem van de gebruiker overgenomen.</li> </ul> <p></p> <ul> <li>Animatie tijdverloop realtime    Standaard staat de Snelheid animatie ingesteld op <code>realtime</code>. De <code>pauze- en afspeelknop</code> hebben geen functie.</li> </ul> <p></p> <ul> <li>Animatie tijdverloop uur per seconde    Door in het pull down menu te kiezen voor <code>uur per seconde</code> kan de animatie van het verloop van de zon vanaf de ingestelde datum en tijdstip worden gestart met de <code>afspeelknop</code>. De andere knoppen van de interface worden dan ook actief.   Met de <code>pauze knop</code> kan de animatie worden gestopt. Met de <code>forward</code> resp. <code>backward</code> knop kan de snelheid van de animatie met hele stappen van 1 uur per seconde worden versneld resp. vertraagd.</li> </ul> <p></p> <p>Opslaan instellingen De instellingen van de functie Zonnestand zijn onderdeel van het Netherlands 3D bestand en worden opgeslagen met de functie <code>Project Opslaan</code>.</p>"},{"location":"docs/handleiding/zonnestand/#schaduwstudie","title":"Schaduwstudie","text":"<p>Pull down  Door op de <code>pijl</code> te klikken wordt het menu <code>schaduwstudie</code> ingeklapt. Door vervolgens weer op de <code>pijl</code> te klikken klapt het menu <code>schaduwstudie</code> uit.</p> <p></p> <p>Download  Door op de knop <code>download</code> te klikken wordt een serie van 12 afbeeldingen gegenereerd volgens onderstaande normen en vervolgens verzameld in een <code>.zip</code> bestand met als naam <code>2025-03-05-T15-00-Schaduwstudie.zip</code> </p> <p></p> <p>De functie maakt afbeeldingen van de actuele camerastandpunt, dus houd er rekening mee dat de resultaten afhankelijk zijn van de keuze van het camerastandpunt.</p>"},{"location":"docs/handleiding/zonnestand/#verantwoording","title":"Verantwoording","text":"<p>Data en tijdstippen</p> <p>Hoewel voor de bezonningsuren overal de TNO-norm wordt aangehouden, is er voor de schaduwstudie geen offici\u00eble standaard. Wel wordt deze set data en tijden gebruikt door de meeste gemeenten en online tools: 21 maart en 23 september (halverwege tussen kortste en langste dag) 21 juni (dag met de meeste zonuren) 22 december (dag met de minste zonuren)</p> <ul> <li>21-03 (en/of 23-09) om 09:00u</li> <li>21-03 (en/of 23-09) om 12:00u</li> <li>21-03 (en/of 23-09) om 15:00u</li> <li>21-03 (en/of 23-09) om 18:00u</li> <li>21-06 om 09:00u</li> <li>21-06 om 12:00u</li> <li>21-06 om 15:00u</li> <li>21-06 om 18:00u</li> <li>21-06 om 20:00u</li> <li>22-12 om 09:00u</li> <li>22-12 om 12:00u</li> <li>22-12 om 15:00u</li> </ul> <p>Meer informatie over schaduwstudies en bezonning, staat op deze website https://iplo.nl/thema/licht/bezonning/</p> <p>Bepaling Zonnestand</p> <p>Algemeen Voor het bepalen van de zonnestand maken we gebruik van het NOAA Solar Position Algorithm (SPA). Voor meer informatie kijk op https://gml.noaa.gov/grad/solcalc/index.html</p> <p>Beheer van tijdzones en zonnestand berekening</p> <p>We maken gebruik van een eigen oplossing, omdat deze standaard niet in Unity beschikbaar is: voor meer informatie kijk op de tab voor organisaties https://netherlands3d.eu/docs/organisations/netherlands3d-platform/</p>"},{"location":"docs/organisations/cors/","title":"Mijn URL wil niet importeren door CORS, en nu?","text":"<p>Wat is CORS? Cross-Origin Resource Sharing (CORS) is een beveiligingsmechanisme dat webapplicaties beschermt door te controleren of ze verbinding mogen maken met een server op een ander domein dan het domein van de webapplicatie zelf. Zonder CORS zou een website toegang kunnen krijgen tot data van andere servers zonder toestemming, wat veiligheidsrisico\u2019s met zich meebrengt. In de praktijk betekent dit dat u, als beheerder van een webservice, uw server moet configureren om expliciet toestemming te geven aan externe toepassingen die uw data willen gebruiken.</p> <p>Waarom is CORS Configuratie Uw Verantwoordelijkheid Omdat CORS een beveiligingsmaatregel is van en voor de  data-aanbieder, kan de configuratie niet vanuit een Netherlands3D viewer worden ingesteld. Webapplicaties, zoals een  Netherlands3D viewer, moeten toegang tot data krijgen via de server die deze data aanbiedt. Zonder CORS-headers  blokkeert de browser toegang om de privacy en veiligheid van de server te waarborgen.</p> <p>Waarom hebben desktopapplicaties zoals QGIS geen last van CORS?</p> <p>CORS-beperkingen gelden alleen voor webbrowsers die webapplicaties beschermen tegen ongeautoriseerde toegang tot  data. Desktopapplicaties zoals QGIS communiceren rechtstreeks met servers zonder de CORS-beperkingen van  webbrowsers en kunnen daardoor zonder beperkingen externe data ophalen.</p>"},{"location":"docs/organisations/cors/#configureer-cors-in-uw-applicatie-of-webserver","title":"Configureer CORS in uw Applicatie of Webserver","text":"<p>Wat moet u doen? Om CORS toe te staan, moet u specifieke HTTP-headers configureren in de webserver of  applicatieserver. De belangrijkste header is: <code>Access-Control-Allow-Origin: *</code> (of in plaats van <code>*</code> een specifieke  domeinnaam, zoals https://netherlands3d.eu). </p> <p>Afhankelijk van de technologie, zoals MapServer of ArcGIS Server, kunt u deze headers toevoegen in de  serverinstellingen of in configuratiebestanden.</p> <p>Voorbeeldinstellingen in MapServer en ArcGIS:</p> <ul> <li> <p>MapServer: Voeg de CORS-headers toe in de configuratie door de mapfile aan te passen of via de    webserverconfiguratie (bijv. Apache).</p> </li> <li> <p>ArcGIS Server: Open de service-instellingen in ArcGIS Manager en configureer de CORS-headers onder    \"Allowed Origins\".</p> </li> </ul>"},{"location":"docs/organisations/cors/#verificatie-van-de-cors-configuratie","title":"Verificatie van de CORS Configuratie","text":"<ol> <li>Open Google Chrome en ga naar de Inspect-tool (rechterklik op de pagina &gt; Inspecteren).</li> <li>Ga naar het Network-tabblad en laad de pagina van uw webservice.</li> <li>Zoek naar de aanvraag die uw webservice adresseert, klik erop en kijk onder Headers.</li> <li>Onder \"Response Headers\" zou u <code>Access-Control-Allow-Origin</code> moeten zien staan. Als de header correct geconfigureerd     is, staat hier het domein dat u heeft toegestaan of een <code>*</code> voor alle domeinen.</li> </ol> <p>Met deze stappen zorgt u ervoor dat uw data veilig toegankelijk is voor webapplicaties die de juiste toegang nodig  hebben.</p>"},{"location":"docs/organisations/netherlands3d-platform/","title":"Netherlands3D Platform","text":"<p>De visie van Netherlands3D is 3D Data Visualisatie van Nederland voor Iedereen.</p> <p>Hoe bereiken we dit?</p> <ul> <li>Open Web Platform: Een open omgeving waar 3D-data eenvoudig kan worden samengebracht door eindgebruikers en   organisaties.</li> <li>Beheerde Web Omgeving: Ontzorging voor organisaties die hun 3D-data willen tonen in een beheerde omgeving.</li> <li>Integraties: Ontzorging voor Unity ontwikkelaars om eigen integraties te ontwikkelen voor hun eigen data.</li> </ul> <p>Dit maken we mogelijk door het platform in drie edities aan te bieden:</p> <ul> <li>Netherlands3D Community: een gedeelde omgeving, direct beschikbaar voor iedereen.</li> <li>Netherlands3D Cloud: een eigen omgeving, door ons beheerd of binnen de eigen organisatie.</li> <li>Netherlands3D Developer: Een opensource platform op Github waar je integraties kunt ontwikkelen of een volledig   aangepaste viewer kunt maken.</li> </ul> <p>Middels deze drie edities kunnen organisaties 3D-data visualiseren in een gedeelde of eigen Netherlands3D viewer, of integraties ontwikkelen om hun eigen 3D-data te tonen.</p>"},{"location":"docs/organisations/netherlands3d-platform/#keuzehulp","title":"Keuzehulp","text":"<p>Om een indruk te geven welke editie van Netherlands3D past voor jouw organisatie, is hier een overzicht van  eigenschappen:</p> Community CloudEigen Beheer CloudBeheerd door ons Developer Direct gebruiksklaar Installatie wordt door ons verzorgd Eigen domeinnaam mogelijk Volledig in eigen beheer Geen ontwikkelaars nodig Geen cloud platform expertise nodig Personalisering mogelijk <sup>1</sup> Eigen lagen bij openen beschikbaar Maatwerk mogelijk Ondersteuning <sup>2</sup> <sup>3</sup> Kosten Gratis Gratis<sup>4</sup> Variabel Gratis / Open Source Updates Automatisch Handmatig Automatisch Handmatig <p>*<sup>1</sup> Beperkte personalisering opties zijn in ontwikkeling. *<sup>2</sup> Community editie heeft ondersteuning voor het beschikbaar zijn van de applicatie. *<sup>3</sup> Developer editie heeft community ondersteuning. *<sup>4</sup> Kosten voor gebruik van het platform zijn gratis, bij eigen beheer komen kosten van de eigen hosting    daar wel bij </p> <p>Elk van deze edities bevat dezelfde functionaliteiten in de viewer. Welke functionaliteiten beschikbaar zijn is te vinden op ons overzicht.</p>"},{"location":"docs/organisations/netherlands3d-platform/#welke-editie-past-bij-jouw-behoefte","title":"Welke editie past bij jouw behoefte?","text":"<ul> <li>Netherlands3D Community: Voor als je wil uitproberen, even snel een toegestuurd project wil bekijken of een    makkelijke instap zoekt.</li> <li>Netherlands3D Cloud: Voor als je een eigen omgeving wilt met extra beheermogelijkheden.</li> <li>Netherlands3D Developer: Voor als je volledige controle wilt over je 3D-visualisaties en maatwerkoplossingen    nodig hebt.</li> </ul>"},{"location":"docs/organisations/solarstudy-calculation/","title":"Verantwoording zonnestudie berekening","text":""},{"location":"docs/organisations/solarstudy-calculation/#beheer-van-tijdzones-en-zonnestand-berekening-in-unity","title":"Beheer van tijdzones en zonnestand berekening in Unity","text":"<p>Om tijdzones correct te beheren en de zonnestand nauwkeurig te berekenen, is een aangepaste oplossing ge\u00efmplementeerd in Unity. Deze oplossing maakt gebruik van een externe package voor tijdzonebepaling op basis van geografische co\u00f6rdinaten en twee aanvullende datasets met historische en toekomstige tijdzone-offsets.</p>"},{"location":"docs/organisations/solarstudy-calculation/#tijdzonebepaling-op-basis-van-coordinaten","title":"Tijdzonebepaling op basis van co\u00f6rdinaten","text":"<ul> <li>Er is een aangepaste versie van de GeoTimeZone-package gebruikt (oorspronkelijk van GitHub: mattjohnsonpint/GeoTimeZone).</li> <li>Deze package converteert latitude/longitude-co\u00f6rdinaten naar een IANA time zone identifier (bijv. Europe/Amsterdam).</li> <li>Dit maakt de implementatie OS-onafhankelijk, waardoor er geen verschillen meer zijn tussen Windows (bijv. W. Europe Standard Time) en andere systemen.</li> <li>De tijdzonegegevens worden uit een bestand in de Resources map uitgelezen en in Unity geladen. Dit bestand bevat een vast aantal gegevens en moet handmatig worden ge\u00fcpdatet om veranderingen in de tijdzones en de zomer/wintertijd te bevatten die sinds 2019 mogelijkerwijs plaats hebben gevonden.</li> </ul>"},{"location":"docs/organisations/solarstudy-calculation/#tijdzone-offsets-en-historische-data","title":"Tijdzone-offsets en historische data","text":"<ul> <li>De aanvullende datasets bevat IANA time zones en hun UTC-offsets voor verschillende tijdsperiodes.</li> <li>Voor Nederland omvat deze dataset de periode \"1916 tot 2037.\"</li> <li>Ook deze datasets zijn op de Unity-manier ingeladen en verwerkt.</li> </ul>"},{"location":"docs/organisations/solarstudy-calculation/#verbeterde-zonnestand-berekening","title":"Verbeterde zonnestand berekening","text":"<ul> <li>Voorheen zat er een bug in omdat de tijdzone conversie niet werkte in WebGL, waardoor de zonnestand een afwijking had van 1 of 2 uur (afhankelijk van de zomer/wintertijd) omdat de tijd altijd als UTC tijd werd ge\u00efnterpreteerd, in plaats van de tijd die voor Amsterdam geldt (Central European Time, CET).</li> <li>Nu is ook de tijdzone van de floating origin meegenomen in de berekening.</li> <li>Dit zorgt ervoor dat de tijd correct is omgerekend naar UTC, wat resulteert in een nauwkeurigere zonnestand in de simulatie.</li> </ul> <p>Conclusie</p> <p>Door deze aanpak is tijdzonebeheer verbeterd en is de zonnestandberekening betrouwbaarder en consistenter over verschillende platforms en tijdzones.</p>"},{"location":"docs/voorbeelden/","title":"Onboarding","text":"<p>Het hoofdstuk Onboarding van Netherlands3D.eu is speciaal opgezet voor gebruikers om stap voor stap te helpen bij het inrichten van de viewer voor specifieke cases.</p> <p>Het proces van inrichten wordt in heldere stappen uitgelegd en ondersteund door filmpjes.</p>"},{"location":"docs/voorbeelden/#onder-ontwikkeling","title":"Onder ontwikkeling","text":"<p>We werken momenteel aan de ontwikkeling van deze sectie om een uitgebreide lijst van  cases te beschrijven. Het doel is om gebruikers en organisaties te ondersteunen met deze onboarding documentatie bij het gebruik van het Netherlands3D platform.</p> <p>Blijf op de hoogte voor updates en verbeteringen aan deze sectie. We kijken ernaar uit om te voorzien in de informatie en hulpmiddelen die nodig zijn om goed gebruik te maken van Netherlands3D.</p>"},{"location":"docs/voorbeelden/3d-tiles-importeren/","title":"Importeren van een 3D Tiles-link","text":"<p>Deze documentatie helpt je stap voor stap bij het importeren van 3D Tiles in Netherlands3D. Houdt de link - dit is vaak een url - bij de hand.</p>"},{"location":"docs/voorbeelden/3d-tiles-importeren/#stap-1-open-de-3d-viewer","title":"Stap 1. Open de 3D-Viewer","text":"<p>Ga naar https://netherlands3d.eu, klik op de knop <code>Bekijk de viewer</code> en de 3D-viewer wordt geopend.</p> <p></p> <p>(Afbeelding) Homepage  </p> <p></p> <p>(Afbeelding) 3D-Viewer startscherm; instellingen-menu</p>"},{"location":"docs/voorbeelden/3d-tiles-importeren/#stap-2-klik-op-de-plus","title":"Stap 2. Klik op de plus","text":"<p>(Afbeelding) Basislagen &amp; functionaliteiten</p> <ul> <li>Het lagen paneel klapt open en de basislagen (links boven) en de functies (links onder) worden zichtbaar.</li> <li>Het Toevoegen-menu en de verschillende teken-, koppel- en importmogelijkheden worden (gedeeltelijk) zichtbaar.</li> </ul>"},{"location":"docs/voorbeelden/3d-tiles-importeren/#stap-3-bestand-toevoegen-met-url","title":"Stap 3. Bestand toevoegen met url","text":"<p>(Afbeelding) Toevoegen / Importeren</p> <p>Klik op <code>Importeren</code>. Het menu; Toevoegen Importeren wordt geopend.  </p> <p></p> <p>(Afbeelding) Bestand via URL</p> <p>Klik op <code>Bestand via URL</code>. Het menu Laag toevoegen via URL wordt geopend.  </p> <p> </p> <p>(Afbeelding) Kopi\u00ebren en plakken van URL</p> <p>Kopie\u00ebr en plak de link van het bestand in het vakje [URL link] en klik op <code>Toevoegen</code>.</p>"},{"location":"docs/voorbeelden/3d-tiles-importeren/#stap-4-navigeer-naar-de-3d-tiles-data","title":"Stap 4. Navigeer naar de 3D Tiles-data","text":"<p>Na <code>Toevoegen</code> is de link gekoppeld en is de laag zichtbaar in het <code>Lagen</code> paneel.</p> <p>Ga naar de locatie waar de 3D Tiles-link betrekking op heeft om de 3D Tiles laag in de 3D-Viewer te bekijken.</p> <p>Sla het project op met <code>Project Opslaan</code> (links onder) om de koppeling te bewaren.</p> <p>Snel naar locatie van de data</p> <p>Bij datasets die alleen data op een bepaalde locatie omvatten kan je ook dubbelklikken op de nieuwe laag. De camera verplaatst dan naar de locatie waar de data zich bevind.</p>"},{"location":"docs/voorbeelden/wms-wfs/","title":"Importeren van een WMS/WFS-link","text":"<p>Deze documentatie helpt je stap voor stap bij het koppelen van een WMS/WFS-link in Netherlands3D. Houdt de link - dit is vaak een url - bij de hand.</p> <p>Info</p> <p>De link bevat meestal de term <code>?service=WFS&amp;request=GetCapabilities</code> of <code>?service=WMS&amp;request=GetCapabilities</code>. Is  dat niet het geval en je ontvangt een foutmelding bij het importeren? Probeer een van deze twee toe te voegen aan  je link.  </p>"},{"location":"docs/voorbeelden/wms-wfs/#instructie-video","title":"Instructie-video","text":"<p>In onderstaande video wordt stap voor stap het toevoegen van een WMS/WFS-link uitgelegd.</p> <p>(Video) toevoegen WMS/WFS-link</p>"},{"location":"docs/voorbeelden/wms-wfs/#stap-1-open-de-3d-viewer","title":"Stap 1. Open de 3D-Viewer","text":"<p>Ga naar https://netherlands3d.eu, klik op de knop <code>Bekijk de viewer</code> en de  3D-viewer wordt geopend.</p> <p></p> <p>(Afbeelding) Homepage  </p> <p></p> <p>(Afbeelding) 3D-Viewer startscherm; instellingen-menu</p>"},{"location":"docs/voorbeelden/wms-wfs/#stap-2-klik-op-de-plus","title":"Stap 2. Klik op de plus","text":"<p>(Afbeelding) Basislagen &amp; functies</p> <ul> <li>Het lagen paneel klapt open en de basislagen (links boven) en de functies (links onder) worden zichtbaar.</li> <li>Het Toevoegen-menu en de verschillende teken-, koppel- en importmogelijkheden worden (gedeeltelijk) zichtbaar.</li> </ul>"},{"location":"docs/voorbeelden/wms-wfs/#stap-3-bestand-toevoegen-met-url","title":"Stap 3. Bestand toevoegen met url","text":"<p>(Afbeelding) Toevoegen / Importeren</p> <p>Klik op <code>Importeren</code>. Het menu; Toevoegen Importeren wordt geopend.  </p> <p></p> <p>(Afbeelding) Bestand via URL</p> <p>Klik op <code>Bestand via URL</code>. Het menu Laag toevoegen via URL wordt geopend.  </p> <p> </p> <p>(Afbeelding) Kopi\u00ebren en plakken van URL</p> <p>Kopie\u00ebr en plak de link van het bestand in het vakje [URL link] en klik op <code>Toevoegen</code>.</p>"},{"location":"docs/voorbeelden/wms-wfs/#stap-4-navigeer-naar-de-wmswfs-data","title":"Stap 4. Navigeer naar de WMS/WFS-data","text":"<p>Na <code>Toevoegen</code> is de link gekoppeld en zijn de sublagen (in het geval van een WFS) in Lagen zichtbaar. Ga naar de locatie waar de WMS/WFS-link betrekking op heeft om de WMS/WFS-Laag in de 3D-Viewer te bekijken.</p> <p>Sla het project op met <code>Project Opslaan</code> (links onder) om de koppeling te bewaren.</p> <p>Snel naar locatie van de data</p> <p>Bij datasets die alleen data op een bepaalde locatie omvatten kan je ook dubbelklikken op de nieuwe laag. De camera verplaatst dan naar de locatie waar de data zich bevind.</p>"},{"location":"articles/archive/2024/","title":"2024","text":""},{"location":"articles/nieuws/","title":"Nieuws","text":""}]}